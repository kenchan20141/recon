<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <!-- SECURITY: Content Security Policy (CSP) -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net https://www.gstatic.com https://cdn.jsdelivr.net/npm/@tensorflow/ ; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com ; font-src https://fonts.gstatic.com ; img-src 'self' data: blob:; media-src 'self' https://actions.google.com blob:; connect-src https://*.firebaseio.com https://justadudewhohacks.github.io https://cdn.jsdelivr.net https://tfhub.dev https://storage.googleapis.com wss://*.firebaseio.com;">
    <title>AI RECON - Dual Mode Monitor</title>

    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

    <!-- TensorFlow & Handpose -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.10.0/dist/tf-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@4.10.0/dist/tf-converter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@0.0.7/dist/handpose.min.js"></script>
    <!-- Backend for TFJS -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.10.0/dist/tf-backend-webgl.min.js"></script>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary-color: #00f3ff;
            --secondary-color: #ff0055;
            --success-color: #00ff9d;
            --warning-color: #ffcc00;
            --bg-color: #050505;
            --panel-bg: rgba(15, 25, 35, 0.98);
            --font-main: 'Orbitron', sans-serif;
            --font-data: 'Rajdhani', sans-serif;
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 0;
            background-color: var(--bg-color);
            background-image: linear-gradient(rgba(0, 243, 255, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 243, 255, 0.05) 1px, transparent 1px);
            background-size: 30px 30px;
            color: var(--primary-color);
            font-family: var(--font-main);
            height: 100vh;
            display: flex; flex-direction: column; align-items: center; overflow-x: hidden;
            font-size: 16px; 
            padding-bottom: 40px;
        }

        /* HEADER */
        header {
            width: 100%; padding: 10px 20px;
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 2px solid var(--primary-color);
            background: rgba(0,0,0,0.85); backdrop-filter: blur(10px); z-index: 100;
        }
        
        .brand { font-size: 1.4rem; letter-spacing: 2px; text-shadow: 0 0 10px var(--primary-color); font-weight: 700; white-space: nowrap; }
        .status-bar { display: flex; gap: 20px; font-family: var(--font-data); font-size: 1.2rem; font-weight: 600; white-space: nowrap; align-items: center; }

        .led { width: 10px; height: 10px; border-radius: 50%; background: #333; box-shadow: 0 0 5px #333; transition: 0.3s; }
        .led.on { background: var(--primary-color); box-shadow: 0 0 15px var(--primary-color); }
        .led.scan { background: var(--success-color); box-shadow: 0 0 15px var(--success-color); animation: pulse-green 1s infinite; }
        .led.err { background: var(--secondary-color); box-shadow: 0 0 15px var(--secondary-color); animation: pulse 0.5s infinite; }
        
        @keyframes pulse { 50% { opacity: 0.3; } }
        @keyframes pulse-green { 50% { opacity: 0.5; box-shadow: 0 0 25px var(--success-color); } }

        /* VIEWPORT */
        .viewport-wrapper { position: relative; width: 96%; max-width: 800px; margin-top: 10px; }
        .viewport {
            position: relative; width: 100%; aspect-ratio: 4/3;
            border: 2px solid #333; background: #000; overflow: hidden;
            box-shadow: 0 0 40px rgba(0,0,0,0.6); transition: border-color 0.3s;
        }
        .viewport.active { border-color: var(--primary-color); }
        .viewport.verified { border-color: var(--success-color); box-shadow: 0 0 20px rgba(0, 255, 157, 0.3); }
        .viewport.alert { border-color: var(--secondary-color); box-shadow: 0 0 40px var(--secondary-color); }
        
        video, canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); /* Mirror effect */ }
        
        /* BUFFER BARS */
        .time-bar-container { position: absolute; bottom: 0; left: 0; width: 100%; height: 6px; background: #222; z-index: 25; }
        .time-bar { height: 100%; width: 100%; background: var(--primary-color); transition: width 0.1s linear; }
        
        /* Hand warning overlay specific */
        .hand-warning {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 0, 85, 0.8); color: #fff; padding: 5px 15px;
            font-size: 1rem; border: 1px solid var(--secondary-color); display: none; z-index: 40;
        }

        /* OVERLAYS */
        .overlay-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: var(--primary-color); z-index: 30; background: rgba(0,0,0,0.85);
            padding: 20px; border: 2px solid var(--primary-color); text-align: center;
            font-size: 1.2rem;
        }
        
        #toilet-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.96); z-index: 50; flex-direction: column; justify-content: center; align-items: center;
        }
        #toilet-timer { font-size: 5rem; color: var(--warning-color); margin: 30px 0; font-family: var(--font-data); }

        /* CONTROLS */
        .controls { width: 100%; margin-top: 15px; display: flex; flex-direction: column; gap: 10px; }
        .mode-selector-container { width: 100%; margin-bottom: 5px; }
        
        select.mode-select {
            width: 100%; padding: 12px; background: #0a0a0a; border: 1px solid var(--primary-color);
            color: var(--primary-color); font-family: var(--font-main); font-size: 1rem;
            cursor: pointer; text-align: center; font-weight: bold;
        }
        select.mode-select:disabled { opacity: 0.5; cursor: not-allowed; border-color: #444; }

        .btn-group { display: flex; gap: 10px; flex-wrap: wrap; }
        
        button {
            flex: 1; padding: 12px 5px; min-width: 100px;
            background: rgba(0, 243, 255, 0.08); border: 1px solid var(--primary-color);
            color: var(--primary-color); font-family: var(--font-main); cursor: pointer;
            transition: 0.2s; text-transform: uppercase;
            font-size: 0.9rem; font-weight: 700;
        }
        button:hover:not(:disabled) { background: var(--primary-color); color: #000; box-shadow: 0 0 20px var(--primary-color); }
        button:disabled { border-color: #444; color: #555; cursor: not-allowed; background: transparent; }
        .btn-danger { border-color: var(--secondary-color); color: var(--secondary-color); }
        .btn-danger:hover:not(:disabled) { background: var(--secondary-color); color: #fff; box-shadow: 0 0 20px var(--secondary-color); }

        /* SETTINGS */
        .settings-panel {
            background: var(--panel-bg); border: 1px solid #333;
            max-height: 0; overflow: hidden; transition: max-height 0.4s ease;
            display: flex; flex-direction: column; padding: 0 15px;
        }
        .settings-panel.open { max-height: 800px; border-color: var(--primary-color); padding: 20px; margin-bottom: 40px; }
        
        .setting-row {
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid #444; padding: 10px 0; 
            color: #ddd; font-family: var(--font-data); font-size: 1rem;
        }
        
        .setting-row input {
            background: #050505; border: 1px solid var(--primary-color); color: var(--primary-color);
            padding: 5px; width: 80px; text-align: center; 
            font-family: var(--font-main); font-size: 1rem; font-weight: bold;
        }

        .log-box { margin-top: 15px; border-top: 2px solid #333; padding-top: 10px; }
        #log-display {
            width: 100%; height: 100px; background: #000; border: 1px solid #444;
            padding: 10px; font-family: 'Courier New', monospace; font-size: 0.8rem;
            color: var(--secondary-color); overflow-y: auto; white-space: pre-wrap;
        }
        .log-entry { border-bottom: 1px solid #222; margin-bottom: 5px; padding-bottom: 2px; }

        /* MODALS */
        .consent-overlay, .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); backdrop-filter: blur(5px);
            z-index: 999; display: flex; align-items: center; justify-content: center;
        }
        .consent-overlay { display: flex; } /* Default open */
        .modal-overlay { display: none; z-index: 1000; }
        .modal-overlay.active { display: flex; }

        .consent-box, .modal-box {
            background: #0a0a0a; border: 2px solid var(--primary-color);
            padding: 20px; width: 90%; max-width: 500px; max-height: 85vh; overflow-y: auto;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.15); text-align: left; color: #ccc;
        }
        .modal-box { text-align: center; max-width: 350px; }

        .consent-box h2 { color: var(--primary-color); margin-top: 0; text-align: center; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .consent-btn { width: 100%; padding: 12px; margin-top: 15px; background: var(--primary-color); color: #000; font-weight: bold; border: none; cursor: pointer; }

        .modal-input {
            width: 100%; padding: 10px; margin-bottom: 20px; background: #111;
            border: 1px solid #333; border-left: 4px solid var(--primary-color);
            color: #fff; font-size: 1.2rem; text-align: center;
        }
        .modal-btns { display: flex; gap: 10px; }

        /* COPYRIGHT */
        .copyright-footer {
            position: fixed; bottom: 0; right: 0; padding: 5px 10px;
            background-color: #f1f1f1; z-index: 150; border-top-left-radius: 5px;
        }
        .copyright-footer p { margin: 0; font-size: 12px; color: #000; font-family: sans-serif; }
    </style>
</head>
<body>

    <!-- PRIVACY CONSENT MODAL -->
    <div id="consent-modal" class="consent-overlay">
        <div class="consent-box">
            <h2>PRIVACY & DATA CONSENT</h2>
            <p>本系統使用瀏覽器端運算技術。影像畫面<b>絕不會</b>上傳至任何伺服器。</p>
            <p>僅記錄違規事件的時間點（如：10:00 離開座位）。</p>
            <button class="consent-btn" onclick="acceptConsent()">我同意 / I AGREE</button>
        </div>
    </div>

    <header>
        <div class="brand">AI<span style="color:var(--secondary-color)"> RECON</span></div>
        <div class="status-bar">
            <div style="display:flex; align-items:center; gap:8px;">
                <div id="led-status" class="led"></div>
                <span id="text-status">WAITING</span>
            </div>
            <div><span id="session-timer-display">--:--</span></div>
        </div>
    </header>

    <div class="viewport-wrapper">
        <div class="viewport" id="viewport">
            <div id="loading-msg" class="overlay-msg">載入神經網絡模型...<br><span style="font-size:0.8em">LOADING NEURAL NETWORKS</span></div>
            
            <!-- Face Registration Overlay -->
            <div id="reg-overlay" class="overlay-msg" style="display:none; border-color:var(--success-color); color:var(--success-color);">
                <h3>FACE REGISTRATION</h3>
                <p>請注視鏡頭</p>
                <div id="reg-countdown" style="font-size:3rem; font-weight:bold;">3</div>
            </div>

            <div id="hand-warning-msg" class="hand-warning">⚠ 偵測不到雙手 (HANDS MISSING)</div>

            <video id="webcam" autoplay playsinline muted></video>
            <canvas id="canvas"></canvas>
            
            <div class="time-bar-container">
                <div id="timeout-bar" class="time-bar"></div>
            </div>
            
            <div id="toilet-screen">
                <h2 style="color:var(--warning-color)">RESTROOM BREAK</h2>
                <div id="toilet-timer">00:00</div>
                <button id="btn-return-early" style="max-width:250px;">I HAVE RETURNED</button>
            </div>
        </div>

        <div class="controls">
            <!-- Mode Selection -->
            <div class="mode-selector-container">
                <select id="mode-select" class="mode-select">
                    <option value="proctor">◉ 監考模式 (偵測臉部 + 雙手)</option>
                    <option value="standard">○ 一般模式 (僅偵測臉部)</option>
                </select>
            </div>

            <div class="btn-group">
                <button id="btn-start" onclick="attemptStart()" disabled>啟動監控 (START)</button>
                <button id="btn-stop" class="btn-danger" onclick="attemptStopSystem()" disabled>結束 (STOP)</button>
                <button id="btn-toilet" onclick="requestToilet()" disabled>如廁 (TOILET)</button>
                <button onclick="attemptToggleSettings()" id="btn-settings">設定 (CONFIG)</button>
            </div>

            <div class="settings-panel" id="settings-panel">
                <h3 style="color:var(--primary-color); margin:0 0 10px 0;">CONFIGURATION</h3>
                <div class="setting-row">
                    <label>Session Duration (Min)</label>
                    <input type="number" id="cfg-duration" value="30" min="1" onchange="updateConfig()">
                </div>
                <div class="log-box">
                    <div style="color:var(--warning-color); margin-bottom:5px;">VIOLATION LOGS</div>
                    <div id="log-display"></div>
                    <div id="firebase-status" style="font-size:0.8rem; color:#666; text-align:right;">Init...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- INPUT MODAL -->
    <div id="input-modal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-title" id="modal-msg" style="margin-bottom:15px; font-weight:bold;">INPUT</div>
            <input type="text" id="modal-input" class="modal-input" autocomplete="off">
            <div class="modal-btns">
                <button class="btn-danger" id="modal-cancel-btn">CANCEL</button>
                <button id="modal-confirm-btn">CONFIRM</button>
            </div>
        </div>
    </div>

    <footer class="copyright-footer">
        <p>Copyright © 2025 陳冠健. All rights reserved.</p>
    </footer>

    <audio id="alarm-sound" loop preload="auto" src="https://actions.google.com/sounds/v1/alarms/alarm_clock.ogg"></audio>

    <script>
        // --- CONFIG ---
        const firebaseConfig = {
            apiKey: "AIzaSyBQ1AegbgEDvksAivyHFWA_1DrIDoRcWqw",
            authDomain: "detector-1f676.firebaseapp.com",
            databaseURL: "https://detector-1f676-default-rtdb.firebaseio.com",
            projectId: "detector-1f676",
            storageBucket: "detector-1f676.firebasestorage.app",
            messagingSenderId: "801506387434",
            appId: "1:801506387434:web:4b51c9edbde5c0facf3e93"
        };
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        let sessionId = ""; 
        let consentGiven = false;
        let adminPassword = "ckkchi"; 

        const state = {
            isAiReady: false,
            isRunning: false,
            isToilet: false,
            mode: 'proctor', // 'proctor' or 'standard'
            
            // Face Vars
            referenceDescriptor: null,
            isTargetPresent: false,
            lastFaceVisibleTime: 0,
            
            // Hand Vars
            handModel: null,
            lastHandsOkTime: 0, // Time when both hands were last seen
            handsDetectedCount: 0,
            isHandViolation: false,
            
            // System Vars
            sessionEndTime: 0,
            lastProcessTime: 0,
            lastHandProcessTime: 0,
            animId: null,
            hasViolated: false
        };

        const config = {
            matchThreshold: 0.55,
            handsTimeoutMs: 5000, // 5 seconds buffer for hands
            faceTimeoutMs: 5000
        };

        // DOM Elements
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const viewport = document.getElementById('viewport');
        const timeoutBar = document.getElementById('timeout-bar');
        const alarmAudio = document.getElementById('alarm-sound');
        const logDisplay = document.getElementById('log-display');
        const modeSelect = document.getElementById('mode-select');
        const handWarningMsg = document.getElementById('hand-warning-msg');

        // --- INIT ---
        async function init() {
            try {
                // Initialize Face API
                const FACE_MODEL_URL = 'https://justadudewhohacks.github.io/face-api.js/models';
                await Promise.all([
                    faceapi.nets.tinyFaceDetector.loadFromUri(FACE_MODEL_URL),
                    faceapi.nets.faceLandmark68Net.loadFromUri(FACE_MODEL_URL),
                    faceapi.nets.faceRecognitionNet.loadFromUri(FACE_MODEL_URL)
                ]);

                // Initialize Handpose
                // Set backend to WebGL for better performance
                await tf.setBackend('webgl');
                state.handModel = await handpose.load();

                // Setup Camera
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, frameRate: { ideal: 30 } },
                    audio: false
                });
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    state.isAiReady = true;
                    document.getElementById('loading-msg').style.display = 'none';
                    if(consentGiven) document.getElementById('btn-start').disabled = false;
                    document.getElementById('firebase-status').innerText = "System Ready";
                };

            } catch (e) {
                console.error(e);
                document.getElementById('loading-msg').innerHTML = "SYSTEM ERROR<br>Please use Chrome/Edge";
                document.getElementById('loading-msg').style.color = "var(--secondary-color)";
            }
        }
        init();

        // --- USER INTERACTIONS ---
        function unlockAudio() {
            alarmAudio.muted = true;
            alarmAudio.play().then(() => {
                alarmAudio.pause();
                alarmAudio.currentTime = 0;
                alarmAudio.muted = false;
            }).catch(e => console.log("Audio unlock skipped"));
        }

        function acceptConsent() {
            unlockAudio();
            document.getElementById('consent-modal').style.display = 'none';
            consentGiven = true;
            document.getElementById('text-status').innerText = "READY";
            if(state.isAiReady) document.getElementById('btn-start').disabled = false;
        }

        async function attemptStart() {
            unlockAudio();
            if(!consentGiven) return;
            
            // Set Mode
            state.mode = modeSelect.value;
            modeSelect.disabled = true;

            const inputName = await showInputPrompt("ENTER NAME (輸入姓名)");
            sessionId = (inputName && inputName.trim()) ? sanitizeInput(inputName) : getDateId();
            
            startFaceRegistration();
        }

        async function startFaceRegistration() {
            document.getElementById('reg-overlay').style.display = 'block';
            let count = 3;
            document.getElementById('reg-countdown').innerText = count;
            
            const timer = setInterval(async () => {
                count--;
                if(count > 0) {
                    document.getElementById('reg-countdown').innerText = count;
                } else {
                    clearInterval(timer);
                    const detection = await faceapi.detectSingleFace(video, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptor();
                    
                    if (detection) {
                        state.referenceDescriptor = detection.descriptor;
                        document.getElementById('reg-overlay').style.display = 'none';
                        startSystem();
                    } else {
                        alert("Face not detected. Try again.");
                        document.getElementById('reg-overlay').style.display = 'none';
                        modeSelect.disabled = false;
                    }
                }
            }, 1000);
        }

        function startSystem() {
            state.isRunning = true;
            state.hasViolated = false;
            
            // Init Timers
            const now = Date.now();
            state.lastFaceVisibleTime = now;
            state.lastHandsOkTime = now; // Assume hands start ok
            state.sessionEndTime = now + (parseInt(document.getElementById('cfg-duration').value) * 60 * 1000);
            
            updateUI(true);
            logToCloud("SYSTEM", `Session Started [${state.mode}]`, true);
            loop();
        }

        function stopSystem(isAuto = false) {
            state.isRunning = false;
            cancelAnimationFrame(state.animId);
            stopAlarm();
            ctx.clearRect(0,0,canvas.width,canvas.height);
            updateUI(false);
            modeSelect.disabled = false;
            handWarningMsg.style.display = 'none';

            const conclusion = state.hasViolated ? "違規結束" : "正常結束";
            logToCloud("CONCLUSION", `${conclusion} (${isAuto ? 'Time Up' : 'Manual'})`, true);
        }

        function updateUI(active) {
            document.getElementById('btn-start').disabled = active;
            document.getElementById('btn-stop').disabled = !active;
            document.getElementById('btn-toilet').disabled = !active;
            document.getElementById('btn-settings').disabled = active;
            document.getElementById('led-status').className = active ? "led scan" : "led";
            document.getElementById('text-status').innerText = active ? `MONITORING (${state.mode === 'proctor' ? 'FULL' : 'FACE'})` : "IDLE";
            
            if(active) viewport.classList.add('active'); 
            else viewport.classList.remove('active', 'alert', 'verified');
        }

        // --- MAIN LOOP ---
        async function loop() {
            if (!state.isRunning) return;
            
            // Toilet Logic
            if (state.isToilet) {
                // Update toilet timers but skip AI
                requestAnimationFrame(loop);
                return;
            }

            const now = Date.now();
            
            // Check Session Time
            const timeLeft = state.sessionEndTime - now;
            updateTimerDisplay(timeLeft);
            if (timeLeft <= 0) {
                stopSystem(true);
                alert("Session Complete!");
                return;
            }

            // 1. CLEAR CANVAS
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 2. FACE DETECTION (Every 200ms)
            if (now - state.lastProcessTime > 200) {
                state.lastProcessTime = now;
                const detections = await faceapi.detectAllFaces(video, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptors();
                
                state.isTargetPresent = false;
                detections.forEach(det => {
                    if (faceapi.euclideanDistance(state.referenceDescriptor, det.descriptor) < config.matchThreshold) {
                        state.isTargetPresent = true;
                    }
                });

                // Update Face Logic
                if (state.isTargetPresent) {
                    state.lastFaceVisibleTime = now;
                    viewport.classList.remove('alert');
                }
                
                // Draw Face Box
                detections.forEach(det => {
                    const box = det.detection.box;
                    const isMatch = faceapi.euclideanDistance(state.referenceDescriptor, det.descriptor) < config.matchThreshold;
                    new faceapi.draw.DrawBox(box, { 
                        label: isMatch ? "TARGET" : "UNKNOWN",
                        boxColor: isMatch ? "#00ff9d" : "#ff0055" 
                    }).draw(canvas);
                });
            }

            // 3. HAND DETECTION (Only in Proctor Mode, Every 300ms)
            if (state.mode === 'proctor' && (now - state.lastHandProcessTime > 300)) {
                state.lastHandProcessTime = now;
                
                try {
                    // Estimate hands
                    const hands = await state.handModel.estimateHands(video);
                    state.handsDetectedCount = hands.length;
                    
                    // Draw Hands Logic (Visual Feedback)
                    ctx.strokeStyle = '#00ff9d';
                    ctx.lineWidth = 2;
                    ctx.fillStyle = '#00ff9d';
                    
                    hands.forEach(hand => {
                        const landmarks = hand.landmarks;
                        
                        // Simple bounding box calculation
                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                        for (let i = 0; i < landmarks.length; i++) {
                            const [x, y] = landmarks[i];
                            minX = Math.min(minX, x);
                            minY = Math.min(minY, y);
                            maxX = Math.max(maxX, x);
                            maxY = Math.max(maxY, y);
                            
                            // Draw points
                            ctx.beginPath();
                            ctx.arc(x, y, 3, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                        
                        // Draw box around hand
                        ctx.strokeRect(minX - 10, minY - 10, (maxX - minX) + 20, (maxY - minY) + 20);
                        ctx.fillText("HAND", minX, minY - 15);
                    });

                } catch (err) {
                    console.warn("Handpose error", err);
                }
            }

            // 4. CHECK VIOLATIONS
            checkStatus(now);

            state.animId = requestAnimationFrame(loop);
        }

        // --- CORE LOGIC: HAND & FACE BUFFER ---
        function checkStatus(now) {
            
            // A. HAND CHECK (Proctor Mode Only)
            let handStatusText = "";
            let isHandAlert = false;

            if (state.mode === 'proctor') {
                if (state.handsDetectedCount >= 2) {
                    // Good: Reset buffer
                    state.lastHandsOkTime = now;
                    handWarningMsg.style.display = 'none';
                    state.isHandViolation = false;
                } else {
                    // Bad: Check how long it's been bad
                    const handMissingTime = now - state.lastHandsOkTime;
                    
                    if (handMissingTime > config.handsTimeoutMs) {
                        // VIOLATION: Exceeded 5 seconds
                        triggerAlarm("違規：雙手未在鏡頭範圍 (Hands Missing)");
                        handWarningMsg.style.display = 'block';
                        state.isHandViolation = true;
                        isHandAlert = true;
                    } else if (handMissingTime > 2000) {
                        // WARNING: 2-5 seconds (Visual warning only)
                        handWarningMsg.style.display = 'block';
                    }
                }
                handStatusText = ` | HANDS: ${state.handsDetectedCount}/2`;
            }

            // B. FACE CHECK
            const faceMissingTime = now - state.lastFaceVisibleTime;
            let isFaceAlert = false;
            
            if (faceMissingTime > config.faceTimeoutMs) {
                triggerAlarm("違規：臉部離開鏡頭 (Face Missing)");
                isFaceAlert = true;
            }

            // Update Status Text
            if (!isHandAlert && !isFaceAlert) {
                stopAlarm();
                viewport.classList.add('verified');
                document.getElementById('text-status').innerText = "VERIFIED (檢測正常)" + handStatusText;
                
                // Update Time Bar (Face based generally)
                updateTimeBar(Math.max(0, 1 - (faceMissingTime / config.faceTimeoutMs)));
            } else {
                viewport.classList.remove('verified');
                // Time bar drains if alerting
                updateTimeBar(0);
            }
        }

        function updateTimeBar(pct) {
            timeoutBar.style.width = (pct * 100) + "%";
            timeoutBar.style.backgroundColor = pct < 0.3 ? "var(--secondary-color)" : "var(--primary-color)";
        }

        function triggerAlarm(msg) {
            document.getElementById('text-status').innerText = "⚠ " + msg;
            viewport.classList.add('alert');
            document.getElementById('led-status').className = "led err";
            
            // Vibrate
            if (navigator.vibrate) navigator.vibrate([500, 200, 500]);
            
            // Sound
            if(alarmAudio.paused) {
                alarmAudio.currentTime = 0;
                alarmAudio.play().catch(()=>{});
            }

            // Log if new violation
            logToCloud("VIOLATION", msg, true);
            state.hasViolated = true;
        }

        function stopAlarm() {
            if(!alarmAudio.paused) alarmAudio.pause();
            viewport.classList.remove('alert');
            document.getElementById('led-status').className = "led scan";
        }

        // --- UTILS ---
        function sanitizeInput(str) {
            const d = document.createElement('div');
            d.textContent = str;
            return d.innerHTML.replace(/[.$#[\]/]/g, "_");
        }

        function getDateId() {
            const now = new Date();
            const pad = n => n.toString().padStart(2,'0');
            return `${now.getFullYear()}${pad(now.getMonth()+1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}`;
        }

        function updateTimerDisplay(ms) {
            if(ms < 0) ms = 0;
            const m = Math.floor(ms / 60000);
            const s = Math.floor((ms % 60000) / 1000);
            document.getElementById('session-timer-display').innerText = `${m}:${s.toString().padStart(2,'0')}`;
        }

        // --- FIREBASE LOGGING ---
        let lastLogMsg = "";
        let lastLogTime = 0;

        function logToCloud(category, msg, saveToDb) {
            // Debounce log to prevent spamming
            const now = Date.now();
            if (msg === lastLogMsg && (now - lastLogTime < 5000)) return;
            
            lastLogMsg = msg;
            lastLogTime = now;

            const timeStr = new Date().toLocaleTimeString('zh-TW', {hour12:false});
            
            // UI Update
            const entry = document.createElement('div');
            entry.className = "log-entry";
            entry.innerHTML = `<span style="color:#666">[${timeStr}]</span> ${category}: ${msg}`;
            logDisplay.appendChild(entry);
            logDisplay.scrollTop = logDisplay.scrollHeight;

            if (saveToDb && sessionId) {
                database.ref('sessions/' + sessionId + '/logs').push({
                    time: timeStr,
                    type: category,
                    msg: msg
                });
            }
        }

        // --- SETTINGS & TOILET ---
        function attemptToggleSettings() {
            if(!state.isRunning) document.getElementById('settings-panel').classList.toggle('open');
        }

        function showInputPrompt(msg) {
            return new Promise((resolve) => {
                const modal = document.getElementById('input-modal');
                const input = document.getElementById('modal-input');
                document.getElementById('modal-msg').innerText = msg;
                modal.classList.add('active');
                
                // Clear old listeners
                const newConfirm = document.getElementById('modal-confirm-btn').cloneNode(true);
                const newCancel = document.getElementById('modal-cancel-btn').cloneNode(true);
                document.getElementById('modal-confirm-btn').replaceWith(newConfirm);
                document.getElementById('modal-cancel-btn').replaceWith(newCancel);

                newConfirm.onclick = () => { modal.classList.remove('active'); resolve(input.value); };
                newCancel.onclick = () => { modal.classList.remove('active'); resolve(null); };
            });
        }

        async function attemptStopSystem() {
            const pwd = await showInputPrompt("ENTER ADMIN PASSWORD");
            if(pwd === adminPassword) stopSystem(false);
            else if(pwd !== null) alert("Wrong Password");
        }

        let toiletInterval;
        function requestToilet() {
            if(!confirm("Start Toilet Break?")) return;
            state.isToilet = true;
            stopAlarm();
            
            const screen = document.getElementById('toilet-screen');
            screen.style.display = 'flex';
            
            let t = 300; // 5 mins fixed or config
            const timerEl = document.getElementById('toilet-timer');
            
            toiletInterval = setInterval(() => {
                t--;
                const m = Math.floor(t/60);
                const s = t%60;
                timerEl.innerText = `${m}:${s.toString().padStart(2,'0')}`;
                if(t<=0) {
                    clearInterval(toiletInterval);
                    screen.style.display = 'none';
                    state.isToilet = false;
                    triggerAlarm("Toilet Timeout");
                }
            }, 1000);
            
            document.getElementById('btn-return-early').onclick = () => {
                clearInterval(toiletInterval);
                screen.style.display = 'none';
                state.isToilet = false;
                // Reset buffers
                state.lastFaceVisibleTime = Date.now();
                state.lastHandsOkTime = Date.now();
                loop();
            };
        }

    </script>
</body>
</html>
