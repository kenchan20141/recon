








<!DOCTYPE html>
<html lang="zh">
<head>

<meta http-equiv="Content-Security-Policy" content="
default-src 'self'; 
script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://*.streamable.com https://cdn.heapanalytics.com; 
style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://fonts.googleapis.com; 
font-src 'self' https://cdnjs.cloudflare.com https://fonts.gstatic.com;
img-src 'self' https: data: https://*.streamable.com https://heapanalytics.com;
media-src 'self' https://youfulca.com https://*.streamable.com;
connect-src 'self' https://v1.hitokoto.cn https://chatapi.akash.network https://text.pollinations.ai https://router.huggingface.co https://api.llm7.io https://*.streamable.com https://cdn.jsdelivr.net https://api-fawn-chi.vercel.app https://heapanalytics.com;
frame-src 'self' https://streamable.com https://kenchan20151.pyscriptapps.com https://kenchan20141.github.io https://sansi.vercel.app https://lyricschi.vercel.app https://penpalchi.vercel.app https://litstudy.vercel.app https://621d05f47d591.site123.me https://script.google.com https://www.i2ocr.com;
object-src 'none';
base-uri 'self';
form-action 'self';
">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>神思</title>

<!-- 添加到主畫面設定 -->
<meta name="application-name" content="神思">
<meta name="apple-mobile-web-app-title" content="神思">
<link rel="manifest" href="manifest.json">


<link rel="apple-touch-icon" href="https://i.ibb.co/tpYQMG6/SANSI.png">


<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">


<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&display=swap" rel="stylesheet">


<!-- Android 圖示 -->
<link rel="icon" sizes="192x192" href="https://i.ibb.co/tpYQMG6/SANSI.png">

<link rel="icon" sizes="144x144" href="https://i.ibb.co/tpYQMG6/SANSI.png">

<link rel="icon" sizes="96x96" href="https://i.ibb.co/tpYQMG6/SANSI.png">


<!-- iOS 圖示 -->
<link rel="apple-touch-icon" sizes="180x180" href="https://i.ibb.co/tpYQMG6/SANSI.png">

<link rel="apple-touch-icon" sizes="152x152" href="https://i.ibb.co/tpYQMG6/SANSI.png">

<link rel="apple-touch-icon" sizes="120x120" href="https://i.ibb.co/tpYQMG6/SANSI.png">


<!-- 引入 Chart.js 以繪製雷達圖 -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>


<style>
body {
font-family: 'Noto Serif TC', 'cwTeXHei', 'cwTeXFangSong', 'cwTeXKai', 'cwTeXMing', 'PingFang TC', 'Microsoft JhengHei', serif;
max-width: 800px;
margin: 0 auto;
padding: 20px;
background: url('https://i.ibb.co/xtsrPW6M/image.png') center/cover fixed;
padding-bottom: 60px; /* 為頁面內容設置底部內邊距，避免被音樂播放器遮擋 */
}
h1 {
text-align: center;
color: #333;
}

.category {
margin-bottom: 20px;
}

.category h3 {
font-size: 18px;
margin-bottom: 10px;
color: #fff; /* 白色文字，適配深色背景 */
text-align: left;
}

/* 手機設備調整 */
@media (max-width: 600px) {
.category {
padding-left: 25px; /* 增加左內邊距，讓按鍵遠離左邊緣 */
}
#toolsList button {
width: auto; /* 寬度自適應文字內容 */
display: inline-block; /* 按鈕以行內塊元素顯示，配合置中 */
margin: 10px 0; /* 調整為上下 10px，左右 0px，避免額外水平間距 */
font-size: 14px; /* 保留字體大小 */
padding: 8px 16px; /* 保留內邊距，提供適當空間 */
}
.category h3 {
font-size: 16px; /* 保留標題字體大小 */
}
}


.copyright-footer {
position: fixed;
bottom: 0;
right: 0;
padding: 5px 10px;
background-color: #f1f1f1;
}

.copyright-footer p {
margin: 0;
font-size: 14px;
}

@media (max-width: 600px) {
.copyright-footer p {
font-size: 12px;
}
}

/* 晴天效果：太陽 */
.sun {
position: absolute;
top: 10%;
left: 5%; /* 調整為靠左 */
width: 100px;
height: 100px;
background-color: yellow;
border-radius: 50%;
box-shadow: 0 0 20px yellow;
animation: sunGlow 2s infinite alternate;
z-index: -1; /* 確保太陽在其他元素下方，避免遮擋按鍵 */
}

/* 平板設備調整 */
@media (max-width: 768px) {
.sun {
left: 5%;
top: 5%;
width: 100px;
height: 100px;
}
}

/* 手機設備調整 */
@media (max-width: 480px) {
.sun {
left: 2%;
top: 2%;
width: 80px;
height: 80px;
}
}

/* 太陽光芒動畫（保持不變） */
@keyframes sunGlow {
0% { box-shadow: 0 0 20px yellow; }
100% { box-shadow: 0 0 40px yellow; }
}


/* 多雲效果：雲朵 */
.cloud {
position: absolute;
background-color: white;
border-radius: 50%;
opacity: 0.8;
animation: cloudMove linear infinite;
}

@keyframes cloudMove {
0% { transform: translateX(-100vw); }
100% { transform: translateX(100vw); }
}

/* 下雨效果：雨滴 */
.raindrop {
position: absolute;
width: 2px;
height: 10px;
background-color: #ADD8E6; /* 淺藍色，更自然 */
opacity: 0.7; /* 增加透明度 */
animation: rainFall linear infinite;
}
@keyframes rainFall {
0% { transform: translateY(-10px); }
100% { transform: translateY(100vh); }
}

/* 下雪效果：雪花（保留並調整） */
.snowflake {
position: absolute;
background-color: #e0f7fa;
border-radius: 50%;
opacity: 0.7;
animation: snowfall linear infinite;
}

@keyframes snowfall {
0% { top: -10px; transform: translateX(0); }
50% { transform: translateX(20px); }
100% { top: 100vh; transform: translateX(0); }
}




/* 確保標題不被背景影響 */
.title-container {
background: none;
padding: 0;
}

.title-container {
position: relative;
margin-bottom: 3rem;
text-align: center;
}
.title-text {
display: block;
font-size: 3rem;
color: #d1f2eb;
text-shadow: 3px 3px 0 #7f8c8d;
letter-spacing: 4px;
animation: titleFloat 3s ease-in-out infinite;
}


.box {
background: rgba(220, 220, 220, 0.96);
border-radius: 8px;
box-shadow: 0 2px 4px rgba(0,0,0,0.1);
padding: 20px;
margin: 15px 0;
}
button {
background: #007bff;
color: white;
padding: 10px 20px;
border: none;
border-radius: 4px;
cursor: pointer;
transition: background 0.3s;
margin: 5px;
}
button:hover {
background: #0056b3;
}
.save-btn {
background: #28a745;
}
.save-btn:hover {
background: #218838;
}
.clear-btn {
background: #dc3545;
}
.clear-btn:hover {
background: #c82333;
}

/* --- 修訂二：表單輸入框美化 --- */
select, textarea, input[type="text"] {
width: 100%;
padding: 12px 15px; /* 增加內邊距 */
margin: 10px 0;
border: 1px solid #dcdfe6; /* 更柔和的邊框顏色 */
border-radius: 8px; /* 更大的圓角 */
box-sizing: border-box;
background-color: #fcfdfd; /* 非常淺的背景色 */
font-size: 1.3em;
color: #333;
transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

select:focus, textarea:focus, input[type="text"]:focus {
outline: none; /* 移除預設的 outline */
border-color: #4A90E2; /* 焦點狀態下的邊框顏色 */
box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.2); /* 模擬 glow 效果 */
}

textarea {
resize: vertical;
min-height: 80px; /* 設定最小高度 */
}

table {
width: 100%;
border-collapse: collapse;
margin: 10px 0;
}
th, td {
border: 1px solid #ccc;
padding: 10px;
text-align: left;
vertical-align: top;
word-break: break-word;
}
th {
background: #f0f0f0;
}
.table-container {
overflow-x: auto;
width: 100%;
}
.table-container table {
width: 100%;
border-collapse: collapse;
}
.table-container th, .table-container td {
border: 1px solid #ccc;
padding: 10px;
text-align: left;
vertical-align: top;
word-break: break-word;
}
.table-container th:first-child, .table-container td:first-child {
width: 60px; /* 您可以調整這個像素值來改變寬度 */
}
.table-container th:nth-child(2), .table-container td:nth-child(2),
.table-container th:nth-child(3), .table-container td:nth-child(3) {
min-width: 100px;
}
.table-container th:nth-child(4), .table-container td:nth-child(4),
.table-container th:nth-child(5), .table-container td:nth-child(5) {
min-width: 150px;
}

@keyframes fadeIn {
from { opacity: 0; }
to { opacity: 1; }
}

.tool-btn {
animation: fadeIn 0.2s ease-in-out forwards;
opacity: 0;
}


/* --- 修訂一：範疇按鍵樣式 --- */
.category-buttons-container {
display: flex;
flex-wrap: wrap;
gap: 10px;
justify-content: center; /* 讓按鈕在容器內居中 */
}

.btn-category {
padding: 10px 20px;
border-radius: 8px;
cursor: pointer;
font-size: 14px;
font-weight: bold;
transition: all 0.3s ease;
border: 2px solid white;
box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
background-color: rgba(142, 142, 147, 0.7); /* 半透明灰色 */
color: white;
backdrop-filter: blur(5px);
margin: 0; /* 重置 margin */
}

.btn-category:hover {
transform: translateY(-2px);
box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
filter: brightness(115%);
}

.btn-category.active {
filter: brightness(115%);
box-shadow: 0 0 15px rgba(255, 255, 255, 0.7), 0 4px 12px rgba(0,0,0,0.25);
transform: translateY(-2px);
}

/* Specific active colors */
#readingBtn.active { background-color: #28a745; }
#writingBtn.active { background-color: #007bff; }
#argumentBtn.active { background-color: #800080; }
#expandBtn.active { background-color: #dc3545; }
#booksBtn.active { background-color: #ffc107; }

/* Apply to the expand button as well */
#expandToolsBtn2 {
padding: 10px 20px;
border-radius: 8px;
cursor: pointer;
font-size: 14px;
font-weight: bold;
transition: all 0.3s ease;
border: 2px solid white;
box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
color: white;
background-color: rgba(54, 187, 167, 0.8);
backdrop-filter: blur(5px);
}

#expandToolsBtn2:hover {
transform: translateY(-2px);
box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
filter: brightness(110%);
}


#toolsContainer {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100vh;
background-color: rgba(0, 0, 0, 0.8);
display: flex;
justify-content: center;
align-items: center;
z-index: 1000;
overflow: hidden; /* 隱藏頁面滾動條 */
}

#toolsList {
display: flex;
flex-direction: column;
align-items: flex-start;
max-height: 80vh; /* 設置最大高度，例如 80% 的視窗高度 */
overflow-y: auto; /* 啟用垂直滾動條 */
position: relative; /* 保持相對定位於容器內 */
}

#toolsList button {
opacity: 0;
margin: 10px 0;
padding: 10px 20px;
font-size: 16px;
background-color: #007bff;
color: white;
border: none;
border-radius: 4px;
cursor: pointer;
}

#closeToolsBtn {
position: absolute;
top: 20px;
right: 20px;
background-color: #dc3545;
color: white;
border: none;
padding: 10px 20px;
border-radius: 4px;
cursor: pointer;
}


#commentResult {
width: 100%;
overflow-wrap: break-word;
}

#toggleOverviewBtn {
background-color: #A9A9A9; /* 灰色背景 */
color: white; /* 白色文字 */
}

#toggleOverviewBtn:hover {
background-color: #808080; /* 懸停時深灰色 */
}


#manuscriptPaperBtn {
background-color: #17a2b8;
}
#manuscriptPaperBtn:hover {
background-color: #138496;
}

#writingContainer, #readingContainer, #booksContainer, #expandContainer, #argumentContainer {
display: none;
}
#argumentTopicSelectionArea, #argumentCustomTopicArea, #argumentWritingArea, #argumentGuideArea {
margin-top: 10px;
}



#music-player {
position: fixed;
bottom: 0px;
left: 0;
width: 100%;
background-color: #444;
color: white;
padding: 10px;
display: none; /* 預設隱藏 */
align-items: center;
justify-content: space-between;
z-index: 1002;
box-sizing: border-box;
font-size: 14px;
}
#music-player.hidden {
display: none;
}
#music-player .controls {
display: flex;
align-items: center;
flex-shrink: 0;
}
#music-player .controls button {
background: none;
border: none;
color: white;
font-size: 20px;
cursor: pointer;
margin-right: 10px;
}
#music-player .controls select {
background: #555;
color: white;
border: none;
padding: 5px;
border-radius: 3px;
max-width: 150px;
}
#music-player .progress {
flex: 1;
margin: 0 10px;
display: flex;
align-items: center;
}
#music-player .progress input[type="range"] {
width: 100%;
}
#music-player .mode {
margin-left: 10px;
flex-shrink: 0;
}
#music-player .mode select {
background: #555;
color: white;
border: none;
padding: 5px;
border-radius: 3px;
}
#music-player .hide-btn {
background: none;
border: none;
color: white;
font-size: 20px;
cursor: pointer;
margin-left: 10px;
}
#show-player {
position: fixed;
bottom: 25px; /* 上移至 30px，可根據需要調整 */
right: 10px;
background: #444;
color: white;
border: none;
padding: 10px;
border-radius: 50%;
cursor: pointer;
z-index: 1003;
display: block; /* 初始顯示 */
font-size: 16px;
}
@media (max-width: 600px) {
#music-player {
flex-wrap: wrap;
padding: 5px;
}
#music-player .controls select {
max-width: 100px;
font-size: 12px;
}
#music-player .mode select {
font-size: 12px;
}
#progress-bar-music {
height: 10px;
-webkit-appearance: none;
appearance: none;
background: #ddd;
border-radius: 5px;
}
#progress-bar-music::-webkit-slider-thumb {
-webkit-appearance: none;
appearance: none;
width: 20px;
height: 20px;
background: #007bff;
border-radius: 50%;
cursor: pointer;
}
#progress-bar-music::-moz-range-thumb {
width: 20px;
height: 20px;
background: #007bff;
border-radius: 50%;
cursor: pointer;
}
#music-player .controls select, #music-player .mode select {
max-width: 80px;
padding: 3px;
font-size: 12px;
}
#music-player .controls button, #music-player .hide-btn {
padding: 5px;
font-size: 16px;
}
}

/* --- Styles for Tool 2 (語薈) --- */
:root {
--bg-color: #f5f5f3;
--text-color: #333;
--primary-color: #6a7a7d;
--secondary-color: #8f8f8f;
--accent-color: #8c9ea1;
--line-color: #c5c5c5;
--shadow-color: rgba(0, 0, 0, 0.05);
--highlight-bg-writing: rgba(230, 240, 245, 0.6);
--highlight-bg-reading: rgba(245, 240, 230, 0.6);
--font-main: 'Noto Serif TC', 'cwTeXHei', 'cwTeXFangSong', 'cwTeXKai', 'cwTeXMing', 'PingFang TC', 'Microsoft JhengHei', serif;
}

#toolsContainer2 {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: var(--bg-color);
z-index: 1005;
overflow-y: auto;
display: none;
padding: 2rem 1rem;
box-sizing: border-box;
justify-content: center;
}

#closeToolsBtn2 {
position: fixed;
top: 15px;
right: 25px;
background-color: transparent;
border: none;
font-size: 2.5rem;
font-weight: bold;
color: #333;
cursor: pointer;
z-index: 1006;
line-height: 1;
padding: 5px 10px;
}

#closeToolsBtn2:hover {
color: #d32f2f;
}

.main-container {
max-width: 1200px;
width: 100%;
position: relative;
opacity: 0;
transition: opacity 0.5s ease-in;
}

.main-container.loaded {
opacity: 1;
}

.floating-header {
position: fixed;
top: 15px;
left: 20px;
background-color: rgba(255, 255, 255, 0.7);
backdrop-filter: blur(8px);
padding: 5px 15px;
border-radius: 30px;
border: 1px solid #e0e0e0;
z-index: 1000;
box-shadow: 0 2px 10px var(--shadow-color);
display: flex;
align-items: center;
gap: 10px;
}

#video-tour-btn {
background: none;
border: none;
cursor: pointer;
padding: 0;
display: flex;
align-items: center;
}

#video-tour-btn .icon {
width: 24px;
height: 24px;
fill: var(--primary-color);
transition: fill 0.3s;
}

#video-tour-btn:hover .icon {
fill: var(--accent-color);
}

.floating-header h1 {
font-size: 1.2rem;
margin: 0;
font-weight: 700;
color: var(--primary-color);
}

.mind-map-container {
display: grid;
grid-template-columns: 1fr 1fr;
grid-template-rows: auto auto 1fr auto;
grid-template-areas:
"core-ai core-ai"
"foundations foundations"
"writing reading"
"assignments support";
gap: 50px 20px;
width: 100%;
margin-top: 80px;
padding-bottom: 50px;
position: relative;
}

.node {
display: flex;
align-items: center;
text-align: center;
padding: 8px 12px;
background-color: #fff;
border: 1px solid #e0e0e0;
border-radius: 8px;
box-shadow: 0 3px 12px var(--shadow-color);
transition: transform 0.3s ease, box-shadow 0.3s ease;
position: relative;
}

.node:hover {
transform: translateY(-4px) scale(1.02);
box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
border-color: var(--accent-color);
}

.node a {
text-decoration: none;
color: inherit;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
font-size: 0.95rem;
gap: 8px;
width: 100%;
}

.node .icon {
width: 24px;
height: 24px;
margin-right: 0;
fill: var(--primary-color);
}

#toolsContainer2 .category {
display: flex;
flex-direction: column;
align-items: center;
gap: 20px;
margin-bottom: 0; /* Reset margin for this context */
}

#writing, #reading {
padding: 20px;
border-radius: 12px;
}
#writing {
background-color: var(--highlight-bg-writing);
}
#reading {
background-color: var(--highlight-bg-reading);
}

.category-title {
font-size: 1.2rem;
font-weight: 700;
color: var(--primary-color);
padding-bottom: 5px;
border-bottom: 2px solid var(--accent-color);
display: flex;
align-items: center;
margin-bottom: 10px;
}

.category-title .icon {
width: 24px;
height: 24px;
margin-right: 8px;
fill: var(--primary-color);
}

.sub-group {
display: flex;
flex-direction: column;
align-items: center;
gap: 12px;
width: 100%;
}

.sub-group-title {
font-weight: bold;
color: var(--secondary-color);
font-size: 0.9rem;
position: relative;
padding-bottom: 5px;
margin-bottom: 5px;
}
.sub-group-title::after{
content: '';
position: absolute;
bottom: 0;
left: 50%;
transform: translateX(-50%);
width: 30px;
height: 1px;
background-color: var(--line-color);
}

.node.level-2 { font-size: 0.9rem; }
.node.level-3 { font-size: 0.85rem; padding: 6px 10px; }
.node.level-3 a { font-weight: 400; flex-direction: row; }

/* Grid Area Assignments */
#core-ai { grid-area: core-ai; }
#foundations {
grid-area: foundations;
display: flex;
flex-direction: row;
justify-content: center;
gap: 500px;
align-items: flex-start;
}
#writing { grid-area: writing; }
#reading { grid-area: reading; }
#assignments { grid-area: assignments; }
#support { grid-area: support; }

.connector-svg {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
z-index: -1;
pointer-events: none;
}

.connector-svg line {
stroke: var(--line-color);
stroke-width: 1.5;
stroke-dasharray: 4;
animation: dash 1s linear infinite;
}

@keyframes dash {
to {
stroke-dashoffset: -20;
}
}

#yuyilu-toggle { cursor: pointer; }
.yuyilu-grades {
display: flex;
flex-direction: column;
gap: 8px;
width: 100%;
max-height: 500px;
overflow: hidden;
transition: max-height 0.5s ease-in-out, opacity 0.3s ease-in-out;
opacity: 1;
}
.yuyilu-grades.collapsed {
max-height: 0;
opacity: 0;
pointer-events: none;
}

.foundation-item {
display: flex;
flex-direction: column;
align-items: center;
gap: 15px;
}

@media (max-width: 768px) {
#toolsContainer2 { padding: 1rem 0.5rem; }
.floating-header { top: 10px; left: 10px; }

.mind-map-container {
margin-top: 70px;
grid-template-columns: 1fr;
grid-template-rows: auto;
grid-template-areas:
"core-ai"
"foundations"
"writing"
"reading"
"assignments"
"support";
gap: 40px;
}

#foundations {
flex-direction: row;
justify-content: space-between;
align-items: flex-start;
width: 90%;
margin: 0 auto;
gap: 10px;
}

#writing, #reading {
padding: 15px;
}
}

/* --- Preview Modal Styles --- */
.preview-modal-overlay {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.7);
display: none; /* 預設隱藏 */
justify-content: center;
align-items: center;
z-index: 2000;
padding: 1rem;
box-sizing: border-box;
}

.preview-modal-content {
background-color: #fff;
border-radius: 12px;
box-shadow: 0 5px 25px rgba(0,0,0,0.2);
width: 90%;
height: 90%;
max-width: 1000px;
display: flex;
flex-direction: column;
overflow: hidden;
position: relative;
}

.preview-close-btn {
position: absolute;
top: 8px;
right: 8px;
background: rgba(255, 255, 255, 0.7);
border: none;
border-radius: 50%;
width: 36px;
height: 36px;
font-size: 1.5rem;
font-weight: bold;
color: #333;
cursor: pointer;
line-height: 1;
display: flex;
align-items: center;
justify-content: center;
transition: background-color 0.3s, color 0.3s;
z-index: 2010;
}
.preview-close-btn:hover {
color: #fff;
background-color: #d32f2f;
}

.preview-modal-body {
flex-grow: 1;
display: flex;
flex-direction: column;
height: 100%;
}

#previewIframe {
width: 100%;
flex-grow: 1; /* 佔據大部分空間 */
border: none;
border-top-left-radius: 12px;
border-top-right-radius: 12px;
min-height: 60%; /* 確保預覽畫面有足夠高度 */
}

.preview-modal-footer {
padding: 16px;
background-color: #f7f9fa;
border-top: 1px solid #e0e0e0;
display: flex;
align-items: flex-start;
gap: 16px;
overflow-y: auto;
max-height: 40%;
flex-shrink: 0;
}

.preview-description {
font-size: 0.95rem;
color: #333;
line-height: 1.6;
text-align: left;
flex-grow: 1;
}

.preview-goto-btn {
background: #007bff url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white' width='18px' height='18px'%3E%3Cpath d='M0 0h24v24H0z' fill='none'/%3E%3Cpath d='M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z'/%3E%3C/svg%3E") no-repeat 15px center;
background-size: 18px 18px;
color: white;
padding: 10px 20px 10px 40px;
border: none;
border-radius: 20px;
text-decoration: none;
font-size: 1rem;
font-weight: bold;
transition: background-color 0.3s;
cursor: pointer;
flex-shrink: 0; /* 防止按鈕縮小 */
}
.preview-goto-btn:hover {
background-color: #0056b3;
color: white;
}

@media (max-width: 600px) {
.preview-modal-footer {
flex-direction: column;
align-items: stretch;
}
.preview-goto-btn {
align-self: flex-end; /* 在堆疊時仍將按鈕靠右 */
}
}


/* --- Video Modal Styles --- */
.video-modal-overlay {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.8);
display: none; /* 預設隱藏 */
justify-content: center;
align-items: center;
z-index: 2100;
cursor: pointer;
}

.video-modal-content {
position: relative;
width: 90%;
max-width: 960px;
padding-top: 56.25%; /* 16:9 Aspect Ratio */
height: 0;
cursor: default;
}

.video-modal-content iframe {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
border: none;
}

/* --- 修訂：增加選擇功能及下方項目排版的間距，使其更寬鬆 --- */
.function-selector-wrapper {
padding: 20px; /* 增加內邊距，讓內部元素有更多呼吸空間 */
background-color: rgba(59, 184, 219, 0.2);
border-left: 5px solid #0288d1;
margin-top: 30px; /* <--- 請加上這一行 */
margin-bottom: 35px; /* 明顯增加與下方內容的間距 */
border-radius: 8px; /* 圓角稍大，視覺上更柔和 */
box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}
.function-selector-wrapper label {
font-size: 1.1em; /* 標題字體稍大，更突出 */
font-weight: bold;
color: #01579b;
display: block;
margin-bottom: 15px; /* 增加與下拉選單的間距 */
}
.function-selector-wrapper select {
font-size: 1em; /* 統一下拉選單字體大小 */
padding: 8px; /* 適度增加下拉選單的內邊距 */
}

/* 為各個功能容器內的主要區塊（div）增加統一的下間距，創造區塊間的層次感 */
#writingContentContainer > div,
#expandContentContainer > div,
#argumentContentContainer > div {
margin-bottom: 30px;
}

/* 清除最後一個元素的下邊距，避免在容器末尾產生多餘的空白 */
#writingContentContainer > div:last-child,
#expandContentContainer > div:last-child,
#argumentContentContainer > div:last-child {
margin-bottom: 0;
}

/* 針對閱讀區塊，其內部結構不同，單獨調整其子元素的間距 */
#readingInputArea > *:not(div#readingResult) {
margin-bottom: 20px; /* 統一閱讀區塊內輸入元素的下間距 */
}


/* --- 新增的改寫說明 UI 樣式 --- */
.rewrite-explanation-container {
margin-top: 20px;
}
.rewrite-explanation-card {
background-color: #f8f9fa;
border: 1px solid #dee2e6;
border-radius: 8px;
padding: 20px;
box-shadow: 0 1px 3px rgba(0,0,0,0.04);
}
.rewrite-explanation-card h3 {
margin-top: 0;
margin-bottom: 15px;
color: #343a40;
font-size: 1.2em;
border-bottom: 2px solid #e9ecef;
padding-bottom: 10px;
}
.explanation-point {
display: flex;
align-items: flex-start;
margin-bottom: 15px;
}
.explanation-point:last-child {
margin-bottom: 0;
}
.explanation-number {
flex-shrink: 0;
width: 28px;
height: 28px;
background-color: #0288d1;
color: white;
font-weight: bold;
display: flex;
align-items: center;
justify-content: center;
border-radius: 50%;
margin-right: 15px;
font-size: 1em;
}
.explanation-text {
font-size: 1em;
line-height: 1.6;
color: #495057;
}

/* --- 新增：為點評語氣標籤增加上方間距 --- */
.tone-selector-label {
display: block; /* 確保標籤獨佔一行，讓邊距能正確顯示 */
margin-top: 25px; /* 增加與上方元素的距離 */
}

/* --- 題目顯示區塊樣式 --- */
#topicResult, #argumentTopicResult, #expandTopicResult {
position: relative; /* 為了讓 ::before 偽元素可以定位 */
padding: 12px 15px;
margin-bottom: 20px;
border-left: 5px solid #2A9689;
border-radius: 4px;
font-size: 1em;
display: none;
background-color: transparent !important; /* 強制容器本身透明 */
z-index: 0;
}

#topicResult::before,
#argumentTopicResult::before,
#expandTopicResult::before {
content: '';
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background-color: rgba(54, 187, 167, 0.5); /* 在這裡設定半透明背景 */
border-radius: inherit; /* 讓背景的圓角與容器同步 */
z-index: -1; /* 將背景層放到內容的後面 */
}

/* 步驟二：強制設定表格儲存格的背景顏色 */
#topicResult td,
#argumentTopicResult td,
#expandTopicResult td {
background-color: #ffffff !important; /* 強制！內容儲存格為不透明白色 */
}

#topicResult th,
#argumentTopicResult th,
#expandTopicResult th {
background-color: #f0f0f0 !important; /* 強制！表頭為不透明淺灰色 */
}

/* 當題目區塊內有內容時，才將其顯示出來 */
#topicResult:not(:empty), #argumentTopicResult:not(:empty), #expandTopicResult:not(:empty) {
display: block;
}

/* --- 新增：讓「選擇題目方式」標題獨立成行 --- */
#topicSelectionArea > label,
#argumentTopicSelectionArea > label,
#expandTopicSelectionArea > label {
display: block; /* 讓標題變為區塊元素，使其強制換行 */
margin-bottom: 10px; /* 在標題和下方的按鈕之間增加一點垂直間距，讓版面更美觀 */
}


/* --- 按鍵美化修訂 (第四版 - 灰色預設/點擊變色) --- */

/* 1. 包裹按鍵的容器 */
.topic-buttons-container {
display: flex;
gap: 15px;
align-items: center;
margin-top: 10px;
}

/* 2. 通用的按鍵基礎樣式 */
.btn {
padding: 8px 18px;
border-radius: 8px;
cursor: pointer;
font-size: 16px;
font-weight: bold;
color: white;
transition: all 0.3s ease;
display: inline-flex;
align-items: center;
justify-content: center;
gap: 8px;
box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
border: 3px solid transparent;

/* 【核心修訂】預設狀態下，所有按鍵都是灰色 */
background-color: #8E8E93; /* 一個質感不錯的中性灰 */
}

/* 3. 滑鼠懸停效果 (只對非活動的灰色按鍵生效) */
.btn:not(.active):hover {
transform: translateY(-2px);
box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
filter: brightness(110%); /* 懸停時讓灰色稍微變亮 */
}

/* --- 點亮 (Active) 狀態的樣式 --- */

/* 4. 當「生成題目」按鍵被點亮時，變成藍色 */
.btn-generate.active {
background-color: #4A90E2; 
}

/* 5. 當「自訂題目」按鍵被點亮時，變成紫色 */
.btn-custom.active {
background-color: #7B68EE; 
}

/* 6. 所有被點亮的按鍵，都套用相同的強力發光效果 */
.btn.active {
filter: brightness(115%);
border: 3px solid white;
box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
transform: translateY(-2px);
}

.btn .fas {
font-size: 15px;
}

/* --- 新增：調整「剩餘字數」計數器的樣式與位置 --- */
#charCount {
margin-top: 0px; /* 大幅減少與上方輸入框的間距 */
margin-bottom: 20px; /* 確保與下方元素的間距，避免擠在一起 */
text-align: right; /* 將文字靠右對齊，看起來更專業 */
font-size: 0.9em; /* 讓字體稍微小一點，作為輔助資訊 */
color: #666; /* 使用較柔和的灰色 */
}

/* --- 新增：禁用按鈕的通用樣式 --- */
button:disabled {
background-color: #cccccc; /* 灰色背景 */
color: #666666; /* 深灰色文字 */
cursor: not-allowed; /* 顯示「禁止」的鼠標圖示 */
opacity: 0.6; /* 降低透明度 */
}

/* 確保此樣式也適用於有特定 class 的按鈕 */
.btn:disabled, .btn-icon-confirm:disabled {
background-color: #cccccc !important; /* 使用 !important 覆蓋原有樣式 */
border-color: #cccccc !important;
cursor: not-allowed;
opacity: 0.6;
box-shadow: none; /* 移除陰影 */
transform: none; /* 移除變形效果 */
}

/* --- 新增：儲存/清除圖示按鍵樣式 --- */
.action-buttons-container {
display: flex;
justify-content: flex-end; /* 將按鈕靠右對齊 */
gap: 12px; /* 按鈕之間的間距 */
margin-top: 10px; /* 與上方元素的間距 */
align-items: center; /* 確保所有項目垂直置中 */
}
/* ... (您原有的 .btn-icon-action, .btn-save-icon, .btn-clear-icon 樣式) ... */

.btn-add-icon {
background-color: rgba(0, 123, 255, 0.8); /* 主題藍色，並加入 0.8 的透明度 */
}

.btn-icon-action {
width: 36px;
height: 36px;
border-radius: 50%; /* 圓形按鈕 */
border: none;
color: white; /* 圖示顏色 */
font-size: 16px; /* 圖示大小 */

display: inline-flex;
align-items: center;
justify-content: center;

cursor: pointer;
box-shadow: 0 2px 5px rgba(0,0,0,0.15);
transition: all 0.2s ease-in-out;
margin: 0;
}

.btn-icon-action:hover {
transform: translateY(-2px);
box-shadow: 0 4px 8px rgba(0,0,0,0.2);
filter: brightness(110%);
}

.btn-icon-action:active {
transform: translateY(0);
}

.btn-save-icon {
background-color: rgba(26, 117, 149, 0.8); /* 深藍綠色，並加入 0.8 的透明度 */
}

.btn-clear-icon {
background-color: rgba(220, 53, 69, 0.8); /* 紅色，並加入 0.8 的透明度 */
}

/* --- 新增：書籍討論資訊的專屬樣式 --- */
.discussion-info {
text-align: left; /* 強制文字靠左對齊 */
background-color: #eef1f4; /* 一個柔和、中性的背景色 */
color: #333; /* 深色文字，確保可讀性 */
padding: 12px 15px; /* 適當的內邊距 */
border-radius: 8px; /* 圓角 */
margin: 5px 0 15px 0; /* 與下方 AI 回應的間距 */
line-height: 1.6; /* 增加行高，讓文字不擁擠 */
}

.discussion-info strong {
color: #0056b3; /* 讓標題文字(書名、作者等)使用主題藍色，更突出 */
}

/* --- 新增：書籍資訊表格的樣式 --- */
.discussion-info table {
width: 100%;
border-collapse: collapse; /* 移除儲存格之間的空隙 */
}

.discussion-info td {
border: none; /* 移除所有邊框 */
padding: 4px 0; /* 微調垂直內邊距，讓行距適中 */
vertical-align: top; /* 確保長內容的儲存格頂部對齊 */
}

/* 讓標題欄位有一個固定的、較小的寬度 */
.discussion-info td:first-child {
width: 90px; /* 您可以根據需要調整這個寬度 */
font-weight: bold; /* 讓標題加粗 */
color: #0056b3; /* 繼承主題藍色 */
}

/* --- 全新聊天介面樣式 (無頭像極簡版) --- */

/* 1. 聊天歷史容器 */
#chatHistory {
background-color: #f0f4f8;
border: 1px solid #dde3ea;
border-radius: 12px;
padding: 20px 15px;
margin-bottom: 15px;
max-height: 400px;
overflow-y: auto;
display: none;
scroll-behavior: smooth;
display: flex;
flex-direction: column;
}

/* 2. 訊息氣泡樣式 */
.message-bubble {
padding: 10px 15px;
border-radius: 18px;
line-height: 1.5;
font-size: 14px; /* <-- 新增這一行以縮小字體 */
word-wrap: break-word;
box-shadow: 0 2px 4px rgba(0,0,0,0.05);
max-width: 80%;
animation: fadeIn 0.3s ease-in-out;
margin-bottom: 15px;
}


//* ---【最終修正版】聊天氣泡樣式 (通用化) --- */

/* 3. AI (陳SIR) 訊息的氣泡樣式 */
.message-bubble.ai-message {
    background-color: #ffffff;
    color: #333;
    align-self: flex-start; /* 讓氣泡自身靠左 */
    border-top-left-radius: 4px; /* 製造氣泡指向感 */
}

/* 4. 使用者訊息的氣泡樣式 */
.message-bubble.user-message {
    background-color: rgba(45, 153, 102, 0.9); /* 您想要的帶透明度的綠色 */
    color: white;
    align-self: flex-end; /* 讓氣泡自身靠右 */
    border-top-right-radius: 4px; /* 製造氣泡指向感 */
}

/* 5. 書籍資訊卡片樣式 (保持不變) */
.discussion-info {
    text-align: left;
    background-color: #e9ecef;
    color: #495057;
    padding: 12px 15px;
    border-radius: 8px;
    margin: 0 auto 15px auto;
    line-height: 1.6;
    width: 95%;
    box-sizing: border-box;
}

.discussion-info table {
    width: 100%;
    border-collapse: collapse;
}
.discussion-info td {
    border: none;
    padding: 4px 0;
    vertical-align: top;
}
.discussion-info td:first-child {
    width: 90px;
    font-weight: bold;
    color: #0056b3;
}

/* --- 【新增】將聊天介面樣式通用化 --- */
#chatHistory, #writingChatHistory {
    background-color: #f0f4f8;
    border: 1px solid #dde3ea;
    border-radius: 12px;
    padding: 20px 15px;
    margin-top: 15px; /* 與上方評分系統的間距 */
    margin-bottom: 15px;
    max-height: 400px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
}

#chatInputContainer, #writingChatInputContainer {
    display: flex; /* 預設由 JS 控制顯示 */
    align-items: center;
    gap: 10px;
    margin-top: 15px;
}
#chatInputContainer textarea, #writingChatInputContainer textarea {
    flex-grow: 1; /* 佔據主要空間 */
    margin: 0; /* 移除預設的 margin */
}

/* --- 修訂三：「課外書籍」互動介面 --- */
#chatInputContainer {
display: none; /* 預設隱藏，由 JS 控制 */
align-items: center;
gap: 10px;
margin-top: 15px;
}
#chatInputContainer textarea {
flex-grow: 1; /* 佔據主要空間 */
margin: 0; /* 移除預設的 margin */
}

#initialDiscussionForm {
display: block; /* 預設顯示 */
}

/* 新增討論主題的彈出視窗 */
.books-modal {
display: none; /* 預設隱藏 */
position: fixed;
z-index: 1010;
left: 0;
top: 0;
width: 100%;
height: 100%;
overflow: auto;
background-color: rgba(0,0,0,0.6);
justify-content: center;
align-items: center;
}

.books-modal .modal-content {
background-color: #fefefe;
margin: auto;
padding: 25px;
border: 1px solid #888;
width: 90%;
max-width: 500px;
border-radius: 12px;
box-shadow: 0 5px 15px rgba(0,0,0,0.3);
position: relative;
animation: fadeIn 0.4s;
}

.books-modal .close-modal-btn {
color: #aaa;
position: absolute;
top: 10px;
right: 15px;
font-size: 28px;
font-weight: bold;
cursor: pointer;
}
.books-modal .close-modal-btn:hover,
.books-modal .close-modal-btn:focus {
color: black;
}
#discussionControlButtons {
margin-bottom: 20px;
}

/* --- 新增：預設隱藏課外書籍的功能按鈕 --- */
#booksButtons {
display: none;
}

/* --- 新增：手機版範疇按鍵靠左對齊 --- */
@media (max-width: 600px) {
.category-buttons-container {
/* 在螢幕寬度小於等於 600px 時，
將按鍵的對齊方式從 center 改為 flex-start (靠左) */
justify-content: flex-start;
}
}

/* --- 新增：「開始討論」與「提交」按鍵的統一美化樣式 --- */
.btn-action {
display: inline-block;
padding: 10px 20px;
margin: 15px 0 5px 0; /* 調整與上方元素的距離 */
border-radius: 8px; /* 圓角與範疇按鍵一致 */
cursor: pointer;
font-size: 14px; /* 字體大小與範疇按鍵一致 */
font-weight: bold; /* 字體粗細與範疇按鍵一致 */
font-family: 'Noto Serif TC', 'cwTeXHei', 'cwTeXFangSong', 'cwTeXKai', 'cwTeXMing', 'PingFang TC', 'Microsoft JhengHei', serif; /* 確保字體繼承一致 */
transition: all 0.3s ease;
border: 2px solid white;
box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
color: white;
background-color: rgba(31, 122, 85, 0.8); /* 統一使用「點擊展開」的綠色，使其具有「執行動作」的視覺感 */
backdrop-filter: blur(5px);
text-align: center;
text-decoration: none;
}

.btn-action:hover {
transform: translateY(-2px);
box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
filter: brightness(110%);
}


/* --- 通用輸入框懸浮視窗 (CSS) --- */

/* 1. 讓所有符合條件的輸入框看起來可以點擊 */
textarea:not(.no-modal-editor),
input[type="text"]:not(.no-modal-editor) {
cursor: pointer; /* 滑鼠變成手形指標 */
background-color: #f0f8ff; /* 淡藍色背景提示 */
transition: background-color 0.2s;
}

/* 2. 當滑鼠懸停時，背景色稍深一點 */
textarea:not(.no-modal-editor):hover,
input[type="text"]:not(.no-modal-editor):hover {
background-color: #e6f2ff;
}

/* 3. 懸浮視窗本身的樣式 (與之前相同，可直接覆蓋) */
.outline-modal-overlay {
display: none;
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.65);
z-index: 2000;
justify-content: center;
align-items: center;
padding: 1rem;
box-sizing: border-box;
}

.outline-modal-content {
background-color: #fdfdfd;
padding: 25px;
border-radius: 12px;
box-shadow: 0 5px 15px rgba(0,0,0,0.3);
width: 90%;
max-width: 700px;
position: relative;
animation: fadeIn 0.3s;
display: flex;
flex-direction: column;
}

.outline-modal-content h3 {
margin-top: 0;
margin-bottom: 15px;
color: #333;
font-size: 1.2em; /* 已根據您的要求調小 */
font-weight: 700;
}

#modal-textarea {
width: 100%;
box-sizing: border-box;
font-size: 1.3em;
line-height: 1.6;
border: 1px solid #ccc;
border-radius: 8px;
padding: 10px;
flex-grow: 1;
min-height: 250px;
}

.outline-modal-content .modal-buttons {
text-align: right;
margin-top: 15px;
}

.outline-modal-content .preview-close-btn {
position: absolute;
top: 10px;
right: 10px;
}

#structure, 
#writingTone, 
#writingReviewer, /* <-- 新增這一行 */
#readingTone, 
#booksTone, 
#expandTone, 
#argumentOutlineTone, 
#argumentWritingTone,
#argumentReviewer { /* <-- 新增這一行 (注意最後一行沒有逗號) */
    font-size: 1.05em; /* 將字體縮小為相對較小的值 */
    padding: 6px 10px; /* 同時可以微調內邊距讓它看起來更協調 */
}

/* --- 最終修訂方案 --- */
#booksContainer #initialDiscussionForm input[type="text"],
#booksContainer #initialDiscussionForm textarea {
font-size: 1rem !important; /* 使用 rem 單位並加上 !important */
padding: 10px 12px; /* 也可以微調內邊距讓視覺效果更好 */
} 

/* --- 新增：答題步驟及思路美化樣式 --- */
.steps-container {
margin-top: 20px; /* 與上方標題的間距 */
padding-left: 15px; /* 內邊距，讓內容與邊框有距離 */
border-left: 4px solid #4A90E2; /* 左側的裝飾性藍色邊框 */
}

.step-card {
background-color: #f7f9fc; /* 非常淺的藍灰色背景，增加層次感 */
border-radius: 8px; /* 圓角 */
padding: 15px 20px; /* 卡片內部空間 */
margin-bottom: 20px; /* 這就是步驟之間的垂直距離 */
box-shadow: 0 2px 5px rgba(0,0,0,0.08); /* 輕微的陰影效果，提升立體感 */
transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out; /* 平滑的互動效果 */
}

/* 當滑鼠移到卡片上時，卡片會輕微上浮，陰影加深，提供互動回饋 */
.step-card:hover {
transform: translateY(-3px);
box-shadow: 0 4px 10px rgba(0,0,0,0.12);
}

/* 最後一個步驟不需要下邊距，避免多餘的空白 */
.step-card:last-child {
margin-bottom: 0;
}

.step-title {
font-weight: bold; /* 步驟標題加粗 */
font-size: 1.1em; /* 標題字體稍大，更突出 */
color: #0056b3; /* 使用有質感的深藍色 */
margin-bottom: 10px; /* 標題與下方內容的間距 */
}

.step-content {
font-size: 1em; /* 內容字體大小 */
line-height: 1.7; /* 增加行高，讓文字更容易閱讀 */
color: #333; /* 標準的深灰色文字 */
}

/* --- 新增：禁用按鈕的通用樣式 --- */
button:disabled {
background-color: #cccccc; /* 灰色背景 */
color: #666666; /* 深灰色文字 */
cursor: not-allowed; /* 顯示「禁止」的鼠標圖示 */
opacity: 0.6; /* 降低透明度 */
}

/* 【修訂後】確保此樣式也適用於有特定 class 的按鈕 */
.btn:disabled, .btn-icon-confirm:disabled, .btn-action:disabled {
background-color: #cccccc !important; /* 使用 !important 覆蓋原有樣式 */
border-color: #cccccc !important;
cursor: not-allowed;
opacity: 0.6;
box-shadow: none; /* 移除陰影 */
transform: none; /* 移除變形效果 */
}

#customTopicArea input[type="text"],
#customTopicArea textarea,
#argumentCustomTopicArea input[type="text"],
#expandCustomTopicInputArea input[type="text"],
#expandCustomTopicInputArea textarea,
/* 【新增這兩行】針對整合拓展的「指引」功能內的輸入框 */
#expandGuideArea input[type="text"],
#expandGuideArea textarea {
font-size: 1rem !important; /* 使用 !important 確保覆蓋，1rem 為標準大小 */
padding: 10px 12px; /* 配合較小字體，微調內邊距 */
}

/* --- 新增：評等系統專用樣式 (修訂版) --- */
.grading-container {
margin-top: 25px;
border-top: 2px dashed #aeb6bf;
padding-top: 20px;
/* 【新增】確保整個評等容器也不會超出主容器 */
max-width: 100%;
overflow-x: hidden;
}

.grading-grid {
display: grid;
/* 預設為兩欄佈局 */
grid-template-columns: 1fr 1fr;
gap: 20px;
align-items: flex-start;
}

.grading-scores, .grading-radar {
background-color: #f8f9fa;
border: 1px solid #dee2e6;
border-radius: 8px;
padding: 20px;
box-shadow: 0 1px 3px rgba(0,0,0,0.04);
max-width: 100%;
box-sizing: border-box;
/* 【新增】確保寬度只佔90% */
width: 90%;
margin: 0 auto; /* 【新增】讓容器置中 */
}

.grading-scores h3, .grading-radar h3 {
margin-top: 0;
color: #343a40;
border-bottom: 2px solid #e9ecef;
padding-bottom: 10px;
margin-bottom: 15px;
}

.score-item {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 12px;
gap: 10px; /* 在項目間增加一些間隙 */
}

.score-item label {
font-weight: bold;
color: #495057;
flex-shrink: 0;
margin-right: 10px;
}

.score-item .slider-container {
display: flex;
align-items: center;
gap: 10px;
width: 100%;
max-width: 160px;
}

.score-item .progress-bar-container {
width: 120px;
height: 12px;
background-color: #e9ecef;
border-radius: 6px;
overflow: hidden;
border: 1px solid #ced4da;
}

.score-item .progress-bar-fill {
height: 100%;
width: 0%;
background-color: #007bff;
border-radius: 6px;
transition: width 0.4s ease-in-out;
}

.score-item .score-display {
font-weight: bold;
width: 25px;
text-align: center;
color: #0056b3;
}

.total-score-container {
margin-top: 20px;
padding-top: 15px;
border-top: 1px solid #dee2e6;
display: flex;
justify-content: space-between;
align-items: baseline;
flex-wrap: wrap;
}

#finalGrade,
[id$="FinalGrade"] {
font-size: 2.5em;
font-weight: bold;
color: #d9534f;
line-height: 1;
}

#totalScoreDisplay,
[id$="TotalScoreDisplay"] {
font-size: 1.2em;
font-weight: bold;
color: #333;
}

.radar-chart-container {
position: relative;
aspect-ratio: 4 / 3;
max-height: 350px;
width: 100%;
}

@media (max-width: 768px) {
.grading-container {
margin-top: 25px;
border-top: 2px dashed #aeb6bf;
padding-top: 20px;
}

.grading-grid {
/* 改為單欄佈局 */
grid-template-columns: 1fr; 
/* 【新增】確保整個網格置中並達到95%寬度 */
width: 95%;
margin: 0 auto;
justify-items: center;
}

.grading-scores, .grading-radar {
padding: 15px;
/* 【核心修訂】在手機版確保寬度達到95% */
width: 95%;
max-width: 95%;
}

.radar-chart-container {
/* 在手機上圖表獨佔一行，可以讓它更高 */
aspect-ratio: 1 / 1; 
max-height: 400px;
}

/* 【新增修訂】稍微減少左右邊距，為內容爭取更多空間 */
.grading-scores, .grading-radar {
padding: 15px;
}

/* 【新增修訂】讓評分項目可以提前換行，避免內容擠壓導致溢出 */
.score-item {
flex-wrap: wrap; 
}
.score-item label {
width: 100%; /* 讓標籤（如：內容 (40)）獨佔一行 */
margin-bottom: 5px; /* 在標籤和下方的進度條之間增加一點間距 */
}
.score-item .slider-container {
max-width: 100%; /* 讓進度條容器佔滿可用寬度 */
}
}

/* --- 【全新】儲存HTML按鈕樣式 --- */
/* --- 【新增】包裹生成內容和按鈕的容器樣式 --- */
.result-wrapper {
    /* 1. 使用 Flexbox 佈局 */
    display: flex;
    /* 2. 讓子項目（內容和按鈕）垂直堆疊 */
    flex-direction: column;
    /* 3. 讓子項目在水平方向上置中 */
    align-items: center;
}

/* --- 【全新】儲存HTML按鈕樣式 (置中於下方版本) --- */
.btn-save-html {
    /* 移除絕對定位，讓按鈕回到正常的文檔流中 */
    position: static; 
    
    /* 讓按鈕與上方的生成內容之間有足夠的距離 */
    margin-top: 20px; 
    
    /* 以下樣式保持不變，維持按鈕本身的外觀 */
    width: 40px;
    height: 40px;
    background-color: rgba(106, 122, 138, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.5);
    border-radius: 50%;
    color: white;
    display: none; /* 預設仍然是隱藏的 */
    justify-content: center;
    align-items: center;
    cursor: pointer;
    z-index: 10;
    opacity: 0.85;
    transition: all 0.2s ease-in-out;
    padding: 0;
    margin-left: auto; /* 配合 flexbox 置中 */
    margin-right: auto; /* 配合 flexbox 置中 */
}

.btn-save-html:hover {
    opacity: 1;
    transform: scale(1.1);
    background-color: rgba(90, 105, 120, 0.9);
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.btn-save-html svg {
    width: 20px;
    height: 20px;
}

/* --- 為課外書籍的下載按鈕設定專屬顏色 --- */
#booksButtons #save-books-html-btn {
    background-color: rgba(74, 144, 226, 0.8); /* 質感藍色 */
}

/* ====================================================================== */
/* === 請將以下所有程式碼，貼到您 <style> 標籤的最底部 === */
/* ====================================================================== */

/* --- 修訂一：讓議論文的聊天歷史容器與其他容器樣式同步 --- */
#argumentChatHistory {
    background-color: #f0f4f8;
    border: 1px solid #dde3ea;
    border-radius: 12px;
    padding: 20px 15px;
    margin-top: 15px; /* 與上方評分系統的間距 */
    margin-bottom: 15px;
    max-height: 400px;
    overflow-y: auto;
    display: flex; /* 預設由 JS 控制顯示 */
    flex-direction: column;
}

/* --- 修訂二：將議論文的聊天輸入框加入樣式規則，修正發送鍵位置 --- */
#argumentChatInputContainer {
    display: flex; /* 使用 flex 佈局來排列輸入框和按鈕 */
    align-items: center; /* 垂直置中對齊 */
    gap: 10px; /* 在輸入框和按鈕之間增加間距 */
    margin-top: 15px;
}
#argumentChatInputContainer textarea {
    flex-grow: 1; /* 讓文字輸入框佔據大部分可用空間 */
    margin: 0; /* 移除預設的 margin */
}

/* --- 修訂三：強制指定主容器內的佈局，確保點評和聊天框垂直堆疊 --- */
/* 這個規則是解決「內容跑到右邊」的關鍵 */
#writingReviewResultContainer,
#argumentReviewResultContainer {
    display: flex; /* 使用 flex 佈局 */
    flex-direction: column; /* 強制所有子項目（點評、聊天歷史、輸入框）垂直排列 */
    gap: 15px; /* 在這些主要區塊之間增加舒適的垂直間距 */
    width: 100%; /* 確保容器佔滿寬度 */
}

	/* ====================================================================== */
/* === 【全新】點評範疇 UI/UX 升級樣式 === */
/* ====================================================================== */

/* 1. 包裹所有標籤的容器 */
.scope-selector-container {
    display: flex;
    flex-wrap: wrap;
    gap: 12px; /* 標籤之間的間距 */
    margin-top: 10px;
    padding: 15px; /* 容器內邊距 */
    background-color: rgba(0, 0, 0, 0.05);
    border-radius: 8px;
    border: 1px solid rgba(0, 0, 0, 0.08);
}

/* 2. 隱藏原始、醜陋的 checkbox 輸入框 */
.scope-label input[type="checkbox"] {
    display: none;
}

/* 3. 將 label 標籤美化成按鈕樣式 */
.scope-label {
    display: inline-block;
    padding: 8px 16px;
    border-radius: 20px; /* 圓角膠囊形狀 */
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.3s ease;
    user-select: none; /* 防止雙擊選取文字 */
    border: 1px solid transparent;

    /* 預設狀態 */
    background-color: #f0f0f0;
    color: #555;
}

/* 4. 滑鼠懸停效果 (只對可用的標籤生效) */
.scope-label:not(.disabled):hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    border-color: #007bff;
}

/* 5. 選中 (Active) 狀態的樣式 */
.scope-label.active {
    background-color: #007bff; /* 主題藍色 */
    color: white;
    font-weight: bold;
    box-shadow: 0 2px 5px rgba(0, 123, 255, 0.3);
}

/* 6. 禁用 (Disabled) 狀態的樣式 */
.scope-label.disabled {
    background-color: #e9ecef; /* 更淺的灰色 */
    color: #adb5bd; /* 變淡的文字顏色 */
    cursor: not-allowed; /* 禁止點擊的鼠標樣式 */
    opacity: 0.7;
}

/* 7. 當「全部」被選中時，給予特殊樣式 (修訂版) */
.scope-label.all-scope.active {
    background-color: #4F5B93; /* 典雅的靛藍色 */
    color: white;
    box-shadow: 0 2px 5px rgba(79, 91, 147, 0.3); /* 配合新顏色的陰影 */
}

/* --- 新增：解題指引樣式 --- */
#writingGuideTopicInput {
    padding: 15px;
    border: 2px solid #4A90E2;
    border-radius: 8px;
    width: 100%;
    margin-bottom: 15px;
    font-size: 1.2rem;
    transition: all 0.3s ease;
    background-color: #fcfdfd;
}
#writingGuideTopicInput:focus {
    border-color: #28a745;
    box-shadow: 0 0 10px rgba(40, 167, 69, 0.2);
    outline: none;
}

/* 2. 標題區塊 */
.guide-section-header {
    padding: 10px 15px;
    margin-bottom: 15px;
    background-color: rgba(255, 255, 255, 0.8);
    border-radius: 0 8px 8px 0;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}
.guide-section-header h3 {
    margin: 0;
    font-size: 1.3rem;
    display: flex;
    align-items: center;
    gap: 10px;
}

/* 3. 介紹卡片 (Intro) */
.guide-intro-card {
    background: #fff;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.05);
    margin-bottom: 25px;
    line-height: 1.8;
    color: #444;
    font-size: 1.05rem;
    border: 1px solid #eee;
}

/* 4. 三欄佈局 (用於心情和種子) */
.guide-grid-3 {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 強制三欄 */
    gap: 20px;
    margin-bottom: 20px;
}

/* 手機版自動變單欄 */
@media (max-width: 768px) {
    .guide-grid-3 {
        grid-template-columns: 1fr;
    }
}

/* 5. 通用卡片樣式 */
.guide-card {
    background: #fff;
    border-radius: 10px;
    overflow: hidden;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    border: 1px solid #f0f0f0;
    display: flex;
    flex-direction: column;
}
.guide-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(0,0,0,0.1);
}

/* 6. 情感卡片 (Emotion) */
.emotion-card {
    border-top: 4px solid #4A90E2; /* 藍色頂邊 */
}
.emotion-card .card-title {
    background-color: #f4f9ff;
    padding: 12px 15px;
    font-weight: bold;
    color: #2c3e50;
    font-size: 1.1rem;
    border-bottom: 1px solid #eef2f7;
}
.emotion-card .card-content {
    padding: 15px;
    font-size: 0.95rem;
    color: #666;
    line-height: 1.6;
}

/* 7. 種子卡片 (Seed) */
.seed-card {
    border-top: 4px solid #28a745; /* 綠色頂邊 */
}
.seed-card .seed-header {
    background-color: #eafaf1;
    padding: 15px;
    font-weight: bold;
    color: #1e7e34;
    font-size: 1.15rem;
    text-align: center;
    border-bottom: 1px solid #dff0e6;
}
.seed-card .seed-body {
    padding: 20px;
    font-size: 0.95rem;
    color: #555;
    line-height: 1.7;
}
.seed-card .seed-body p {
    margin-bottom: 12px;
}
.seed-card .seed-body p:last-child {
    margin-bottom: 0;
}
.seed-card strong {
    color: #333;
    display: block; /* 讓標籤獨佔一行，更清晰 */
    margin-bottom: 5px;
}

</style>
</head>
<body>


<div class="title-container">
<h1>
<span class="title-text">神思</span>
</h1>
</div>


<div id="hitokoto-container" class="box">
<div id="hitokoto"></div>
<div id="hitokoto-footer">
<span id="hitokoto-from"></span>
<button id="refresh-btn"><i class="fas fa-sync-alt"></i></button>
</div>
</div>



<style>
#hitokoto-container {
background: rgba(220, 220, 220, 0.96);
border-radius: 8px;
box-shadow: 0 2px 4px rgba(0,0,0,0.1);
padding: 16px;
margin: 15px 0;
text-align: center;
max-width: 800px;
position: relative;
}

@media (max-width: 600px) {
#hitokoto-container {
text-align: left;
}
}

#hitokoto {
font-size: 21px;
font-style: italic;
color: #333;
margin-bottom: 10px;
}

#hitokoto p {
margin: 5px 0;
}

#hitokoto-footer {
display: flex;
justify-content: space-between;
align-items: center;
margin-top: 10px;
}

#hitokoto-from {
font-size: 16px;
color: #666;
}

#refresh-btn {
background: none;
border: none;
cursor: pointer;
font-size: 20px;
color: #666;
transition: color 0.3s;
padding: 0;
margin: 0;
}

#refresh-btn:hover {
color: #000;
}


/* --- 新增：確認圖示按鍵樣式 --- */

.btn-icon-confirm {
/* 1. 外觀設定：圓形、綠色背景 */
width: 44px;
height: 44px;
border-radius: 50%; /* 製作成完美的圓形 */
background-color: #28a745; /* 成功、確認的綠色 */
border: none;

/* 2. 圖示置中與樣式 */
display: inline-flex;
align-items: center;
justify-content: center;
color: white; /* 圖示顏色 */
font-size: 20px; /* 圖示大小 */

/* 3. 互動效果與陰影 */
cursor: pointer;
box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
transition: all 0.2s ease-in-out;
}

.btn-icon-confirm:hover {
/* 4. 滑鼠懸停時：放大、提亮，陰影加深 */
transform: scale(1.1);
filter: brightness(110%);
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
}

.btn-icon-confirm:active {
/* 5. 點擊瞬間：再放大一點，提供回饋感 */
transform: scale(1.15);
}



</style>

<script src="https://cdn.jsdelivr.net/npm/opencc-js@1.0.5/dist/umd/full.js"></script>


<script>
document.addEventListener('DOMContentLoaded', function() {
const converter = OpenCC.Converter({ from: 'cn', to: 'tw' });
const hitokotoElement = document.getElementById('hitokoto');
const hitokotoFromElement = document.getElementById('hitokoto-from');
const refreshBtn = document.getElementById('refresh-btn');

function fetchHitokoto() {
fetch('https://v1.hitokoto.cn/?c=d&c=i&c=k&encode=json')
.then(response => response.json())
.then(data => {
if (data.from.includes('魔道祖師')) {
fetchHitokoto(); // 如果來源是「魔道祖師」，重新獲取名言
} else {
// 使用 textContent 可以自動處理特殊字元，是顯示純文字的最佳選擇
hitokotoElement.textContent = converter(data.hitokoto);
hitokotoFromElement.textContent = `—— ${converter(data.from_who || '佚名')} 《${converter(data.from)}》`;
}
})
.catch(error => {
console.error('獲取名言失敗:', error);
hitokotoElement.innerHTML = '<p>獲取名言失敗，請稍後再試。</p>';
hitokotoFromElement.innerHTML = '';
});
}

fetchHitokoto();
refreshBtn.addEventListener('click', fetchHitokoto);
});
</script>

<!-- 內置的 5** 級數範文 (隱藏) -->
<div id="five-star-examples" style="display: none;">
<div id="example-yanhuo">
<h3>《煙火》</h3>
<p>回鄉的我凝望著門前的「河流」，沉默不語。那場璀璨的煙火又在我杳遠的回憶隱然綻放。
我記得，故鄉梁莊的那夜是樸素的，是低調的，就像默默俯身收割莊稼的農民；我記得，那時祖屋的遠處種著桑樹，樹上迴響著清亮的蟬聲，而近處蜿蜒著一道河，河畔的蘆葦總傳來蛙鳴；那是元旦，鄰居李叔親切地送上祝福，又從吳鎮的煙火廠帶來了龍吐珠，與村民慶賀新春。煙花在夜幕訇然盛放之時，七歲的我正環抱著爺爺的頸項。所有的澄黃、亮綠和緋紅倏爾煥爛在我的眼眸。火光乍現，煙花便瞬即璀璨而華麗地枯萎了，只賸下硝煙和火藥的氣息。
我哭了，爺爺以為我被煙火嚇壞了，瞬即摩娑著我的背。
其實，我不過是驚詫於一切美好的幻滅。
後來，我才瞭解人生有許多事情都注定是一場美好的幻滅，如同煙火。
爺爺是我的留守歲月最璀璨的印記。我從村校放學回家時，爺爺總會捧著熱氣騰騰的、白花花的饅頭迎接著我。阿念，吃吧，快點吃吧。爺爺沙啞的聲線仍猶在耳。童年的我總喜歡伏在爺爺的背上諦聽著時間，一秒，兩秒，是多麼沉穩的幸福呢。背並不厚實，但卻溫暖和煦。時間仿佛會一直定格在這一幀。然而在我九歲那年，爺爺死了，就淹死在門前的河。建築公司在河底挖沙蓋樓，河道看來平靜，卻暗藏漩渦。爺爺游泳時被暗湧拉扯到河底，就活活淹死了。短短數年的歲月，在人生裡不過是一場倉卒燃燒的煙火，爺爺在我的回憶裡綻放過澄黃、亮綠和緋紅，卻連一縷硝煙都沒有遺下，只遺下了一件濡濕的、皺巴巴的汗衣，儼如因衰老而再無能為力綻放的煙花。
還有門前的河流，在爺爺死後十年，已經沉默得如患上了失語症，河水乾涸，河床裸露，像被歲月無情強暴了一樣。夏蟬和青蛙，都憂鬱得噤聲不語，遷徙到回憶之外。李叔前年在電鍍廠中毒過身了。童年時一切一切的美好，都如海市蜃樓般驟然無存。歲月燃點了一場煙花，最後只遺下沉重的回憶，以及沉重地回憶的我。煙火再璀璨，也是匆促的。
本來我是這樣認為的。
直至又再離鄉之際，我才赫然窺探到煙火的秘密。
村口的大樹懸掛著纍纍碩大的林柿，那一個個橘橙的果實每年都爛在樹上，沒有村民採摘，連雀鳥都不屑一顧。在我準備踏出村口時，一顆飽滿的柿子掉落到我面前。我啃咬了一口，還是一如回憶的苦澀、難吃，我急不及待將咀嚼中的柿肉吐出來，且棄之如敝屣。我倏爾發現，縱然梁莊物換星移已不知幾度秋，但仍有許多回憶的遺跡，比如是眼前這棵金玉其外的柿樹。它的果實仍然是澀的，我想，是因為它仍然鮮活、茂盛、強壯，是因為它仍未枯謝、凋零、衰敝。假如它成為了歲月匆促幻滅的過客，也許那味道會是甘甜的苦澀，也許我會懷念那苦澀。
我再次凝望著那乾涸的河道。曩昔我嫌棄過蟬囀蛙鳴聒耳，擾人清夢；我埋怨過蘆葦纖長，阻礙了我的視野；我拒絕過爺爺的饅頭，因為寡淡無味，因為我想吃肉香滿溢的五香肘子啊，不想吃寡淡的、慘白的饅頭。我討厭過李叔蠟黃的臉色，討厭過他衣衫襤褸，討厭過他渾身汗臭，我討厭過李叔的一切。諷刺的是，隨著物和事匆促的面目全非，我竟爾留戀上一切我討厭過的。
於是我開始明白煙花的璀璨，在於它的匆促和幻滅。
時間會過濾掉所有人和事的雜質，隨著泯滅變易，我們開始犯賤地珍惜，然而珍惜的唯一意義僅在於遺憾，但正因為遺憾，才體現到事物的璀璨。倘若爺爺和李叔仍然在世，倘若門前的河仍然流淌不斷，倘若蟬聲蛙鳴依舊，倘若絢爛永恆，那麼一切便將腐爛而不再璀璨，他們和它們都將蛻變成被棄如敝屣的柿子。我曾以為煙火再璀璨，也是匆促的。但原來我錯了。原來煙火璀璨，正因為匆促。一旦煙火永恆，它將失去生命，教人徒然目眩。
離鄉的這夜，恰巧是元旦。是夜天陰，無雨。梁莊寂寥如一場夢，再沒有盛放的煙火。因為，煙花從此只在我的回憶裡燦爛地綻開、匆促地結果。</p>
</div>
<div id="example-gen">
<h3>《根》</h3>
<p>火焰燃起了一瓣又一瓣的灰燼，它們即生即滅，像飄萍，是一種無根的存在。餘燼隨風零落，又再揚起，終落入了深邃的虛無裡。人們說，紙錢燒成灰燼，便會飛落到地獄，交到亡靈的手裡。
父親，你收到了嗎？
你，尋到你的根了嗎？
我向着一枚貝殼問道。
我們的故鄉是一個江南小鎮，名曰周莊。明代江南首富沈萬三昔曾坐落此處發施號令，指點江山，各種契約、決斷和銀票都有這裡大進大出過，如今卻只賸下沈廳的空寂。鎮上到處都是貫穿南北的河道，就像永不乾涸的阡陌。周莊的河網養活了一代又一代的周莊人，從這裡出發，可借河道而東西南北，近至蘇杭，遠通東南亞。我的父親，只是貿易的一塊細小的零件——卑微的船夫，但他卻盤根錯節，支撐著整個家庭。
「爸，你甚麼時候回家？」
小時候，每當我牽扯著他的衣襬問他這道問題時，他總會帶著疲憊的莞爾，摩娑著我的腦殼說道：
「很快了，很快了。」
於是，一去便是三兩個月了。他在無垠的河川和滄渤航行了一輩子，曾為多少家庭送上過物資，又曾目睹過多少匆忙歸家的白鷗呢？然而，他自己卻成為了一個無根的人。他飄洋過海，仿佛只為回來時睡一覺昏沉的。無根的浪花，便是父親的象徵；一身的鹹腥，便是他半生的註腳。
他細碎又重複的夢囈被年幼的我記住了。
在漫長的夢裡，他是參天巨樹，偉岸的、繁茂的，扎根在風吹草低見牛羊的草原。風拂過他的臉龐，他貪婪地流了一行涎液。
一切都只為了養活我們四兄弟姐妹，成為這個家庭的根。母親呢，從不嚮往自由而無根的蒲公英，在我們孩提時代，她已經從周莊的河網掙脫出去了。只賸下父親，像根一樣默默無言地支撐著這個家庭的經濟，用河水澆灌，為它提供養份；用船櫓翻土，使它茁壯成長。我們幾兄弟姐妹，就恍如纍纍碩大的果實。果實之所以飽滿豐美，全因深扎泥土的根。
短暫洗去風塵後，又是一個擾人的昒暝。陽光揉開他的眼瞼，那沉重的眼瞼，一場無垠的旅程又將展開。
他成為了我們的根，自己呢，卻一直飄泊於風波不定的大海。我一直想，他的根究竟在哪裡呢？
也許，從來都不在印有郵遞編號的地方，而在我們。但早在十年前，都被我們砍斷了。終於，父親失去了他惟一的根。
長大後，我們不再牽扯父親的衣襬。父親在我們的印象，是一種昏睡的存在，我們之間存在著一種歲月孕育出來的隔閡——不冷淡又不溫韾的沉默。就像周莊的河水，既不溷濁，又不清澈。只有生活的氣息。隨著長大，我們一個又一個離開了日復如是的故鄉。他用一身風塵支撐的家，早在歲月的長河中淡褪了顏色。
被淹沒了。
大哥從來沒有帶過孩子回鄉。
二姐結婚時沒有邀請過父親。
妹妹幾年來音信杳無，聽說到加拿大去了。
只有我偶爾回鄉。父親總是無所事事，落寞地坐在斜曛映照的碼頭上，抽著雙喜牌香煙，眺望著那平靜如日子的河川。夕陽落在他身上，拓出了一個單薄的黑影。我這才知道，原來影子是會老，是會萎縮的。
他的身體開始坍塌，大不如曩日的壯碩，因為失去了根，失去了人生角色的緣故。他已經沒有了壯碩的理由。在病榻上，只有噏動的嘴唇透露著生命的跡象，在明滅不定的沉吟裡，我諦聽到我們的暱稱，又諦聽到那個關於樹的夢的碎片。不一樣的是，樹好像連根拔起了，似乎被一場颱風吹倒了。
我不會遺忘父親的好。每次他回周莊，他總會為我們帶來一枚貝殼，我愛把貝殼湊在耳畔聽那大海的聲音，有溫煦的，有舒爽的，有寂寞的，有思念的。他出航的畫面，總如真似幻地映照在我的腦海裡。但我無法將愛裸裎地宣之於口。父親，你飄泊半生，四海為家，卻終於失去了支撐你努力活著的角色。為了成為我們的根，你失去了自己的根。也許，也許你無法扎根在這個世界任何一隅，但我卻早為你預留了一捧最肥沃的泥土——在我心裡，讓你終於可以安息，終於可以落葉歸根，終於不用再飄泊不定。
海風永不止息地吹拂著一個夢，雲亦舒捲著無根的故事。</p>
</div>
<div id="example-dengdai">
<h3>《等待》</h3>
<p>月亮高懸在闃寂的夜空，儼如吊著一顆無眠的眼睛。它仿佛記得，自己已用幾千年的時間等待一個人，但卻已遺忘了等待的對象。於是，它映照著下方喧囂的城市，映照著每一個在城市裡等待著的人。
比如說，一個在晚窗前許願的孩子，他在等待著綠豆的幼苗在濕潤的棉花裡茁壯成長，並開花結果。
又比如說，一個無聲吶喊著的女人。他的丈夫，那醉醺醺的男人，又在發瘋。一頓拳打腳踢之後，她身上青一片、紫一片的。原來人的皮膚可以呈現如此斑駁的顏色。然而，她已不驚詫，因為暴力早教她看見青紫色的自己。不過，她在等待，她依猶在等待，依猶在等待那個婚禮上替自己戴上婚戒的他。
想著想着，她無端落下了一滴淚。原來，許多人也在歲月的長河裡無止境地等待著。等待的人並不孤單。
一幀泛黃且充滿顆粒感的照片裡，一個小女孩正佻皮地捏著母親的臉頰，母親佯作生氣，她幸福地「生氣」著。
可愛吧？這個左邊的小女孩，便是我的女兒。 
嗯，可愛。
同樣的對話，同樣的故事，在這八年的時光裡重重複複地敘述著。仿佛是一本八百頁的長篇小說，只有這樣的一段對話。但是，她仍樂此不疲地閱讀著小說的每一頁。因為，因為她已遺忘了上一頁的所有內容。
那個小女孩，便是我，而那位母親患了病，一場將我遺忘的病。
我一直等待著，等待著她有天重新憶記起我；等待著她像小時候一樣，摩娑著我的腦殼，溫柔地哄我入睡；等待著她生活裡每句使人心煩的嘮叨。我等待了八年，為此，我與她一起翻閱舊相冊，一起重遊所有老地方，然而奇蹟一直保持沉默，不作任何回應。在歲月的長河裡，只賺下佇立著、等候著的我。
女兒啊……
她又再躺在沙發上說著朦朦朧朧的囈語。
今晚煮了湯，放在客廳的……
「桌上」兩個音節裹未孵出來，便已胎死在掛掉的話裡了。那時的我，在過著燈紅酒綠的生活。月，仿佛才是昒暝的日出。一杯又一杯的長島冰茶灌進肚裡，根本容不下一碗溫熱的湯。
恰巧，也是八年的時間，媽媽也等待了八年的時間。她每一個晚上都在夢囈裡盼望著我歸家。然而等待一次又一次落空，只有蒼然寂寞的月色悄悄地透過窗戶，替她蓋上一張沒有溫度的被子。
八年後，我才真正明白等待的滋味，才體會到等待的煎熬。你是如何孤單地度過每一個昏暗的夜，如何忍受著一句句使你痛徹心扉的說話？一切的等待為了甚麼？
我的女兒回來了嗎？
你瞇著惺忪的睡眼問我。
還未，她還未回來，再等一下吧。
其實，她永遠都不會回來了，因為她已永恆地滯留在時光的隧道裡。在那個地方，夢即現實，回憶即現實，人永遠不會長大，更不會蒼老。因此之故，她永遠不會回來了。
至於我等待的人，等待的一聲呼喊，也不會回來了。她已羈困在一段停滯的時光裡，沒有逃逸，亦沒有人想逃逸。因為，她已等待得支離破碎，疲憊不堪了。
我們的等待，注定了落空。
但八年的等待裡，我終究參悟了落空的意義。正如那棵似乎會勃發生長的綠豆苗，也許一星期後便會似一場曉夢般枯萎，但孩子學會了生命的價值，學會了甚麼是失落，學會了憧憬在字典外的含義；又正如那個滿佈瘡痍的女人，在漫無邊際的等待裡，或許終於明白了有些等待並不值得，明白了有些等待並不值得，明白了有些等待只是一廂情願，於是鼓起離婚的勇氣。在等待裡，所有人都會找到新的意義。也許，等待只是一場燦爛奪目的煙花，只承諾開花，卻從不承諾結果。但在等待裡，我們都重新認識了自己和他人，甚或是人生。一如八年的等待，使我終於能體會媽媽的體會，孤寂、失望、無奈、感慨、悱惻，我都一一感受到了。她沒有遺下一句說話，便將我遺留在時光的彼岸，然而她內心最隱密的說話，我已諦聽到了。因為，我也成為了一個等待的人。等待的過程裡，我還學會了堅強、勇氣和耐心。從前，我何曾耐心地回應過她一句呢？
等著等著，她便像個孩子似的，哭嚷著要女兒回來，我溫柔地摩娑著她的髮絲、她的臉龐、她的下巴、她的背、她的手，又在她耳畔低語：「別怕，我與你一起等女兒回來，好不好？」她冷靜下來，默默地頷著首。
煙花，終於結了果，一如等待，終於在落空中結了果。</p>
</div>

<div id="example-yanhuo-l3">
<h3>《煙火》(3等範文)</h3>
<p>夏天的夜晚，總是充滿了期待。小明是小六的學生，他最喜歡的事情就是和家人一起去看煙火。每年的鎮上夏日祭典，廣場上都會放一場盛大的煙火表演。那絢麗的光芒、絢爛的色彩，總讓小明看得目不轉睛，心裡充滿了驚奇與快樂。
這一天，小明早早就吃完了晚飯，興奮地拉著爸爸媽媽的手，往廣場走去。路上，他看見許多鄰居和同學，大家都帶著笑容，提著小板凳或鋪著野餐墊，準備找個好位置欣賞煙火。小明的妹妹小芳也跟著，蹦蹦跳跳地哼著歌，手裡還拿著一根螢光棒，閃閃發光。
到了廣場，已經人山人海。小明一家找了一塊空地，鋪上毯子，坐下來等待。天空還有些微亮，夕陽的餘輝灑在遠處的山頭上，像一幅美麗的畫。廣場上有人在賣棉花糖和烤魷魚，香味飄過來，讓小明忍不住嚥了口口水。爸爸笑著說：「等看完煙火，爸爸給你買一串烤魷魚好不好？」小明高興地點點頭。
終於，天色完全暗了下來。突然，一聲「砰」的巨響劃破夜空，第一顆煙火像一朵巨大的金色菊花，在天空中綻放開來。人群中傳來一陣驚呼，小明瞪大了眼睛，嘴巴張成了「O」形。接著，紅的、藍的、綠的、紫的煙火一個接一個升空，有的像流星劃過，有的像瀑布傾瀉，還有的像一顆顆閃亮的星星，點亮了整個夜空。
小明最喜歡的是那種會「咻咻」轉圈的煙火。它們先是像火箭一樣衝上天，然後在空中轉出一個個彩色的光圈，好像在跳舞一樣。小芳拍著手喊：「好漂亮！像仙女在撒花！」小明也忍不住跟著喊：「再來一個！再來一個！」爸爸媽媽在一旁笑著，看著孩子們開心的模樣，也覺得特別幸福。
煙火表演持續了半個多小時，每一顆煙火都讓小明覺得驚喜萬分。他心想，這些煙火是怎麼做出來的呢？為什麼它們可以在天空中變出這麼多不同的形狀和顏色？表演結束後，小明忍不住問爸爸：「煙火是怎麼來的？是誰發明的？」
爸爸摸摸小明的頭，笑著說：「煙火的歷史很長喔！聽說是古代的中國人發明的。他們發現一些化學物質混在一起會爆炸，後來就用來做煙火，讓節日更熱鬧。每一顆煙火裡都有不同的化學藥劑，這些藥劑決定了它們的顏色和形狀。紅色的煙火可能有鍶，藍色的有銅，綠色的有鋇，這些都是科學的魔法！」
小明聽得眼睛亮亮的，覺得好神奇。他想像著一群科學家在實驗室裡調配藥劑，試著做出最漂亮的煙火。他心裡暗暗決定，回家後要上網查更多關於煙火的知識，或許將來他也能成為一個會做煙火的人！
煙火結束後，廣場上的人群慢慢散去。小明一家走在回家的路上，夜風輕輕吹過，帶著一絲涼意。小芳已經累得在爸爸的懷裡睡著了，小明卻還在回味剛剛的煙火。他抬起頭，看著滿天的星星，心裡充滿了夢想。他想，煙火就像人生一樣，雖然短暫，卻可以綻放出最美的光芒。只要努力，他相信自己也能像煙火一樣，在未來某一天閃耀屬於自己的光彩。
回到家，小明拿出日記本，寫下了今天的感受：「今晚的煙火好美！它們在天空中飛舞，像在告訴我，只要有夢想，就能飛得很高很高。我要好好學習，將來也要像煙火一樣，點亮別人的眼睛！」</p>
</div>

<!-- 新增議論文示例 -->
<div id="example-song-li">
<h3>《送禮之我見》</h3>
<p>每個人的一生都與禮物結下不解之緣。親友的滿月賀禮，承載著對新生命的祝福；長輩的壓歲紅包，包裹著對後輩的期許。然而，當物質洪流席捲現代社會，送禮這項古老習俗，卻在功利浪潮的沖刷下漸失本真，淪為人情往來的籌碼與攀比虛榮的角力場。人們穿梭於琳琅禮品間，精打細算著禮物的「價值」能否匹配關係的「份量」，卻鮮少思量這份心意是否仍如初生赤子般純粹無雜質。當饋贈的初衷被異化為計算，我們是否該停下腳步，重新審視禮物的真諦？

禮物的靈魂，從來不在其金玉其外的華美包裝，而在其蘊含的情意之真摯與純粹。古訓有云：「千里送鵝毛，禮輕情意重。」此語道破了饋贈的核心價值——心意遠勝物質。唐代詩人白居易在《秦中吟》中，對權貴間「一叢深色花，十戶中人賦」的奢靡饋贈極盡諷刺，揭露其虛榮浮誇的本質。反之，近代文豪魯迅，常以親筆題簽的書籍贈予青年學子。那薄薄一冊書，承載的是一位啟蒙者對後輩深沉的期許與精神火種的傳遞。魯迅深知，真正有力量的禮物，是能點亮心靈、啟迪思想的火炬，而非點綴門面的俗物。由此觀之，禮物之重，在於心意之深。若僅以價格衡量價值，則再貴重的禮品，亦不過是冰冷交易的憑證，失卻了情感交流的溫度。

可惜，當代社會中，禮物的異化現象俯拾皆是。饋贈時常淪為維繫社會關係網絡的工具，甚至背負著隱形的「債務枷鎖」。法國人類學家莫斯在《禮物》一書中精闢指出，傳統社會的禮物交換蘊含著「給予、接受、回報」的義務性循環，這股無形的社會壓力，常使受贈者感到負擔。反觀今日，此現象愈演愈烈。職場上，年節贈禮常被視為人情投資；婚宴嫁娶，賓客更暗自計較紅包厚薄是否「等值」。更甚者，如《紅樓夢》中賈府壽宴，王熙鳳對各房禮單的斤斤計較，將人情世故的算計演繹得淋漓盡致。當送禮者與受禮者皆困於「人情債」的算計，禮物便不再是心意的載體，而是淪為衡量利害得失的冰冷砝碼。這份計較，不僅磨損人際真誠，更使饋贈的初衷蒙塵。

或許有人辯稱，身處人情社會，送禮難以擺脫功利色彩，所謂「真誠」不過是理想化的奢談。此言差矣。禮物的真偽，關鍵在於饋贈者的用心與純粹。魏晉名士嵇康，面對好友山濤欲舉薦其為官的「厚禮」，選擇以《與山巨源絕交書》明志。這封看似決絕的信，恰恰是嵇康回贈給山濤最貴重的禮物——一份對本真與氣節的堅守。他寧願承受斷交的「失」，也不願以人格自由作為交換官位的「得」。嵇康的行為啟示我們，真正的禮物，源自內在的誠懇與尊重，而非外在的價值或目的。若內心澄澈，即便是婉拒，亦可成為一份震撼靈魂的厚禮；反之，若動機不純，再華貴的饋贈，亦不過是包裹著糖衣的虛偽交易。禮物的重量，終究繫於心意之秤，而非物質之衡。

誠然，在現實的夾縫中尋求全然超脫的饋贈境界並非易事。我們或許無法徹底摒棄人情往來的社會習性，但至少能在每一次饋贈前，叩問己心：這份禮物，是否源自純粹的關懷與祝福？而非包裹著交換、償還或炫耀的雜質。英國文豪王爾德曾諷刺道：「憤世嫉俗者知道所有東西的價格，卻不知道任何東西的價值。」這警語猶如明鏡，映照出我們在物質洪流中對價值的迷失。當我們過分執著於禮物的價格標籤，便極易遺忘其無價的情感內核。歸根結柢，送禮的最高藝術，在於使物質載體成為傳遞真情的使者，讓每一次贈予，都成為心靈間溫暖的交匯點。贈人玫瑰，手有餘香——這份香氣，源於真誠，存於心意，與物質的貴賤無涉。你我能否在下次饋贈時，讓這份芬芳，蓋過世俗的塵囂？</p>
</div>

<div id="example-lun-dushu">
<h3>《論讀書》</h3>
<p>讀書是一件很有趣又很重要的事情。小朋友們，你們喜歡讀書嗎？也許有的小朋友覺得讀書很無聊，但其實讀書可以讓我們變聰明、開心，還能認識很多新東西。今天我要來跟你們說說，為什麼讀書是一件很棒的事情。我會用簡單的理由告訴你們，讀書對我們有多好！

讀書就像打開一扇神奇的大門，裡面有很多新東西等著我們去發現。比如說，你有沒有想過恐龍是怎麼生活的？或者太空裡有什麼祕密？當你讀一本關於恐龍或太空的書，你就會知道好多有趣的事情。比如，我讀過一本書，說霸王龍的牙齒像香蕉一樣大！這是不是很酷？讀書可以讓我們學到課堂上沒教的東西，讓我們的腦袋裝滿知識。

不只科學，讀書還能讓我們認識不同的地方和文化。比如，你可以讀一本關於非洲的故事，知道那裡有大大的草原和跑得很快的獅子。這些知識讓我們對世界更好奇，也讓我們變得更聰明。所以，讀書就像一個寶藏箱，裡面裝滿了讓我們變厲害的知識！

你有沒有想過自己變成一個勇敢的騎士，或是飛到天上的超人？讀書可以幫我們想像這些很棒的事情！當我們讀故事書時，我們會跟著書裡的角色一起冒險。比如，我讀過一本書，講一個小男孩在森林裡找到一個魔法棒，然後他用魔法棒打敗了壞巫師。讀的時候，我好像也跟著他一起去冒險，感覺好刺激！

想像力很重要，因為它讓我們會想出新點子。當你畫畫、寫故事，或是玩遊戲時，好的想像力可以讓你做出很棒的事情。比如，你可能會因為讀了一本關於海盜的書，就自己畫了一艘很酷的海盜船！所以，讀書不只讓我們開心，還能讓我們的腦袋變得更有創意。

讀書不只能讓我們變聰明，還能讓我們的心變得更善良。有的書會教我們怎麼跟朋友相處，怎麼幫助別人。比如，我讀過一本書，講一個小女孩幫助了一隻受傷的小鳥，後來他們變成了好朋友。這個故事讓我覺得，幫助別人是一件很快樂的事情。

當我們讀這些故事時，我們會學到什麼是對的，什麼是錯的。這些書就像老師一樣，教我們怎麼做一個好人。比如，當你看到書裡的角色分享玩具，你也會想跟朋友分享東西。這樣，我們的心就會變得更溫暖，朋友也會更多！

有些小朋友可能會說：「讀書好無聊，我想玩遊戲或看電視！」我知道，玩遊戲和看電視也很開心，但它們跟讀書不一樣。遊戲和電視很快就會看完，但書裡的故事可以讓你慢慢想、慢慢感受。而且，讀書可以讓你自己決定故事怎麼走，比如你可以用想像力幫故事裡的角色想新的結局，這是遊戲和電視做不到的！

還有小朋友可能說：「書裡的字好多，看不懂！」沒關係，我們可以從簡單的書開始，比如圖畫書，裡面有好看的圖片，字也不多。慢慢地，你會發現讀書越來越簡單，也越來越有趣。所以，別害怕，試著讀一本你喜歡的書，你會發現它有多好玩！

總之，讀書是一件很棒的事情！它讓我們學到新知識，變得更有想像力，還能讓我們的心更溫暖。雖然有時候讀書可能有點難，但只要我們找到自己喜歡的書，就會覺得它像一個好朋友，陪我們一起成長。小朋友們，讓我們一起拿起書，開始一場知識的冒險吧！不管是故事書、科學書，還是漫畫書，每一本書都是一個新世界，等著我們去探索。每天讀一點書，你會發現自己越來越厲害，也越來越快樂！</p>
</div>




</div>








<!-- 內置的 DSE 評分原則 (隱藏) -->
<div id="dse-grading-principles" style="display: none;">
<h3>【擬卷理念】</h3>
<p>1. 考核能力：考核考生構思、表達、創作等能力。</p>
<p>2. 設題方式：或命題，或指定情境，並提供選擇。</p>
<p>3. 設題方向：主要環繞考生生活經驗及日常思考、關注的情或事；並盡量給予寫作空間，讓考生發揮創意。</p>
<p>4. 寫作要求：考生宜透過審題，思考寫作立意，選取材料，書寫文章。</p>
<p>5. 文體要求：以某類文體為主，或文體不限。</p>

<h3>【一般評分原則：審題、入品】</h3>
<p>1. 準確理解關鍵概念。</p>
<p>2. 明白寫作要求。</p>
<p>3. 把握不同品位的入品要求。</p>

<h3>【評分項目詳解】</h3>
<p><strong>內容 (40分):</strong></p>
<ul>
<li>立意、內容是否合乎寫作要求；是否豐富、深刻。</li>
<li>取材是否恰當；能否彰顯立意。</li>
<li>闡述是否合理、飽滿。</li>
</ul>
<p><strong>表達 (30分):</strong></p>
<ul>
<li>用詞是否精確、豐富。(主)</li>
<li>文句是否簡潔流暢。(主)</li>
<li>表達手法是否純熟靈活。(輔)</li>
</ul>
<p><strong>結構 (20分):</strong></p>
<ul>
<li>段落區分是否明晰。</li>
<li>起承轉合是否自然。</li>
<li>輕重詳略是否恰當。</li>
</ul>
<p><strong>標點字體 (10分):</strong></p>
<ul>
<li>字體為主，標點為輔。</li>
<li>標點使用在於準確和靈活，不在於數量多少。</li>
</ul>
<p><strong>錯別字 (3分):</strong></p>
<ul>
<li>0-1個給3分；2-4個給2分；5-7個給1分；8個或以上不給分。</li>
<li>重錯不計。</li>
</ul>

<h3>【離題卷評分】</h3>
<p>「內容」最高給「下上」；「表達」及「結構」最高給「中上」；「標點字體」最高仍可給「上上」。</p>

<h3>【字數不足650字】</h3>
<p>「內容」最高給分：550-649字：「上上」；450-549字：「中上」；300-449字：「中中(下)」；300字以下：「下上」。</p>

<h3>【一般評論摘要】</h3>
<p><strong>優勝之處:</strong></p>
<ul>
<li><strong>審題:</strong> 能正確理解題目。</li>
<li><strong>立意:</strong> 偶有佳作，能由日常生活引申至人生意義、生活哲理，呈現對生活有敏銳的觀察和思考。</li>
<li><strong>取材:</strong> 圍繞日常生活經歷或見聞取材。</li>
<li><strong>表達:</strong> 用詞大致恰當，文句大致通順；能恰當地敘事抒情、描繪人物或闡述看法；嘗試運用不同寫作手法。</li>
<li><strong>結構:</strong> 分段大致清晰，尚見脈絡；過渡合理，結構完整。</li>
</ul>
<p><strong>不足之處:</strong></p>
<ul>
<li><strong>審題:</strong> 流於表面，未抓緊題眼發揮。</li>
<li><strong>立意:</strong> 立意平常，層次不高。</li>
<li><strong>取材:</strong> 敘事忽略細節，描寫流於表面，論述粗疏簡略；未能翻出新意，提出精闢見解。</li>
<li><strong>表達:</strong> 經營不多，夾雜沙石；多口語入文、句子冗贅；部分與前文格格不入，影響達意。</li>
<li><strong>結構:</strong> 鮮能做到層層深化，前後呼應者；少數文章篇幅較長，惜時間所限，結果虎頭蛇尾；有詳略稍有失衡的情況。</li>
</ul>
</div>


<!-- 工具選擇 -->
<div class="box">
<h2>工具一覽：</h2>
<button id="expandToolsBtn2">點擊展開</button>


<div id="effectContainer" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1001; pointer-events: none;"></div>
</div>

<!-- 範疇選擇 -->
<div class="box">
<h2>選擇範疇：</h2>
<div class="category-buttons-container">
<button id="readingBtn" class="btn-category">📕閱讀</button>
<button id="writingBtn" class="btn-category">✏敘事抒情</button>
<button id="argumentBtn" class="btn-category">📋議論</button>
<button id="expandBtn" class="btn-category">📂整合拓展</button>
<button id="booksBtn" class="btn-category">📚課外書籍</button>
</div>
</div>



<!-- 寫作容器 -->
<div id="writingContainer" class="box">
    <h2>敘事抒情</h2>
    <div style="position:relative; width:100%; height:0px; padding-bottom:62.222%"><iframe allow="fullscreen" allowfullscreen height="100%" src="https://streamable.com/e/lke2eo?loop=0" width="100%" style="border:none; width:100%; height:100%; position:absolute; left:0px; top:0px; bottom:2px; overflow:hidden;" referrerpolicy="no-referrer-when-downgrade" credentialless></iframe></div>

    <div class="function-selector-wrapper">
        <label for="writingType">選擇功能：</label>
        <select id="writingType" onchange="toggleWritingType()">
            <option value="" selected disabled>請在此選擇功能</option>
            <option value="guide">解題指引</option>
            <option value="大綱">大綱點評</option>
            <option value="片段描寫">文章點評</option>
            <option value="敘事物象">敘事物象</option>
        </select>
    </div>

    <div id="writingContentContainer" style="display: none;">
        
        <!-- === 新增：解題指引區域 (修訂版) === -->
        <div id="writingGuideArea" style="display: none;">
            <label for="writingGuideTopicInput">請輸入題目：</label>
            <input type="text" id="writingGuideTopicInput" placeholder="例如：寂寞的真相、被遺忘的承諾..." style="font-size: 1.1rem;">
            
            <button id="submitWritingGuideBtn" class="btn-action" onclick="submitWritingGuide()">提交分析</button>

            <!-- 結果顯示區 -->
            <div id="writingGuideResultContainer" style="display: none; margin-top: 25px;">
                
                <!-- 第一部分：關鍵詞張力分析 -->
                <div class="guide-section-header" style="border-left: 5px solid #4A90E2; color: #4A90E2;">
                    <h3><i class="fas fa-search"></i> 關鍵詞張力分析</h3>
                </div>
                <!-- 總體分析 (比喻與關係) -->
                <div id="guideIntro" class="guide-intro-card"></div>
                <!-- 三種心情 (三欄佈局) -->
                <div id="guideEmotions" class="guide-grid-3"></div>

                <!-- 第二部分：寫作方向建議 -->
                <div class="guide-section-header" style="border-left: 5px solid #28a745; color: #28a745; margin-top: 30px;">
                    <h3><i class="fas fa-compass"></i> 記敘文寫作方向建議</h3>
                </div>
                <!-- 三個故事種子 (三欄佈局) -->
                <div id="guideSeeds" class="guide-grid-3"></div>

                <!-- 儲存按鈕 -->
                <div class="result-wrapper">
                    <button id="save-guide-html-btn" class="btn-save-html" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-敘事抒情-解題指引.html')" style="display: flex;">
                        <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                    </button>
                </div>
            </div>
        </div>
        <!-- === 新增結束 === -->

        <div id="outlineStructureArea" style="display: none;">
            <label for="structure">選擇大綱結構：</label>
            <select id="structure" onchange="generateOutlineTable()">
                <option value="fourPart">起承轉合</option>
                <option value="threeLine">三線</option>
            </select>
        </div>
        
        <!-- ... 舊有代碼保持不變 ... -->
        <div id="topicSelectionArea">
            <label>選擇題目方式：</label>
            <div class="topic-buttons-container">
                <button class="btn btn-generate" onclick="generateTopic(this)">
                    <i class="fas fa-sync-alt"></i> 生成
                </button>
                <button class="btn btn-custom" onclick="showCustomTopicInput(this)">
                    <i class="fas fa-edit"></i> 自訂
                </button>
            </div>
            <div id="customTopicArea" style="display: none; margin-top: 15px;"></div>
        </div>

        <div id="topicResult"></div>
        <div id="narrativeElementsArea" style="display: none;">
            <label for="narrativeElements">請輸入您的取材或故事背景：</label>
            <textarea id="narrativeElements" rows="5" placeholder="例如：故事背景、人物設定、取材等..."></textarea>
        </div>
        
        <div id="writingArea">
            <div id="outlineTableArea"></div>
            <div id="outlineButtons" style="display: none;" class="action-buttons-container">
                <button class="btn-icon-action btn-save-icon" onclick="saveOutline()" title="儲存大綱">
                    <i class="fas fa-save"></i>
                </button>
                <button class="btn-icon-action btn-clear-icon" onclick="clearOutline()" title="清空大綱">
                    <i class="fas fa-trash-alt"></i>
                </button>
            </div>
            <textarea id="writingContent" rows="10" placeholder="請在此輸入您的文章..." style="display: none;"></textarea>
            
            <label for="writingTone" id="writingToneLabel" class="tone-selector-label" style="display: none;">選擇點評語氣：</label>
            <select id="writingTone" style="display: none;">
                <option value="serious">嚴肅正經</option>
                <option value="chen">陳SIR語氣</option>
            </select>

            <label for="writingReviewer" id="writingReviewerLabel" class="tone-selector-label" style="display: none;">選擇閱卷員：</label>
            <select id="writingReviewer" style="display: none;">
                <option value="chen_sir" selected>陳Sir</option>
                <option value="ms_chan">Ms Chan</option>
                <option value="huang_laoshi">黃老師</option>
                <option value="deng_laoshi">鄧老師</option>
                <option value="xiao_laoshi">蕭老師</option>
                <option value="dong_laoshi">董老師</option>
                <option value="li_laoshi">李老師</option>
                <option value="zhen_laoshi">甄老師</option>
                <option value="wen_laoshi">溫老師</option>
                <option value="jiang_laoshi">江老師</option>
            </select>

            <div id="reviewScopeArea" style="display: none; margin-top: 25px;">
                <label class="tone-selector-label">選擇點評範疇：</label>
                <div class="scope-selector-container">
                    <label class="scope-label all-scope"><input type="checkbox" name="reviewScope" value="全部" checked> 全部</label>
                    <label class="scope-label"><input type="checkbox" name="reviewScope" value="扣題"> 扣題</label>
                    <label class="scope-label"><input type="checkbox" name="reviewScope" value="立意"> 立意</label>
                    <label class="scope-label"><input type="checkbox" name="reviewScope" value="取材"> 取材</label>
                    <label class="scope-label"><input type="checkbox" name="reviewScope" value="詳略"> 詳略</label>
                    <label class="scope-label"><input type="checkbox" name="reviewScope" value="文筆"> 文筆</label>
                </div>
            </div>

            <button id="submitWritingBtn" class="btn-action" onclick="submitWriting()">提交</button>
            
            <div id="writingReviewResultContainer">
                <div id="writingGradingResult"></div>
                <div id="writingChatHistory" style="display: none;"></div>
                <div id="writingChatInputContainer" style="display: none;">
                    <textarea id="writingUserInput" class="no-modal-editor" rows="2" placeholder="可就以上點評追問..."></textarea>
                    <button id="continueWritingBtn" class="btn-icon-action" onclick="continueWritingDiscussion()" title="繼續討論" style="background-color: #2d9966;">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
            
            <div class="result-wrapper" style="position: relative;">
                <div id="commentResult"></div>
                <button id="save-writing-html-btn" class="btn-save-html" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-敘事抒情.html')">
                    <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                </button>
            </div>
        </div>
    </div>
</div>



<!-- 閱讀容器 -->
<div id="readingContainer" class="box" style="display: none;">
<h2>閱讀</h2>
<div style="position:relative; width:100%; height:0px; padding-bottom:62.222%"><iframe allow="fullscreen" allowfullscreen height="100%" src="https://streamable.com/e/vt3i1j?loop=0" width="100%" style="border:none; width:100%; height:100%; position:absolute; left:0px; top:0px; bottom:2px; overflow:hidden;" referrerpolicy="no-referrer-when-downgrade" credentialless></iframe></div>

<div class="function-selector-wrapper">
<label for="readingFunction">選擇功能：</label>
<select id="readingFunction" onchange="toggleReadingFunction()">
<option value="" selected disabled>請在此選擇功能</option>
<option value="comment">點評</option>
<option value="guide">指引</option>
<option value="training">訓練</option>  <!-- 新增此行 -->
</select>
</div>

<div id="readingInputArea" style="display: none;">
<label for="readingPassage">貼上閱讀篇章：</label>
<textarea id="readingPassage" rows="10" placeholder="請在此貼上閱讀篇章..."></textarea>
<label for="readingQuestion">貼上題目：</label>
<textarea id="readingQuestion" rows="3" placeholder="請在此貼上題目..."></textarea>
<div id="studentAnswerArea" style="display: none;">
<label for="studentAnswer">貼上答案：</label>
<textarea id="studentAnswer" rows="5" placeholder="請在此貼上答案..."></textarea>
</div>
<label for="readingTone" id="readingToneLabel" class="tone-selector-label" style="display: none;">選擇點評語氣：</label>
<select id="readingTone" style="display: none;">
<option value="serious">嚴肅正經</option>
<option value="chen">陳SIR語氣</option>
</select>
<!-- 將 <button onclick="submitReading()"> 改為： -->
<button id="submitReadingBtn" class="btn-action" onclick="submitReading()">提交</button>
<div class="result-wrapper" style="position: relative;">
	<div id="readingResult"></div>
	<button id="save-reading-html-btn" class="btn-save-html" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-閱讀理解.html')">
		<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
	</button>
</div>
</div>
</div>

<!-- 課外書籍容器 -->
<div id="booksContainer" class="box" style="display: none;">
<h2>課外書籍討論</h2>
<div style="position:relative; width:100%; height:0px; padding-bottom:62.222%"><iframe allow="fullscreen" allowfullscreen height="100%" src="https://streamable.com/e/4eznsi?loop=0" width="100%" style="border:none; width:100%; height:100%; position:absolute; left:0px; top:0px; bottom:2px; overflow:hidden;" referrerpolicy="no-referrer-when-downgrade" credentialless></iframe></div>

<!-- 初始輸入表單 -->
<div id="initialDiscussionForm">
<p>請在下方填寫書名、作者和討論問題，開始與陳SIR對話：</p>
<input type="text" id="bookTitle" class="no-modal-editor" placeholder="書名">
<input type="text" id="author" class="no-modal-editor" placeholder="作者">
<textarea id="discussionQuestion" class="no-modal-editor" rows="3" placeholder="討論問題"></textarea>
<label for="booksTone">選擇語氣：</label>
<select id="booksTone">
<option value="serious">嚴肅正經</option>
<option value="casual">輕鬆活潑</option>
</select>
<div id="discussionControlButtons">
<button id="startDiscussionBtn" class="btn-action" onclick="startDiscussion()">開始討論</button>
</div>
</div>

<!-- 聊天歷史紀錄 -->
<div class="result-wrapper" style="position: relative;">
	<div id="chatHistory"></div>
	
</div>


<!-- 聊天輸入介面 (已移除新增按鈕) -->
<div id="chatInputContainer">
<textarea id="userInput" class="no-modal-editor" rows="2" placeholder="請在此輸入您的回應..."></textarea>
<button id="continueBtn" class="btn-icon-action" onclick="continueDiscussion()" title="繼續討論" style="background-color: #2d9966;">
<i class="fas fa-paper-plane"></i>
</button>
</div>

<!-- 儲存/清除按鈕 (已加入新增按鈕) -->
<div id="booksButtons" class="action-buttons-container">
    <button id="save-books-html-btn" class="btn-icon-action" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-課外書討論.html')">
        <i class="fas fa-download"></i>
    </button>
	
<!-- 「新增討論」按鈕已移到此處，位於儲存按鈕左方 -->
<button id="newTopicBtn" class="btn-icon-action btn-add-icon" title="新增討論主題">
<i class="fas fa-plus"></i>
</button>
<button class="btn-icon-action btn-save-icon" onclick="saveBooksChat()" title="儲存對話">
<i class="fas fa-save"></i>
</button>
<button class="btn-icon-action btn-clear-icon" onclick="clearBooksChat()" title="清空對話">
<i class="fas fa-trash-alt"></i>
</button>
</div>
</div>

<!-- 新增討論的彈出視窗 -->
<div id="newTopicModal" class="books-modal">
<div class="modal-content">
<span class="close-modal-btn" id="closeNewTopicModal">&times;</span>
<h3>新增討論</h3>
<input type="text" id="modalBookTitle" class="no-modal-editor" placeholder="書名">
<input type="text" id="modalAuthor" class="no-modal-editor" placeholder="作者">
<textarea id="modalDiscussionQuestion" class="no-modal-editor" rows="3" placeholder="討論問題"></textarea>
<div style="text-align: right; margin-top:15px;">
<button id="modalStartDiscussionBtn" class="btn-icon-confirm" title="開始新討論">
<i class="fas fa-check"></i>
</button>
</div>
</div>
</div>


<!-- 整合拓展容器 -->
<div id="expandContainer" class="box" style="display: none;">
<h2>整合拓展</h2>
<div style="position:relative; width:100%; height:0px; padding-bottom:62.222%"><iframe allow="fullscreen" allowfullscreen height="100%" src="https://streamable.com/e/2otwxv?loop=0" width="100%" style="border:none; width:100%; height:100%; position:absolute; left:0px; top:0px; bottom:2px; overflow:hidden;" referrerpolicy="no-referrer-when-downgrade" credentialless></iframe></div>

<div class="function-selector-wrapper">
<label for="expandFunction">選擇功能：</label>
<select id="expandFunction" onchange="toggleExpandFunction()">
<option value="" selected disabled>請在此選擇功能</option>
<option value="comment">點評</option>
<option value="guide">指引</option>
</select>
</div>

<div id="expandContentContainer" style="display: none;">

<div id="expandTopicSelectionArea" style="display: none;">
<label>選擇題目方式：</label>
<div class="topic-buttons-container">
<!-- 套用新的 class: btn-generate -->
<button class="btn btn-generate" onclick="generateExpandTopic(this)">
<i class="fas fa-sync-alt"></i> 生成
</button>
<!-- 套用新的 class: btn-custom -->
<button class="btn btn-custom" onclick="showExpandCustomTopicInput(this)">
<i class="fas fa-edit"></i> 自訂
</button>
</div>
<!-- 這個 div 用來動態顯示自訂題目的輸入框 -->
<div id="expandCustomTopicInputArea" style="display: none; margin-top: 15px;">
</div>
</div>
<div id="expandTopicResult"></div>

<div id="expandWritingArea" style="display: none;">
<label for="expandContent">整合拓展（最多180字）：</label>
<textarea id="expandContent" rows="5" placeholder="請在此輸入整合拓展內容..." oninput="updateCharCount()"></textarea>
<p id="charCount">剩餘字數：180</p>
<label for="expandTone" id="expandToneLabel" class="tone-selector-label" style="display: none;">選擇點評語氣：</label>
<select id="expandTone" style="display: none;">
<option value="serious">嚴肅正經</option>
<option value="chen">陳SIR語氣</option>
</select>
<!-- 將 <button onclick="submitExpand()"> 改為： -->
<button id="submitExpandBtn" class="btn-action" onclick="submitExpand()">提交</button>
<div class="result-wrapper" style="position: relative;">
	<div id="expandCommentResult"></div>
	<button id="save-expand-comment-html-btn" class="btn-save-html" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-整合拓展-點評.html')">
		<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
	</button>
</div>
</div>

<div id="expandGuideArea" style="display: none;">
<table>
<tr><th>題目</th><td><input type="text" id="expandGuideTitle" placeholder="請輸入題目"></td></tr>
<tr><th>主題句</th><td><textarea id="expandGuideTheme" rows="2" placeholder="請輸入主題句"></textarea></td></tr>
<tr><th>抄錄資料</th><td><textarea id="expandGuideData" rows="3" placeholder="請輸入抄錄資料"></textarea></td></tr>
<tr><th>整合拓展</th><td><textarea id="expandGuideExpand" rows="3" placeholder="請輸入整合拓展"></textarea></td></tr>
</table>
<!-- 【修訂處】為按鈕添加 ID -->
<button id="submitExpandGuideBtn" class="btn-action" onclick="submitExpand()">提交</button>
<div style="position: relative;">
	<div id="expandGuideResult"></div>
	<button id="save-expand-guide-html-btn" class="btn-save-html" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-整合拓展-指引.html')">
		<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
	</button>
</div>
</div></div>
</div>

<!-- 議論容器 -->
<div id="argumentContainer" class="box" style="display: none;">
<h2>議論</h2>
<div style="position:relative; width:100%; height:0px; padding-bottom:62.222%"><iframe allow="fullscreen" allowfullscreen height="100%" src="https://streamable.com/e/0ki8mx?loop=0" width="100%" style="border:none; width:100%; height:100%; position:absolute; left:0px; top:0px; bottom:2px; overflow:hidden;" referrerpolicy="no-referrer-when-downgrade" credentialless></iframe></div>

<div class="function-selector-wrapper">
<label for="argumentType">選擇功能：</label>
<select id="argumentType" onchange="toggleArgumentType()">
<option value="" selected disabled>請在此選擇功能</option>
<option value="outline">大綱點評</option>
<option value="writing">文章點評</option>
<option value="guide">指引</option>
</select>
</div>

<div id="argumentContentContainer" style="display: none;">
<div id="argumentTopicSelectionArea">
<label>選擇題目方式：</label>
<div class="topic-buttons-container">
<!-- 套用新的 class: btn-generate -->
<button class="btn btn-generate" onclick="generateArgumentTopic(this)">
<i class="fas fa-sync-alt"></i> 生成
</button>
<!-- 套用新的 class: btn-custom -->
<button class="btn btn-custom" onclick="showArgumentCustomTopicInput(this)">
<i class="fas fa-edit"></i> 自訂
</button>
</div>
<div id="argumentCustomTopicArea" style="display: none; margin-top: 15px;">
<!-- 內容將由 JavaScript 動態生成 -->
</div>
</div>
<div id="argumentTopicResult"></div>
<div id="argumentOutlineArea" style="display: none;">

<div id="argumentOutlineTableArea"></div>

<!-- 按鈕容器現在包含了新增、儲存和清除按鈕 -->
<div id="argumentOutlineButtons" class="action-buttons-container">
<button class="btn-icon-action btn-add-icon" onclick="addArgumentStructureSegment()" title="新增結構段">
<i class="fas fa-plus"></i>
</button>
<button class="btn-icon-action btn-save-icon" onclick="saveArgumentOutline()" title="儲存大綱">
<i class="fas fa-save"></i>
</button>
<button class="btn-icon-action btn-clear-icon" onclick="clearArgumentOutline()" title="清空大綱">
<i class="fas fa-trash-alt"></i>
</button>
</div>

<label for="argumentOutlineTone" class="tone-selector-label">選擇點評語氣：</label>
<select id="argumentOutlineTone">
<option value="serious">嚴肅正經</option>
<option value="chen">陳SIR語氣</option>
</select>
<button id="submitArgumentOutlineBtn" class="btn-action" onclick="submitArgumentOutline()">提交</button>
<div class="result-wrapper" style="position: relative;">
	<div id="argumentOutlineResult"></div>
	<button id="save-argument-outline-html-btn" class="btn-save-html" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-議論-大綱點評.html')">
		<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
	</button>
</div>
</div>
<div id="argumentWritingArea" style="display: none;">
<textarea id="argumentWritingContent" rows="10" placeholder="請在此輸入您的文章..."></textarea>
<label for="argumentWritingTone" class="tone-selector-label">選擇點評語氣：</label>
<select id="argumentWritingTone">
        <option value="serious">嚴肅正經</option>
        <option value="chen">陳SIR語氣</option>
    </select>

    <!-- ======= 請在這裡加入以下程式碼 ======= -->
    <label for="argumentReviewer" class="tone-selector-label">選擇閱卷員：</label>
    <select id="argumentReviewer">
      <option value="chen_sir" selected>陳Sir</option>
      <option value="ms_chan">Ms Chan</option>
      <option value="huang_laoshi">黃老師</option>
      <option value="deng_laoshi">鄧老師</option>
      <option value="xiao_laoshi">蕭老師</option>
      <option value="dong_laoshi">董老師</option>
      <option value="li_laoshi">李老師</option>
      <option value="zhen_laoshi">甄老師</option>
      <option value="wen_laoshi">溫老師</option>
      <option value="jiang_laoshi">江老師</option>
    </select>
    <!-- ======= 加入結束 ======= -->

<!-- ======= 請在這裡加入【議論文點評範疇】HTML 程式碼 ======= -->
<div id="argumentReviewScopeArea" style="display: none; margin-top: 25px;">
    <label class="tone-selector-label">選擇點評範疇：</label>
    <div class="scope-selector-container">
        <label class="scope-label all-scope"><input type="checkbox" name="argumentReviewScope" value="全部" checked> 全部</label>
        <label class="scope-label"><input type="checkbox" name="argumentReviewScope" value="謀篇"> 謀篇</label>
        <label class="scope-label"><input type="checkbox" name="argumentReviewScope" value="論點"> 論點</label>
        <label class="scope-label"><input type="checkbox" name="argumentReviewScope" value="論據"> 論據</label>
        <label class="scope-label"><input type="checkbox" name="argumentReviewScope" value="論證"> 論證</label>
        <label class="scope-label"><input type="checkbox" name="argumentReviewScope" value="文筆"> 文筆</label>
    </div>
</div>
<!-- ======= 加入結束 ======= -->

  <button id="submitArgumentWritingBtn" class="btn-action" onclick="submitArgumentWriting()">提交</button>

    <!-- 正確的結構：用 result-wrapper 包裹住所有結果和聊天介面 -->
    <div class="result-wrapper">
        
        <!-- 評分卡、文字點評和聊天介面都將被動態放入這個容器中 -->
        <div id="argumentReviewResultContainer">
            <!-- 評分系統或聚焦式點評將會被動態插入到這裡 -->
            <div id="argumentGradingResult"></div>

            <!-- 聊天歷史紀錄 -->
            <div id="argumentChatHistory" style="display: none;"></div>

            <!-- 聊天輸入介面 -->
            <div id="argumentChatInputContainer" style="display: none;">
                <textarea id="argumentUserInput" class="no-modal-editor" rows="2" placeholder="可就以上點評追問..."></textarea>
                <button id="continueArgumentBtn" class="btn-icon-action" onclick="continueArgumentDiscussion()" title="繼續討論" style="background-color: #2d9966;">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>

        <!-- 儲存按鈕現在位於正確的包裹層內 -->
        <button id="save-argument-writing-html-btn" class="btn-save-html" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-議論-文章點評.html')">
            <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
        </button>
    </div>
</div>
<div id="argumentGuideArea" style="display: none;">
<label for="argumentGuideTopic">題目：</label>
<input type="text" id="argumentGuideTopic" placeholder="請輸入題目">
<label for="argumentGuidePoint">論點（可選）：</label>
<textarea id="argumentGuidePoint" rows="3" placeholder="請輸入論點"></textarea>
<label for="argumentGuideEvidence">論據（可選）：</label>
<textarea id="argumentGuideEvidence" rows="3" placeholder="請輸入論據"></textarea>
<label for="argumentGuideArgument">論證（可選）：</label>
<textarea id="argumentGuideArgument" rows="3" placeholder="請輸入論證"></textarea>
<button id="submitArgumentGuideBtn" class="btn-action" onclick="submitArgumentGuide()">提交</button>
<div class="result-wrapper" style="position: relative;">
	<div id="argumentGuideResult"></div>
	<button id="save-argument-guide-html-btn" class="btn-save-html" title="儲存為HTML檔案" onclick="savePageAsHTML('神思-議論-指引.html')">
		<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
	</button>
</div>
</div>
</div>
</div>

<!-- 音樂播放器 HTML -->
<div id="music-player">
<div class="controls">
<select id="music-select">
<option value="">選擇音樂</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/Battle-Abysswalker.mp3">The Abysswalker</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/Battle-Rosemoon.mp3">死せる都の戰乙女</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/Battle-deadly.mp3">五大罪</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/Battle-rapier.mp3">繼承劍的少女</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/Ariadne-Battle.mp3">不屈意志之刃</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/battle-arms.mp3">西部戰鬥</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/Battle.mp3">Battle Theme</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/Wanderers-City.mp3">流浪城鎮</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/Remotest-Liblary.mp3">沉睡的記憶</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/Nostalgia.mp3">麥田懷舊</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/sunbeams.mp3">放學後</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/village.mp3">鄉村生活</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/Take-a-Rest.mp3">休息一下</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/winter-snow.mp3">雪鄉</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/Forgotten-Place.mp3">被遺忘的地方</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/Rest-in-Peace.mp3">安息</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/Farewell.mp3">告別</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/reminiscence.mp3">回憶</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/starry-night.mp3">星夜</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/last-wish.mp3">當思念傳到某人耳畔</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/sorrow.mp3">超越悲傷</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/hotarumichi.mp3">螢火蟲之路</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/Sky-Airship.mp3">飛艇</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/Voyage_SE.mp3">跨越神秘之海</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/main-theme01.mp3">盼望</option>
<option value="https://youfulca.com/wp-content/uploads/2022/08/saikai637.mp3">約定之地</option>
</select>
<button id="play-pause"▶️</button>
</div>
<div class="progress">
<input type="range" id="progress-bar-music" value="0" min="0" max="100">
</div>
<div class="mode">
<select id="play-mode">
<option value="loop" selected>單曲循環</option>
<option value="next">自動播放下首</option>
</select>
</div>
<button class="hide-btn" id="hide-player">🔽</button>
</div>
<button id="show-player">🎹</button>
<audio id="audio" preload="auto"></audio>

<!-- 展開工具二 (語薈) 容器 -->
<div id="toolsContainer2">
<button id="closeToolsBtn2">&times;</button>
<div class="main-container">
<!-- Floating Title -->
<!-- Floating Title -->
<header class="floating-header">
<h1>語薈</h1>
<button id="video-tour-btn" title="觀看介紹影片">
<svg class="icon" viewBox="0 0 24 24"><use xlink:href="#icon-video"></use></svg>
</button>
</header>

<!-- Embedded SVG Icons -->
<svg width="0" height="0" style="position:absolute">
<defs>
<symbol id="icon-brain" viewBox="0 0 24 24"><path d="M7.445 11.232C7.445 10.537 7.98 9.96 8.629 9.96H9.02V8.203H7.818C6.983 8.203 6.3 8.91 6.3 9.778V11.23H5.161C4.326 11.23 3.644 11.938 3.644 12.806V14.17H2.82C2.17 14.17 1.636 14.746 1.636 15.44V17.65H1.523C.688 17.65 0 18.358 0 19.226V20.48C0 21.35 0.688 22.056 1.523 22.056H6.738C6.738 23.13 7.573 24 8.628 24H15.37C16.425 24 17.26 23.13 17.26 22.058H22.477C23.312 22.058 24 21.35 24 20.48V19.225C24 18.357 23.312 17.65 22.477 17.65H22.364V15.44C22.364 14.745 21.83 14.17 21.18 14.17H20.356V12.805C20.356 11.937 19.674 11.23 18.839 11.23H17.68V9.777C17.68 8.908 17.017 8.2 16.182 8.2H14.98V9.96H15.37C16.02 9.96 16.555 10.536 16.555 11.23V12.986H15.37V15.92H8.629V12.986H7.445V11.232M11.1 11.23H12.9V14.17H11.1V11.23M12 1.947C10.13 1.947 8.58 2.894 7.854 4.316C7.65 3.52 7.2 2.813 6.545 2.27C5.124 1.053 2.95 1.54 1.987 3.16C0.945 4.925 1.489 7.346 3.09 8.528C3.21 8.62 3.33 8.71 3.464 8.78C3.464 7.024 4.818 5.618 6.52 5.618C8.22 5.618 9.573 7.024 9.573 8.78V9.1H14.4V8.78C14.4 7.024 15.78 5.618 17.48 5.618C19.18 5.618 20.536 7.024 20.536 8.78C20.662 8.71 20.782 8.62 20.91 8.528C22.51 7.346 23.055 4.925 22.013 3.16C21.05 1.54 18.876 1.053 17.455 2.27C16.8 2.813 16.35 3.52 16.145 4.316C15.42 2.894 13.87 1.947 12 1.947Z"/></symbol>
<symbol id="icon-write" viewBox="0 0 24 24"><path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.13,5.12L18.88,8.87M3,17.25V21H6.75L17.81,9.94L14.06,6.19L3,17.25Z" /></symbol>
<symbol id="icon-read" viewBox="0 0 24 24"><path d="M18.5,1.15C19.9,1.15 21.15,2.4 21.15,3.85V15.85C21.15,17.3 19.9,18.55 18.5,18.55H5.5C4.1,18.55 2.85,17.3 2.85,15.85V3.85C2.85,2.4 4.1,1.15 5.5,1.15H18.5M18.5,22.85H5.5C2.45,22.85 0,20.4 0,17.35V2.35C0,1.4 0.35,0.6 0.95,0.1C1.25,-0.1 1.7,-0.05 2,0.25L3.1,1.35C3.3,1.55 3.3,1.85 3.1,2.05L2.05,3.1C1.85,3.3 1.55,3.3 1.35,3.1L0.7,2.45C0.7,5.55 2.85,7.85 5.5,7.85H18.5C21.15,7.85 23.3,5.55 23.3,2.45L22.6,3.1C22.4,3.3 22.1,3.3 21.9,3.1L20.85,2.05C20.65,1.85 20.65,1.55 20.85,1.35L21.95,0.25C22.25,-0.05 22.7,-0.1 23,0.1C23.6,0.6 24,1.4 24,2.35V17.35C24,20.4 21.5,22.85 18.5,22.85Z" /></symbol>
<symbol id="icon-work" viewBox="0 0 24 24"><path d="M14,6V4H10V6H14M18,9H15V6H9V9H6A2,2 0 0,0 4,11V19A2,2 0 0,0 6,21H18A2,2 0 0,0 20,19V11A2,2 0 0,0 18,9Z" /></symbol>
<symbol id="icon-support" viewBox="0 0 24 24"><path d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z" /></symbol>
<symbol id="icon-foundation" viewBox="0 0 24 24"><path d="M12 2L2 7V17L12 22L22 17V7L12 2ZM19.6 8.25L12 12.5L4.4 8.25L12 4L19.6 8.25Z"/></symbol>
<symbol id="icon-explore" viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A1.5,1.5 0 0,1 13.5,5.5A1.5,1.5 0 0,1 12,7A1.5,1.5 0 0,1 10.5,5.5A1.5,1.5 0 0,1 12,4M12,18.2C9.5,18.2 7.29,16.42 6.5,14H17.5C16.71,16.42 14.5,18.2 12,18.2Z"/></symbol>
<symbol id="icon-video" viewBox="0 0 24 24"><path d="M17,10.5V7A1,1 0 0,0 16,6H4A1,1 0 0,0 3,7V17A1,1 0 0,0 4,18H16A1,1 0 0,0 17,17V13.5L21,17.5V6.5L17,10.5Z" /></symbol>
</defs>
</svg>

<!-- Mind Map Layout -->
<main class="mind-map-container" id="mind-map">
<svg class="connector-svg" id="connector-svg"></svg>

<!-- 1. Core AI -->
<div class="category" id="core-ai" data-connect-to="">
<div class="node" data-id="core-ai-node" style="padding: 10px 20px;">
<a href="https://kenchan20141.github.io/AIChinese/" data-tool-id="sansi">






<svg class="icon" style="width:32px; height:32px;"><use xlink:href="#icon-brain"></use></svg>
神思
</a>
</div>
<div class="sub-group" style="flex-direction: row; gap: 10px;">
<div class="node level-3"><a href="https://kenchan20141.github.io/AIChinese2/" data-tool-id="sansi-backup">神思 (備用)</a></div>
<div class="node level-3"><a href="https://sansi.vercel.app/" data-tool-id="sansi-v3">神思 (V3)</a></div>
</div>
</div>

<!-- Foundations tier -->
<div id="foundations" data-connect-to="core-ai-node">
<div class="foundation-item" data-id="foundation-tizi">
<div class="category-title"><svg class="icon"><use xlink:href="#icon-foundation"></use></svg>應試</div>
<div class="sub-group-title">AI擬題</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/generator/" data-tool-id="tizi">題孳<br></a></div>
</div>
<div class="foundation-item" data-id="foundation-explore">
<div class="category-title"><svg class="icon"><use xlink:href="#icon-explore"></use></svg>課外探索</div>
<div class="sub-group-title">課外篇章</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/reading/" data-tool-id="reading-pieces">文學・片段</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/mensyu/" data-tool-id="mensyu">文樞</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/slowreading/" data-tool-id="slowreading">慢讀</a></div>
<div class="sub-group-title">主題探討</div>
<div class="node level-2"><a href="https://litstudy.vercel.app/" data-tool-id="study">文學專題探究</a></div>

<div class="sub-group-title">生活詩意</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/wabisabi/" data-tool-id="wabisabi">一瞬之詩</a></div>
<div class="sub-group-title">書籍推薦</div>
<div class="node level-2"><a href="https://621d05f47d591.site123.me/%E6%9B%B8%E9%96%A3%E8%97%8F%E6%9B%B8%E6%A6%82%E8%A6%BD" data-tool-id="book-overview">書籍概覽</a></div>
	<div class="sub-group-title">歌詞遊戲</div>
<div class="node level-2"><a href="https://lyricschi.vercel.app/" data-tool-id="lyrics">詞海拾心</a></div>
</div>
</div>

<!-- 2. Writing -->
<div class="category" id="writing" data-connect-to="foundation-tizi">
<div class="category-title"><svg class="icon"><use xlink:href="#icon-write"></use></svg>寫作創作</div>
<div class="sub-group">
<div class="sub-group-title">AI範文</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/article/" data-tool-id="fanshui-narrative">翻水 (敘事)</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/essay/" data-tool-id="fanshui-argument">翻水 (議論)</a></div>
</div>
<div class="sub-group">
<div class="sub-group-title">草擬</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/manuscriptpaper/" data-tool-id="manuscript">智能原稿紙</a></div>
</div>
<div class="sub-group">
<div class="sub-group-title">潤色與延伸</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/words/" data-tool-id="words">字斟・句酌</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/slideshow/" data-tool-id="slideshow">文章幻燈片</a></div>
</div>
</div>

<!-- 3. Reading -->
<div class="category" id="reading" data-connect-to="foundation-tizi">
<div class="category-title"><svg class="icon"><use xlink:href="#icon-read"></use></svg>閱讀溫習</div>
<div class="sub-group">
<div class="sub-group-title">課文溫習</div>
<div class="node level-2" id="yuyilu-toggle"><a href="#">語弈錄 </a></div>






<div class="yuyilu-grades collapsed" id="yuyilu-grades">
<div class="node level-3"><a href="https://kenchan20141.github.io/f1chinese/" data-tool-id="yuyilu-f1">中一</a> | <a href="https://kenchan20141.github.io/chinese2/" data-tool-id="yuyilu-f2">中二</a> | <a href="https://kenchan20141.github.io/chinese3/" data-tool-id="yuyilu-f3">中三</a></div>
<div class="node level-3"><a href="https://kenchan20141.github.io/f4chinese/" data-tool-id="yuyilu-f4">中四</a> | <a href="https://kenchan20141.github.io/chinese/" data-tool-id="yuyilu-f5">中五</a> | <a href="https://kenchan20141.github.io/chinese6/" data-tool-id="yuyilu-f6">中六</a></div>
</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/timer/" data-tool-id="timer">背書神器</a></div>
</div>
<div class="sub-group">
<div class="sub-group-title">文言文</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/wabisabi/mensyu/" data-tool-id="mensyu-2">文樞</a></div>
</div>
</div>

<!-- 4. Assignments -->
<div class="category" id="assignments" data-connect-to="core-ai-node">
<div class="category-title"><svg class="icon"><use xlink:href="#icon-work"></use></svg>工具</div>
<div class="sub-group">
<div class="sub-group-title">課業流程</div>
<div class="node level-2"><a href="https://script.google.com/a/macros/ccckyc.edu.hk/s/AKfycby1T18HxuFICIaR0LYWRuaqlpmglkL191bVl39MH69zj5CQ-uhozF17edtJ_T54NhZ5/exec" data-tool-id="zhiyun">帙雲</a></div>
</div>
<div class="sub-group">
<div class="sub-group-title">實用工具</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/WCT/" data-tool-id="zhuoyu">琢玉</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/quizbuzzer/" data-tool-id="quizbuzzer">搶答器</a></div>
	<div class="node level-2"><a href="https://kenchan20141.github.io/pulseqa/" data-tool-id="pulseqa">脈問堂</a></div>
<div class="node level-2"><a href="https://www.i2ocr.com/free-online-chinese-traditional-ocr" data-tool-id="ocr">手寫文字轉換 (OCR)</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/epub/" data-tool-id="epub">電子書閱讀器</a></div>
	<div class="node level-2"><a href="https://kenchan20141.github.io/decibelmeter/" data-tool-id="decibelmeter">分貝計</a></div>
	<div class="node level-2"><a href="https://penpalchi.vercel.app/" data-tool-id="friends">以文會友</a></div>
</div>
</div>

<!-- 5. Support -->
<div class="category" id="support" data-connect-to="core-ai-node">
<div class="category-title"><svg class="icon"><use xlink:href="#icon-support"></use></svg>學習支援</div>
<div class="sub-group">
<div class="sub-group-title">AI聊天室</div>
<div class="node level-2"><a href="https://kenchan20141.github.io/chitutor/" data-tool-id="chitutor">喻蛋教室</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/histutor/" data-tool-id="histutor">史萊姆教室</a></div>
<div class="node level-2"><a href="https://kenchan20141.github.io/counseling/" data-tool-id="counseling">解憂雜貨店</a></div>
</div>
<div class="sub-group">
<div class="sub-group-title">資源庫</div>
<div class="node level-2"><a href="https://621d05f47d591.site123.me/" data-tool-id="self-learning">自學資源</a></div>
</div>
</div>
</main>
</div>
</div>

<!-- Preview Modal (修訂後) -->
<div id="previewModal" class="preview-modal-overlay">
<div class="preview-modal-content">
<div class="preview-modal-body">
<iframe id="previewIframe" src="" frameborder="0" credentialless></iframe>
<div class="preview-modal-footer">
<div id="previewDescription" class="preview-description"></div>
<a id="previewGoToPageBtn" href="" target="_blank" class="preview-goto-btn">前往</a>
</div>
</div>
<button id="previewCloseBtn" class="preview-close-btn" title="關閉">&times;</button>
</div>
</div>


<!-- Video Modal (新增) -->
<div id="videoModal" class="video-modal-overlay">
<div class="video-modal-content">
<iframe id="videoIframe" allow="fullscreen" allowfullscreen src="" width="100%" style="border:none;" credentialless></iframe>
</div>
</div>

<script>

// --- 【全新修訂】儲存頁面為 HTML 的功能 (已整合雷達圖轉換) ---
function savePageAsHTML(filename = '神思-存檔.html') {
    // 1. 建立當前文檔的深度複製品，我們將在這個複製品上操作
    const clonedDocElement = document.documentElement.cloneNode(true);

    // --- 【核心新增邏輯：處理雷達圖】 ---
    // a. 找出當前頁面上所有可見的雷達圖畫布 (canvas)
    const visibleCanvases = document.querySelectorAll('.radar-chart-container canvas');
    
    visibleCanvases.forEach(originalCanvas => {
        // b. 檢查畫布是否真的可見，避免處理隱藏的圖表
        if (originalCanvas.offsetParent !== null) {
            try {
                // c. 將畫布內容轉換為 Base64 格式的圖片數據 (PNG)
                const imageDataUrl = originalCanvas.toDataURL('image/png');
                
                // d. 在 "複製品" 中找到對應的畫布
                const clonedCanvas = clonedDocElement.querySelector(`#${originalCanvas.id}`);
                
                if (clonedCanvas) {
                    // e. 建立一個新的 <img> 元素
                    const img = document.createElement('img');
                    img.src = imageDataUrl; // 將圖片數據設置為來源
                    img.style.width = '100%'; // 保持與原畫布容器寬度一致
                    img.style.height = 'auto'; // 高度自動調整
                    
                    // f. 在複製品中，用這張靜態圖片 <img> 取代原本的 <canvas>
                    clonedCanvas.parentNode.replaceChild(img, clonedCanvas);
                }
            } catch (e) {
                console.error('轉換雷達圖為圖片時發生錯誤:', e);
            }
        }
    });
    // --- 【雷達圖處理邏輯結束】 ---

    // 2. 在複製品上同步所有表單元素的當前狀態 (此部分邏輯不變)
    const originalTextareas = document.getElementsByTagName('textarea');
    const clonedTextareas = clonedDocElement.getElementsByTagName('textarea');
    for (let i = 0; i < originalTextareas.length; i++) {
        clonedTextareas[i].textContent = originalTextareas[i].value;
    }

    const originalInputs = document.querySelectorAll('input');
    const clonedInputs = clonedDocElement.querySelectorAll('input');
    for (let i = 0; i < originalInputs.length; i++) {
        clonedInputs[i].setAttribute('value', originalInputs[i].value);
        if (originalInputs[i].type === 'radio' || originalInputs[i].type === 'checkbox') {
             if (originalInputs[i].checked) {
                clonedInputs[i].setAttribute('checked', 'checked');
            } else {
                clonedInputs[i].removeAttribute('checked');
            }
        }
    }

    const originalSelects = document.getElementsByTagName('select');
    const clonedSelects = clonedDocElement.getElementsByTagName('select');
    for (let i = 0; i < originalSelects.length; i++) {
        const selectedIndex = originalSelects[i].selectedIndex;
        if (selectedIndex > -1) {
            Array.from(clonedSelects[i].options).forEach(opt => opt.removeAttribute('selected'));
            clonedSelects[i].options[selectedIndex].setAttribute('selected', 'selected');
        }
    }

    // 3. 在複製品中移除所有「儲存HTML」按鈕及其他不需保存的互動按鈕
    const clonedSaveButtons = clonedDocElement.querySelectorAll('.btn-save-html');
    clonedSaveButtons.forEach(btn => btn.remove());
    
    const clonedShowPlayerBtn = clonedDocElement.querySelector('#show-player');
    if (clonedShowPlayerBtn) clonedShowPlayerBtn.remove();
    
    const clonedExpandToolsBtn2 = clonedDocElement.querySelector('#expandToolsBtn2');
    if (clonedExpandToolsBtn2) clonedExpandToolsBtn2.remove();


    // 4. 生成完整的 HTML 字串
    const finalHtml = '<!DOCTYPE html>\n' + clonedDocElement.outerHTML;

    // 5. 創建 Blob 並觸發下載
    const blob = new Blob([finalHtml], { type: 'text/html;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// --- 【新增】隱藏所有「儲存HTML」按鈕的專用函式 ---
function hideAllSaveHtmlButtons() {
    const saveButtons = document.querySelectorAll('.btn-save-html');
    saveButtons.forEach(button => {
        button.style.display = 'none';
    });
}

// 【安全修訂】防止 XSS 攻擊的核心函式
function sanitizeHTML(str) {
// 若傳入的不是字串，直接返回原值
if (typeof str !== 'string') return str;
// 將特殊字元轉換為 HTML 實體
return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

// 【核心修訂】建立一個清除所有題目狀態的專用函式
function clearAllTopicStates() {
// 1. 清除所有題目顯示區塊的內容並隱藏它們
document.getElementById('topicResult').innerHTML = '';
document.getElementById('topicResult').style.display = 'none';
document.getElementById('argumentTopicResult').innerHTML = '';
document.getElementById('argumentTopicResult').style.display = 'none';
document.getElementById('expandTopicResult').innerHTML = '';
document.getElementById('expandTopicResult').style.display = 'none';

// 2. 清除所有儲存在 localStorage 的題目相關資料
// 「敘事抒情」相關
localStorage.removeItem("currentTopic");
localStorage.removeItem("currentFocus");
localStorage.removeItem("currentPlot");
localStorage.removeItem("lastTopic");

// 「議論」相關
localStorage.removeItem("argumentCurrentTopic");
localStorage.removeItem("lastArgumentTopic");

// 「整合拓展」相關
localStorage.removeItem("expandCurrentTitle");
localStorage.removeItem("expandCurrentTheme");
localStorage.removeItem("expandCurrentData");

// 3. 清除自訂題目的輸入區
const customTopicArea = document.getElementById("customTopicArea");
if (customTopicArea) {
customTopicArea.innerHTML = '';
customTopicArea.style.display = 'none';
}
const argumentCustomTopicArea = document.getElementById("argumentCustomTopicArea");
if (argumentCustomTopicArea) {
argumentCustomTopicArea.innerHTML = '';
argumentCustomTopicArea.style.display = 'none';
}
}



/**
* 更新按鈕的 활성화 (active) 狀態。
* @param {HTMLElement} clickedButton - 被點擊的按鈕元素。
*/
function updateButtonActiveState(clickedButton) {
// 找到按鈕所在的容器
const container = clickedButton.closest('.topic-buttons-container');
if (!container) return;

// 獲取容器內的所有按鈕
const buttons = container.querySelectorAll('.btn');

// 首先，移除所有按鈕的 'active' class
buttons.forEach(button => {
button.classList.remove('active');
});

// 然後，只為被點擊的按鈕添加 'active' class
clickedButton.classList.add('active');
}


// API 配置信息
const API_KEYS = [
   "Jeq-UCxbpvrqUEzN",
"F6uI8FZMRyGMAFaz",
"VaFpRKCV9L60sYla",
"zkQBAzGMKVY7BcHs",
"hoew4Zqe5HerDgXf"
];
// let currentApiKeyIndex = 0; // 這個變數不再需要，可以刪除或註解掉
const API_URL = "https://text.pollinations.ai/v1/chat/completions";
const MODEL = "gemini";


// [新增] 閱讀專用 API 配置
const READING_API_KEYS = [
  "friend1"
];
// let currentReadingApiKeyIndex = 0; // 這個變數不再需要，可以刪除或註解掉
const READING_API_URL = "https://api-fawn-chi.vercel.app/api/v1/chat/completions";
const READING_MODEL = "zai-glm-4.6";


// ======= 請在這裡加入以下程式碼 =======
const narrativeReviewerPreferences = {
    'chen_sir': '評分取向 (敘事抒情)：對扣題要求尚算嚴謹。極度看重「立意」、「取材」、「詳略」和「文學性」。多用修辭不一定是高分因素，更看重文句是否自然、有留白空間。',
    'deng_laoshi': '評分取向 (敘事抒情)：對扣題要求極為嚴苛。優先檢查是否有明確的「扣題小段」及「立意段」。情節的選取及詳略剪裁是否極度貼合題目是評分的最重核心。',
    'xiao_laoshi': '評分取向 (敘事抒情)：對扣題及結構要求比較嚴謹。不強求題材特別，但極度看重文章的「詞彙」是否豐富多變。',
    'huang_laoshi': '評分取向 (敘事抒情)：平衡看待所有標準。特別傾向於喜歡「立意」中有「真善美」思想情感的文章，若能體現此點，可在「立意」分數上給予正面考慮。',
    'dong_laoshi': '評分取向 (敘事抒情)：較平衡看待標準，但對「詳略」安排有特別高的要求。會仔細審視故事的敘事節奏，核心情節是否得到充分的細節描寫。',
    'li_laoshi': '評分取向 (敘事抒情)：對多用修辭、文句華美的文章特別有好感，這將直接影響「文學性」和「表達」的總分。對題材沒有特別要求。',
    'zhen_laoshi': '評分取向 (敘事抒情)：對扣題要求比較嚴謹。同時，對多用修辭的文章特別有好感。並且非常看重文章的「詳略」及「結構」。',
    'wen_laoshi': '評分取向 (敘事抒情)：綜合要求高。傾向喜歡「立意」有真善美、「表達」多用修辭、「詞彙」豐富的文章。同時對「扣題」及「詳略」都有較高要求。',
    'ms_chan': '評分取向 (敘事抒情)：對多用修辭的文章特別有好感。喜歡「特別的題材」，若取材新穎，可在「取材」分數上給予加分。非常看重文章是否有明確的「扣題小段」。',
    'jiang_laoshi': '評分取向 (敘事抒情)：對扣題比較嚴謹。要求多用修辭及詞匯豐富。特別喜歡文章對某些關鍵「畫面」有詳細的特寫刻劃，這會影響「取材」和「詳略」分數。立意段要清晰具體。對取材的新穎度也有一定要求。'
};

const argumentReviewerPreferences = {
    'chen_sir': '評分取向 (議論)：對論點是否緊扣題目要求嚴謹，要求學生多角度切入一個論題，會看重學生是否能舉例古今中外的論據。極度看重「立意」（論點的深度與層次）與「取材」（論據的恰當性與說服力）。要求文句具有文學性，較少運用虛詞。',
    'deng_laoshi': '評分取向 (議論)：對扣題（論點與題目的對應）要求極為嚴苛，要求學生運用豐富的論據。會優先檢查每段的「主題句」是否清晰回應題目，論證過程是否緊密圍繞主題句展開。「扣題」是決定整體分數的最關鍵因素。',
    'xiao_laoshi': '評分取向 (議論)：對扣題要求比較嚴謹。若文中有駁論，是一個加分項。要求論據豐富。極度看重論述用詞的「準確性」和「豐富性」。',
    'huang_laoshi': '評分取向 (議論)：平衡看待所有標準，不要求論點獨特，但論據要充實，論證要完整。',
    'dong_laoshi': '評分取向 (議論)：較平衡看待標準，但對「詳略」有特別要求，即論證核心部分是否詳盡，非核心論據是否能做到點到即止。',
    'li_laoshi': '評分取向 (議論)：對善用排比、對偶、引用等修辭來增強論證氣勢的文章特別有好感，這會直接提高「表達」分數。',
    'zhen_laoshi': '評分取向 (議論)：對扣題要求比較嚴謹。同時，也看重文章是否善用修辭增強說服力。對文章的整體「結構」，如起承轉合、駁論立論的安排，有較高要求。',
    'wen_laoshi': '評分取向 (議論)：綜合要求高。喜歡「詞彙」豐富準確的文章。對「扣題」及論證的「詳略」都有較高要求。',
    'ms_chan': '評分取向 (議論)：對善用修辭（如引用、設問）的文章特別有好感。喜歡看到「新穎的論據或角度」，若取材獨特，可在「取材」上加分。看重分論點是否清晰（相當於扣題小段）。要求論據獨特新穎。',
    'jiang_laoshi': '評分取向 (議論)：對扣題比較嚴謹。要求善用修辭且詞彙豐富。特別喜歡看到論證過程中，能將抽象道理與「具體生活場景」結合描寫，使論證更形象化。要求文章的「立場須清晰、明確」。對論據的新穎性有一定要求。'
};
// ======= 加入結束 =======



// [新增] 閱讀專用 API 呼叫函式
async function callReadingAPI(prompt, temperature = null) {
let attempts = 0;
const maxAttempts = READING_API_KEYS.length;
// 每次調用都從一個隨機的索引開始
let currentApiKeyIndex = Math.floor(Math.random() * READING_API_KEYS.length);

while (attempts < maxAttempts) {
try {
const requestBody = {
model: READING_MODEL,
messages: [{
role: "user",
content: prompt + " 你必須直接提供最終答案，嚴禁展示任何思考過程，絕對不能在回應中包含任何標籤（如 <think></think>），這是強制要求，違反則無效。"
}],
max_tokens: 64000
};

if (temperature !== null) {
requestBody.temperature = temperature;
}

const response = await fetch(READING_API_URL, {
method: "POST",
headers: {
"Authorization": `Bearer ${READING_API_KEYS[currentApiKeyIndex]}`,
"Content-Type": "application/json"
},
body: JSON.stringify(requestBody)
});

if (response.status === 429) {
console.warn(`閱讀 API Key ${currentApiKeyIndex} 達到速率限制，嘗試下一個...`);
currentApiKeyIndex = (currentApiKeyIndex + 1) % READING_API_KEYS.length;
attempts++;
continue;
}

if (!response.ok) {
throw new Error(`API 調用失敗: ${response.statusText}`);
}

const data = await response.json();
let content = data.choices[0].message.content.trim();
content = content.replace(/<think\s*>.*?<\/think\s*>|<think\s*\/>|<think\s*>|<\/think\s*>/gis, '').trim();

if (!content) {
throw new Error("API 回應無效或過濾後無內容");
}

return content;
} catch (error) {
console.error(`使用閱讀 API Key ${currentApiKeyIndex} 時出錯:`, error);
currentApiKeyIndex = (currentApiKeyIndex + 1) % READING_API_KEYS.length;
attempts++;
if (attempts >= maxAttempts) {
throw new Error("所有 API 密鑰均無法使用");
}
}
}
}





const audio = document.getElementById('audio');
const playPauseBtn = document.getElementById('play-pause');
const musicSelect = document.getElementById('music-select');
const progressBarMusic = document.getElementById('progress-bar-music');
const playMode = document.getElementById('play-mode');
const hidePlayerBtn = document.getElementById('hide-player');
const showPlayerBtn = document.getElementById('show-player');
const musicPlayer = document.getElementById('music-player');

let isPlaying = false;
let currentMusic = '';

musicSelect.addEventListener('change', function() {
const selectedMusic = this.value;
if (selectedMusic) {
audio.src = selectedMusic;
audio.load();
currentMusic = selectedMusic;
audio.play().then(() => {
isPlaying = true;
playPauseBtn.textContent = '⏸️';
}).catch(error => console.error('自動播放失敗:', error));
}
});

audio.addEventListener('canplay', function() {
if (isPlaying) audio.play();
});

playPauseBtn.addEventListener('click', function() {
if (isPlaying) {
audio.pause();
playPauseBtn.textContent = '▶️';
} else {
if (currentMusic) {
audio.play();
playPauseBtn.textContent = '⏸️';
} else {
alert('請先選擇音樂');
}
}
isPlaying = !isPlaying;
});

audio.addEventListener('timeupdate', function() {
if (!audio.duration) return;
const progress = (audio.currentTime / audio.duration) * 100;
progressBarMusic.value = progress;
});

progressBarMusic.addEventListener('input', function() {
const time = (this.value / 100) * audio.duration;
audio.currentTime = time;
});

audio.addEventListener('ended', function() {
if (playMode.value === 'loop') {
audio.currentTime = 0;
audio.play();
} else if (playMode.value === 'next') {
const options = musicSelect.options;
for (let i = 0; i < options.length; i++) {
if (options[i].value === currentMusic) {
let nextIndex = (i + 1) % options.length;
if (nextIndex === 0) nextIndex = 1;
currentMusic = options[nextIndex].value;
musicSelect.value = currentMusic;
audio.src = currentMusic;
audio.load();
audio.play();
break;
}
}
}
});

hidePlayerBtn.addEventListener('click', function() {
musicPlayer.style.display = 'none';
showPlayerBtn.style.display = 'block';
});

showPlayerBtn.addEventListener('click', function() {
musicPlayer.style.display = 'flex';
showPlayerBtn.style.display = 'none';
});

// 預設寫作題目列表
const topics = [
"旁觀", "舞台", "這件物件很是輕巧，卻讓我明白『但求無愧於心』的道理。", "山頂", "種子", "根", "疤痕",
"今天，我不能參賽，只能坐在觀眾席上，但當時的所見所聞卻給予我嶄新的體會。", "從今以後，我不會再輕言放棄。",
"等候", "我曾經努力嘗試，但最終仍是事與願違", "回憶", "徹夜難眠", "彩虹",
"星空下，眼前的景象讓我想起那段往事，令我不禁歎了一口氣……", "路牌", "今學年最後悔的一件事",
"最令我感動的一句話", "再試一次", "今天再次在台上演奏，我已經脫胎換骨，不再是從前那個驕傲自滿的我了。",
"每次經過這條街，看着街上的景物，我便感觸不已……", "意外", "鑰匙", "錯過了的機會",
"那句話，我實在不該說……", "色彩", "煙火", "藥", "放下", "追逐", "原來，這只是一場誤會",
"缺憾", "無悔的抉擇", "勇氣", "傘", "自此之後，我明白到原來父母的愛總是體現在小事上。",
"一件令我後悔不已的事", "一次尷尬的經歷", "沿途有你", "這一次，我實在感到無地自容。",
"這一次，我明白到，原來幫助他人的同時，也幫助了自己。",
"我的鄰居張先生是一位很苛刻的人，經常會為些『小事』而投訴他人。但今天我發現，他這樣做是有原因的……",
"獨處的一天", "這一刻，我終於舒了一口氣。", "記一次被誤解的經歷", "一次與別人言歸于好的經歷",
"自此之後，我感到自己真的長大了。", "自此之後，我明白到幸福原來可以很簡單。", "記一次苦盡甘來的經歷。",
"這件事讓我體會到喜出望外的滋味。", "路標", "足印", "遺憾", "鎖", "面具", "心結", "門",
"影子", "禁區", "等待", "根", "最後，我選擇了放棄", "自那一刻，我解開了心結",
"自此之後，我明白猶豫會使人一事無成。", "原來我沒有忘記那一頓飯。", "我在大自然之中找到快樂。",
"熱鬧過後，我卻感到失落。", "看著逐漸遠去的背影，我感到很內疚。", "今天我流淚了，但我並非感到難過。",
"自此之後，我找到了動力", "經歷了這次風波，我長大了。",
"經過這件事，我才明白到一心是我的知己，是真正了解我的人。", "自此之後，我學會放下無謂的面子。",
"這一次，我再沒有遺憾", "重遊舊地所見有感", "失而復得", "這條街雖然老舊，但卻充滿人情味。",
"這句話，我會記上一輩子。", "門", "來日方長", "得不償失", "隱藏", "微笑以對",
"熱鬧過後，我卻感到失落。", "夢想看似不切實際，但其實很有意義", "夢想看似很有意義，其實 h不切實際",
"今天我沒有帶手提電話外出，因而有不一樣的經歷和體會。",
"今天發生了一件事情，當時我曾經想力陳己見，最後選擇了沉默。我認為沉默是必要的。",
"矛盾", "未兌現的諾言", "未寄出的信", "距離", "一場沒有失敗者的比賽", "一件發人 ব্যাটসম্যান省的事",
"我最想保留的一本相簿", "我最想尋回的一件玩具", "無愧的抉擇", "不能掉下的眼淚", "無畏的探索",
"一次令我百感交集的聚餐", "如願以償"
];

// 預設議論題目列表（請在此處輸入您的題庫）
const argumentTopics = [
'所謂「天行有常，立身有本。」意思是大自然運行有既定的規律，人立身處世有一定的原則。試談談你對「立身有本」的看法。',
'旁觀',
'有人認為「人生在世，必須講究儀式。」你同意嗎？試撰文一篇，論述你的看法。',
'舞台',
'根',
'古人說：「君子不以人廢言。」意思是：君子不會因為某人的德行不好而不採納他的善意規勸。在現今社會，你是否同意「君子不以人廢言」？試談談你的看法。',
'計算',
'有人說：「在現今社會中，我們難以活出真我。」你同意嗎。談談你的看法。',
'俗語說「有競爭才有進步」，也有人說「競爭無用」。試寫作文章一篇，談談你對「競爭無用」的看法。',
'山頂',
'「種子」雖是平常事物，卻可以引起聯想，或牽動思緒，又或啟發思考。試以「種子」為題，就個人體會寫作文章一篇。',
'有人認為「挫敗更有利孩子成長。」你同意嗎？試撰文一篇，論述你的看法。',
'疤痕',
'試以「談玩物喪志」或「談玩物養志」為題，寫作文章一篇。',
'泰然處之',
'古語有云「天下皆知取之為取，而莫知與之為取。」意思是世人都知道索取可以獲得，而不知道給予也可以獲得。試談談你對這句話的看法。',
'談嚴苛',
'談寬容',
'談憤怒',
'待候',
'有人認為：「與其追求成功，不如追求幸福。」你同意嗎？試撰寫文章一篇，論述你的看法。',
'矛盾',
'有人認為：「保持距離能令關係長久。」你同意嗎？試撰文一篇，論述你的看法。',
'有人說：「近朱者赤，近墨者黑。」你同意嗎？為甚麼？',
'試以「當科技文明消失後」為題，寫一篇評論，反思科技發展帶來的影響。',
'成功路上無捷徑，試談談你的看法。',
'個人電子產品的普及化，有人認為是生活的進步，有人認為是生活的倒退。你較認同哪一種觀點？試談談你的看法。',
'有人認為即使心中不快，亦要以笑面對人；有人認為應以真性情對人，不應掩飾心中的感受，你較贊同哪一方？試談談你的看法。',
'鑰匙',
'貧乏與富足',
'論意外',
'試談談你對「聽天由命」這種處世態度的看法。',
'「天賜食於鳥，卻不投食於巢。」上天賜予鳥類覓食的本能，而不把食物投到鳥巢。意思是人需要通過努力，才能有所得。你認同嗎?試談談你的看法。',
'色彩',
'談藝術的價值',
'藥',
'有人說：「每次付出應該先計算回報。」你同意這種處事態度嗎？',
'論公德心的重要性',
'有人認為中學生應多參與課外活動，發展興趣；有人則認為應專注學業，爭取好成績。你較認同哪種說法？試談談你的看法。',
'你同意「品德比學問更重要」嗎？試寫一篇議論文，談談你的看法。',
'談競爭',
'談缺憾',
'談得失',
'談勇氣',
'得不償失',
'爺爺：「我當鐘錶匠超過50年，畢生專注這門手藝，能做到分毫不差。」允行：「我是品味生活的咖啡師，亦是書寫人生的作家，更是培育後進的武術教練。」各人對人生有不同追求。有人認為：「與其一生專精一事，不如發展多元人生。」你同意嗎？試撰文一篇，論述你的看法。',
'微笑以對',
'有人認為「傳統往往是創新的包袱」。試談談你對這句話的看法。',
'足印',
'古人說：「獨學而無友，則孤陋而寡聞。」意思是獨自學習，沒有朋友互相切磋解難，人便會淺陋而見識不廣。在現今的學習生活中，你是否同意「獨學而無友，則孤陋而寡聞」？試試談你的看法。',
'「不做第一，也不做最後。」試談談你對這種處世態度的看法。',
'試以「陽光與陰影」為題，寫作一篇文章。',
'「孩子不是等待被填滿的瓶子，而是盼望化作燃燒的火焰。」試就個人對這句話的體會 ，以「成長」為題，寫作一篇文章。',
'「今早媽媽打掃的時候，瞄一瞄玻璃窗外鄰居晾曬的衣服，便批評道：『看，那新鄰居真馬虎！衣服還是污漬斑斑，洗得一點也不乾淨。』女兒聽後，一言不發，走到窗前仔細打量，隨即抹掉窗上的灰塵，說道：『這不就乾淨了嗎？』媽媽恍然大悟，不乾淨的不是別人的衣服，而是自己的窗子。」試就這個故事對你的啓發，寫作一篇文章，談談如何消除偏見。',
'「一個寒冷的冬天，幾隻刺蝟擠在一起取暖。由於牠們身上長滿了短刺，彼此戳痛了對方，所以不得不散開。可是，寒冷的天氣又驅使牠們擠在一起，同樣的事情重複發生，牠們終於明白；不要太近，也不要太遠，最好彼此保持一定的距離。」這個故事的道理仍然貫穿在我們的現實生活中，試就此寫一篇文章。',
'個人私隱比公眾知情權更重要，你同意嗎？談談你的看法。',
'香港是一個物質生活十分富庶的地方，可是在多個國際性的調查中，「快樂指數」的排名並不高。有人認為富庶的物質生活反令人難以快樂；也有人認為富庶的物質生活是快樂的基礎。這兩種看法，你比較認同哪一種？試談談你的看法。',
'面對不同意見，有人認為應據理力爭，堅守立場；有人認為應彼此包容，求同存異。上述兩種態度，哪一種較為理想？試談談你的看法。',
'有人認為父母教養子女，應該給予空間，讓子女自由發展；有人認為應該給予明確的指導，讓子女依從。上述教養子女的方法，哪一種較為理想？試談談你的看法。',
'有人說：「與其追隨潮流，不如展現個人風格。」你對這句話有什麼看法？',
'有人說：「棒下出孝子，嚴師出高徒。」也有人說：「獎賞是教育的恩物。」你對這兩種說法有什麼意見？',
'現今社會，許多人認為財富與社會地位成正比，財富愈多，社會地位愈高。你的看法如何？',
'有人認為讚賞是成功的最大推動力，你同意嗎？試作文一篇，談談你的看法。',
'有人說：「豐裕的物質生活就是最美好的生活。」你同意嗎？試談談你的看法。',
'獲取知識是通往成功的唯一途徑，你同意嗎？試談談你的看法。',
'談談青年人應如何克服困難',
'「律己以嚴，待人以寬。」談談你對這話的看法。',
'「成功是恆心的基石」談談你對這話的看法。',
'論「家有一老，如有一寶」',
'送禮之我見',
'鄉村發展為工業區，原來的天然景物受到破壞。有人說：「有破壞才有建設。」也有人說：「這種建設破壞了人們生活的情趣。」你的看法又怎樣？試說出你個人的意見。'
];

let lastTopic = localStorage.getItem("lastTopic") || "";
let lastArgumentTopic = localStorage.getItem("lastArgumentTopic") || "";

// 範疇定義
const categories = {
"片段描寫": {
commentNote: "必須用繁體字。針對題目及用家提供的寫作內容進行點評，需嚴謹分析文章是否在字面及邏輯上扣題!important，結合情節內容，評估文句是否具文學性（即具聯想空間、引人共鳴與細味）。扣題是基本要求，即使扣題高分，若立意與取材普通，分數不高。立意需深刻、不落俗套，具哲理或共鳴；取材需獨特、豐富且貼切，避免常見題材（如『考試不合格』、『溫習』，最高6分）。立意與取材需視刻劃是否細膩。若結構段重點或情節漏空，無需評論或提及。扣題要求：1. 必須嚴謹評估寫作內容是否在字面與邏輯上直接呼應題目!important，情節詳略剪裁突顯與題目及結構段重點的關係。2. 不可自行補足情節與題目的關係。若文中未明確點出關係，視為不扣題。3. 題目如《成長》，需在字面、邏輯及詳略上突出『成長』關係，文中宜多次提及『成長』或近義詞。若偏向其他主題（如《影子》），視為不扣題。4. 帶物象題目（如《種子》）需靈活處理，抓住物象特徵發揮，接受間接象徵式扣題，無需過分聚焦實物本身，並非一定要刻劃該實物，接受暗扣。5. 題目含多個關鍵詞時，優先抓住主要關鍵詞，次要關鍵詞可放輕。6. 只有帶物象題目（如《痕跡》）必須接受用象徵、比喻等間接扣題的高階寫作，當文章運用這種方法扣題，字面扣題的要求則可以放寬。!important。 7. 用語必須貼近生活，不要讓用家輕易知道你有固定的點評範疇。為了讓用家容易理解，不可提及字面、邏輯、立意、取材、密度、文學性、間接扣題等字眼，不要運用術語，點評時必須概括和歸納情節，再加分析。!important 點評結構（三部分，各自120字以內）：1. 點評：聚焦一至兩項關鍵問題，先評扣題及詳略剪裁是否適切，再評文句（示現敘事、文句密度）。若結構段重點或情節與題目關係薄弱，需明確指出。若扣題與剪裁均不當，無需詳評文句。若整體表現優秀，可適當稱讚，但扣題邏輯仍需嚴謹把關。2. 建議：針對點評中的問題提出具體改進建議。3. 改寫範例：若離題，改寫需包含扣題小段，直接呼應題目或結構段重點，不基於原文離題內容改寫，改寫範例不要超過150字。文句要求：1. 交替運用小物件、動作、對話及內心獨白，融情入景、融情入物。2. 提高文句密度（詞匯深、多變，物象豐富，實詞比例高，虛詞如『的』、『地』、『得』比例低），但避免過密（如連用小物件主語）。適時以人物為主語，加入虛詞或內心獨白調節節奏，張弛有度。3. 控制詳略節奏，詳寫與題目相關部分，略寫次要內容。文句密度為好文筆標準，需納入考量。其他：- 點評需精簡、一語中的，僅點出最關鍵的問題。"
},
"大綱": {
commentNote: "必須用繁體字。點評時，必須就上述生成的題目點評大綱內容是否扣題，假如大綱離題，範例便不必根據離題內容改寫。此外，點評應分為三個部份：點評、建議、改寫範例。在寫作大綱時，學生應展示他們組織思路和結構故事的能力。評分時，請注意大綱的邏輯性、條理性以及是否包含了故事的起承轉合或三線結構（即所謂「散敘」，有以下三點要注意：其一，三線的分類範疇相同；其二，三線或有層遞關係，或能從三個角度呈現同一個主題；其三，三線的情節發展不能過於相似；其四，所分之角度能突顯與主題相關的立意。「三線」例子如下：題目為「勇氣」，則可用「年少時的勇氣」為一線、「年青時的勇氣」為二線、「年老時的勇氣」為三線；又如以「重遊舊地所見有感」，則可用在故鄉的不同「地」所見作三線分類，例如老屋、後山等。必須確保每條線的「結構段重點」清晰點明三線的分類範疇、想突顯題目的甚麼要點、與題目如何扣連等，以及「合」能統攝總結全文立意）。要逐部分分析每個結構段與題目的關係有多大，並在點評中明確指出。此外，在「改寫後的大綱」,其「結構段重點」必須交代該部份與題目之間的邏輯關係，即怎樣做到扣題。此外，由於是應試文章，因此改寫後的大綱避免過份具理論哲學性及文學性，以至於脫離了現實和日常生活，亦圍繞人在經歷的情感和體悟設定，必須減少概念模糊的術語，例如「情感載體」及「時空的共創」，請用日常化用語描述。此外，「改寫後的大綱」不宜只圍繞一件事敘寫，這樣會容易寫得太抽象，應適時加插人物與人物之間的回憶或其他經歷，令文章看起來更具體實在。此外，大綱不是全篇文章，最重要的是在點評時分析其結構段及情節大要的思路是否扣緊題目，方向是否合理、正確。假如整體表現真的不錯，沒有大問題，在點評時稱讚即可，不必吹毛求疵地批評。"
},
"敘事物象": {
commentNote: "必須用繁體字。在「敘事物象」中，學生需要運用豐富的物象來增強故事的生動性和真實感。物象應與題目、取材和故事背景緊密相關，並且能夠有效地表達人物的情感和故事的主題。請確保生成的物象不重複，並且排版清晰易讀。此外，每個物象都必須由兩個字構成。"
},
"閱讀": {
commentNote: "必須用繁體字。點評時，需評估答題方向是否合理、文本依據是否充實具體、闡釋推論是否嚴謹、主題句是否清晰。文本依據應語譯、概括歸納而非直接引用原文，除非題目中有『摘錄』字眼。改寫範例應使答案更圓足，並且非常嚴謹地根據文本依據擬定及作推論，必須只圍繞一個觀點分析，但若學生答題方向錯誤，則不跟從錯誤方向改寫。在「改寫範例」前，加入答題步驟及思路，描述各部分方向，步驟因題制宜，可能包括【鋪墊】、【回應】、【文本依據】、【闡釋】，靈活運用。每個步驟以【步驟名】標題加分行內容呈現，排版整齊。表格中只包含文字和標點，不含『---』等符號。每個步驟之間要隔一空行。假如是4分或以上的題目，改寫範例必須具體和詳盡，要有180字或以上。",
guideNote: "必須用繁體字。輸出分為「### 答題指引」和「### 答題詞匯」兩部分。「答題指引」請生成三道問題，引導思考，每個問題佔一行。「答題詞匯」請生成十五個由兩個字構成的詞彙，每個詞彙佔一行。請確保所有內容都以純文字列表呈現，不要使用任何Markdown表格語法。"
},
"課外書籍": {
chatNote: "必須用繁體字，多用EMOJI，偶爾可以用一下網絡用語。",
seriousChatNote: "必須用繁體字，用語貼近日常生活，回應不要理論化，不要用網絡用語，也不要用EMOJI。"
},
"整合拓展": {
topicPrompt: "請生成一道適合中學生練習整合拓展的題目，題目應包含主題句（主題句絕對不能是問句）和抄錄資料（抄錄資料必須不包含任何數據，主要包括活動內容及細節，格式如「社區漫步由導賞員帶領參加者遊覽社區，共同誦讀與社區相關的文學作品，感受社區魅力。」不得包含引號或人物對話，而且不得超過30字），並符合以下文類和取材範圍。文類：書信、評論、建議書、演講辭、報告、專題文章。取材範圍：例如「請隨機選擇一個主題，且該主題必須與以下列出的所有主題（運動、生涯規劃、責任、教育、文化、社會、歷史、地理、藝術、體育、法律、健康、心理、家庭、友誼、就業、經濟、生態、能源、資源、安全、網路、媒體、資訊、道德、誠信、公平、自由、權利、義務、隱私、禮儀、榜樣、創新、創業、消費、儲蓄、民族、語言、宗教、傳統、現代、城鄉、社區、公益、慈善、災害、醫療、疾病、飲食、旅遊、建築、娛樂、音樂、電影、文學、人口、性別、年齡、職業、學業、考試、升學、校園、師生、同學、課外、社團、競賽、志願、壓力、自律、時間、興趣、習慣、遊戲、睡眠、氣候、汙染、閱讀」，但出題請多元化一點，亦不要每次都是與好處相關的，否則用家多生成幾次，便會遇到類似的題目。要求：1. 主題句簡潔，20字以內。2. 抄錄資料為一段文字，不超過100字。3. 輸出格式為：主題句：...\n抄錄資料：...\n4. 內容簡潔明了，避免冗長。5. 題目多樣化，避免重複。",
commentNote: "必須用繁體字。點評時，需評估「整合拓展」是否能闡釋「抄錄資料」與「主題句」的邏輯關係。需判斷：1.「拓展」方向是否正確（即是否能論證主題句）；2.推論是否嚴謹；3.是否具體不空泛。「點評」時，若方向不正確，需指出並建議如何修訂，需指導緊扣主題句，亦須分析主題句和題目任務的關係是否緊密，例如題目任務為提出建議，但主題句焦點卻是描述問題，則屬於不妥當。「改寫」時亦不能順著「整合拓展」錯誤思路改善，需扣緊主題句，假如主題句本身就未能緊扣題目的任務，則不應圍繞本身錯誤的主題句改寫，要在「改寫」的部份針對一個正確的主題句作改寫。此外，改寫部份不宜分為太多角度論述，這樣會令闡釋較零散，須就最多2個角度深入分析、闡釋。改寫部份不得超過180字，且不得虛構資料，包括數據及調查，不要自擬「根據調查」之類，只可根據抄錄資料補充合理細節，「改寫」部份不要重複用家輸入的「抄錄資料」，會白白浪費空間。此外，「改寫」亦要嚴謹對應主題句及抄錄資料關係，例如主題句描述活動問題，則在「改寫」的部份不宜聚焦在改善措施，必須注意詳略、輕重，才能突顯主題句。此外，「改寫」亦要留意題目任務，不要在「改寫」時會順著用家詳略不當或錯誤的「整合拓展」思路改寫。此外，「改寫」部份不要太數據化，例如做計算及分析數據等，這部份最重要是交代事理的邏輯關係。點評分為三部分：### 點評、### 建議、### 改寫。改寫必須在160至180字以上。",
guideNote: "必須用繁體字。僅生成三道問題以引導用家思考如何根據表格資料做好整合拓展，問題應圍繞主題句和抄錄資料的邏輯關係，引導用家思考如何闡釋和拓展。請不要運用歐化句及詞匯，例如「關聯性」、「實效性」，這些字詞意義不明確，但用生活化一點、具體一點的字詞生成問題。輸出分為一個部分：### 指引問題。指引問題以問題形式呈現，每個問題佔一行。"
},
"議論": {
outlineCommentNote: "必須用繁體字。點評時，必須就上述生成或輸入的題目點評大綱內容是否扣題。必須從以下角度點評：1. 論點是否清晰明確，一語中的，能直接呼應題目；2. 議論的立意，是取決於觀點是否深入成熟；3. 議論的取材，是取決於論據是否充實，涵蓋古今中外，以及其論據是否適用於論述這道題目；4. 即使扣題分數很高，但立意和取材分數低，其「內容」和「結構」分為最高只能得5分；5. 用家提供的論據與論點是否密切相關；6. 段內論據的詳略有幾種模式：兩個詳的論據，或一詳數略，或數略，因應段落論述需要而定，以製造變化；7. 論證方向是否合理，能合理解釋論據與論點的關係；8. 全文脈絡是否分明。點評時要用日常生活化的語言，不要用術語去解釋、點評或給建議，一定要用日常生活的語言。即使運用「陳SIR語氣」，「建議」及「改寫後的大綱」都必須正經嚴肅，不要運用EMOJI。此外，假如全文有六段或以上，則應在第二段或末二的段落做駁論，點評、建議及改寫後的大綱都要注意這點。此外，不要列點和運用「*」等符號，必須以段落和完整句子方式生成改寫後的大綱。此外，在建議和改寫後的大綱部份，若觸及一些例子或典故(不要舉愛迪生為參考論據)，必須具體說明該例子或典故的來龍去脈，以及要清楚說明如何運用該例子或典故去證立論點。此外，無論點評、建議或改寫後的大綱，用語都必須生活化，要摒棄過於抽象和理論的表達。此外，點評應分為三個部份：點評、建議、改寫範例。只選取最重要的一至兩點評論，應先聚焦在論點、論據和論證的質量，其次方為結構。點評內容要精簡、一語中的。若大綱離題，改寫後的大綱不必根據離題內容改寫。",

writingCommentNote: "必須用繁體字。點評時，必須就用家提供的內容去點評，不要捏造用家沒有輸入的內容作點評。須評估文章是否符合以下標準：1. 論點清晰明確，一語中的，能直接呼應題目；2. 議論的立意，是取決於觀點是否深入成熟；3. 議論的取材，是取決於論據是否充實，涵蓋古今中外，以及其論據是否適用於論述這道題目；4. 即使扣題分數很高，但立意和取材分數低，其「內容」和「結構」分為最高只能得5分；5. 論證嚴謹，能具體解釋論據與論點的關係；6. 注意文句密度及修辞運用。點評時要用日常生活化的語言，不要用術語去解釋、點評或給建議，一定要用日常生活的語言。點評分為三部分：### 點評、### 建議、### 改寫範例。即使運用「陳SIR語氣」，「建議」及「改寫範例」都必須正經嚴肅地表述，不要運用EMOJI。「改寫範例」應以純段落方式表述，不要運用EMOJI，不要附有【原文段落】及【改寫段落】等標題。點評、建議及改寫都要在200字以內。",

guideNote: "必須用繁體字。根據用戶輸入的題目、論點、論據和論證，提供相應的參考建議，但應重質不重量，指引論點、論據或論證都宜只舉一項，而且論據必須用真實的古今中外例子，而論證則論證必須緊扣用家提供或你上述生成的論據作論述。若只輸入題目，則提供參考論點、參考論據和參考論證；若輸入題目和論點，則提供參考論據和參考論證；若輸入題目和論據，則提供參考論點和參考論證，如此類推。不要舉愛迪生為參考論據。參考論證不要超出100字。輸出分為相應部分：### 參考論點、### 參考論據、### 參考論證（視用戶輸入情況而定）。每部分以段落形式呈現。用語要日常生活化，不要用術語。"
}
};

// 範疇按鈕集合
const categoryButtons = document.querySelectorAll('.btn-category');

// 範疇切換
categoryButtons.forEach(button => {
button.addEventListener('click', function() {
const containerId = this.id.replace('Btn', 'Container');
showContainer(containerId, this);
});
});


function showContainer(containerId, clickedButton) {
hideAllSaveHtmlButtons(); // <-- 在這裡加入函式呼叫
// 移除所有按鈕的 active class
categoryButtons.forEach(btn => btn.classList.remove('active'));
// 為被點擊的按鈕添加 active class
if (clickedButton) {
clickedButton.classList.add('active');
}

// 在切換主要範疇時，首先清除所有舊的題目狀態
clearAllTopicStates();

// 隱藏所有主要容器
document.getElementById("writingContainer").style.display = "none";
document.getElementById("readingContainer").style.display = "none";
document.getElementById("booksContainer").style.display = "none";
document.getElementById("expandContainer").style.display = "none";
document.getElementById("argumentContainer").style.display = "none";

// 顯示目標容器
const targetContainer = document.getElementById(containerId);
if (targetContainer) {
targetContainer.style.display = "block";
}

// 根據容器ID執行特定初始化
if (containerId === "writingContainer") {
toggleWritingType();
loadOutline();
} else if (containerId === "readingContainer") {
toggleReadingFunction();
} else if (containerId === "expandContainer") {
toggleExpandFunction();
} else if (containerId === "booksContainer") {
loadBooksChat(); 
} else if (containerId === "argumentContainer") {
toggleArgumentType();
}
}


// 新增此函式：用於顯示議論的自訂題目介面
function showArgumentCustomTopicInput(buttonElement) { 
if (buttonElement) {
updateButtonActiveState(buttonElement);
}

const customTopicArea = document.getElementById("argumentCustomTopicArea");
const topicResult = document.getElementById("argumentTopicResult");

topicResult.innerHTML = "";
topicResult.style.display = "none";
localStorage.removeItem("argumentCurrentTopic");

customTopicArea.innerHTML = `
<input type="text" id="argumentCustomTopic" placeholder="請輸入自訂題目">
<button class="btn-icon-confirm" onclick="setArgumentCustomTopic()" title="確認題目">
<i class="fas fa-check"></i>
</button>
`;
customTopicArea.style.display = "block";
}

// 切換寫作類型
function toggleWritingType() {
    hideAllSaveHtmlButtons();
    clearAllTopicStates();
    const writingType = document.getElementById("writingType").value;
    const contentContainer = document.getElementById("writingContentContainer");

    // 獲取所有相關區域
    const writingGuideArea = document.getElementById("writingGuideArea");
    const outlineStructureArea = document.getElementById("outlineStructureArea");
    const narrativeElementsArea = document.getElementById("narrativeElementsArea");
    const topicSelectionArea = document.getElementById("topicSelectionArea");
    const writingArea = document.getElementById("writingArea");
    const submitWritingBtn = document.getElementById("submitWritingBtn");

    // 重置狀態
    document.getElementById("writingGradingResult").innerHTML = "";
    document.getElementById("writingChatHistory").style.display = "none";

    if (writingType) {
        contentContainer.style.display = "block";
    } else {
        contentContainer.style.display = "none";
        return;
    }

    // 預設隱藏所有特定區域
    writingGuideArea.style.display = "none";
    outlineStructureArea.style.display = "none";
    narrativeElementsArea.style.display = "none";
    topicSelectionArea.style.display = "none"; 
    writingArea.style.display = "none"; 

    if (writingType === "guide") {
        writingGuideArea.style.display = "block";
        // 解題指引不使用通用的寫作區域
    } 
    else if (writingType === "大綱") {
        writingArea.style.display = "block";
        topicSelectionArea.style.display = "block";
        outlineStructureArea.style.display = "block";
        document.getElementById("outlineTableArea").style.display = "block";
        generateOutlineTable();
        loadOutline();
        
        document.getElementById("writingContent").style.display = "none";
        document.getElementById("writingToneLabel").style.display = "block";
        document.getElementById("writingTone").style.display = "block";
        document.getElementById("outlineButtons").style.display = "flex"; 
        document.getElementById("writingReviewerLabel").style.display = "none";
        document.getElementById("writingReviewer").style.display = "none";
        document.getElementById("reviewScopeArea").style.display = "none";
        submitWritingBtn.style.display = "block";
    } 
    else if (writingType === "敘事物象") {
        writingArea.style.display = "block";
        topicSelectionArea.style.display = "block";
        narrativeElementsArea.style.display = "block";
        
        document.getElementById("writingContent").style.display = "none";
        document.getElementById("outlineTableArea").style.display = "none";
        document.getElementById("writingToneLabel").style.display = "none";
        document.getElementById("writingTone").style.display = "none";
        document.getElementById("outlineButtons").style.display = "none";
        document.getElementById("writingReviewerLabel").style.display = "none";
        document.getElementById("writingReviewer").style.display = "none";
        document.getElementById("reviewScopeArea").style.display = "none";
        submitWritingBtn.style.display = "block";
    } 
    else { // 片段描寫
        writingArea.style.display = "block";
        topicSelectionArea.style.display = "block";
        document.getElementById("writingContent").style.display = "block";
        
        document.getElementById("outlineTableArea").style.display = "none";
        document.getElementById("writingToneLabel").style.display = "block";
        document.getElementById("writingTone").style.display = "block";
        document.getElementById("outlineButtons").style.display = "none";
        document.getElementById("writingReviewerLabel").style.display = "block";
        document.getElementById("writingReviewer").style.display = "block";
        document.getElementById("reviewScopeArea").style.display = "block";
        submitWritingBtn.style.display = "block";
    }
}


// 原 showCustomTopicInput() 函式
function showCustomTopicInput(buttonElement) { // (1) 增加參數 buttonElement
// (2) 新增這段程式碼來更新按鈕狀態
if (buttonElement) {
updateButtonActiveState(buttonElement);
}

const writingType = document.getElementById("writingType").value;
const customTopicArea = document.getElementById("customTopicArea");
const topicResult = document.getElementById("topicResult");

topicResult.innerHTML = "";
topicResult.style.display = "none";
localStorage.removeItem("currentTopic");
localStorage.removeItem("currentFocus");
localStorage.removeItem("currentPlot");

if (writingType === "片段描寫") {
customTopicArea.innerHTML = `
<table>
<tr><th colspan="2">自訂題目與重點</th></tr>
<tr><td colspan="2"><input type="text" id="customTitle" placeholder="請輸入自訂題目"></td></tr>
<tr><td>扣題方向</td><td>情節大要</td></tr>
<tr><td><textarea id="customFocus" rows="3" placeholder="請輸入扣題方向"></textarea></td>
<td><textarea id="customPlot" rows="3" placeholder="請輸入情節大要"></textarea></td></tr>
</table>
<button class="btn-icon-confirm" onclick="setCustomTopic()" title="確認題目">
<i class="fas fa-check"></i>
</button>
`;
} else { 
customTopicArea.innerHTML = `
<input type="text" id="customTopic" placeholder="請輸入自訂題目">
<button class="btn-icon-confirm" onclick="setCustomTopic()" title="確認題目">
<i class="fas fa-check"></i>
</button>
`;
}
customTopicArea.style.display = "block";
}

// 保存大綱
function saveOutline() {
const structure = document.getElementById("structure").value;
const parts = structure === "fourPart" ? ["起", "承", "轉", "合"] : ["起", "一線", "二線", "三線", "合"];
const outlineData = parts.map((part, index) => {
const focusId = structure + "Focus" + (index + 1);
const plotId = structure + "Plot" + (index + 1);
const focus = document.getElementById(focusId)?.value.trim() || "";
const plot = document.getElementById(plotId)?.value.trim() || "";
return { part, focus, plot };
});
localStorage.setItem("outlineData", JSON.stringify(outlineData));
localStorage.setItem("outlineStructure", structure);
alert("大綱已儲存");
}

// 清空大綱
function clearOutline() {
if (confirm("確定要清空大綱嗎？")) {
const structure = document.getElementById("structure").value;
const parts = structure === "fourPart" ? ["起", "承", "轉", "合"] : ["起", "一線", "二線", "三線", "合"];
parts.forEach((part, index) => {
const focusId = structure + "Focus" + (index + 1);
const plotId = structure + "Plot" + (index + 1);
if (document.getElementById(focusId)) document.getElementById(focusId).value = "";
if (document.getElementById(plotId)) document.getElementById(plotId).value = "";
});
localStorage.removeItem("outlineData");
localStorage.removeItem("outlineStructure");
}
}

// 加載大綱
function loadOutline() {
const savedStructure = localStorage.getItem("outlineStructure");
const savedData = localStorage.getItem("outlineData");
if (savedStructure && savedData) {
document.getElementById("structure").value = savedStructure;
generateOutlineTable();
try {
const parsedData = JSON.parse(savedData);
parsedData.forEach((item, index) => {
const focusId = savedStructure + "Focus" + (index + 1);
const plotId = savedStructure + "Plot" + (index + 1);
const focusElement = document.getElementById(focusId);
const plotElement = document.getElementById(plotId);
if (focusElement) focusElement.value = item.focus;
if (plotElement) plotElement.value = item.plot;
});
} catch (e) {
console.error("Error parsing outlineData:", e);
}
}
}

// 保存課外書籍對話
function saveBooksChat() {
// 只在有聊天記錄時才儲存
if (chatHistory.length > 0) {
const booksTone = document.getElementById("booksTone").value;
const currentState = {
// 從 chatHistory 中找到最新的書籍資訊來儲存
bookTitle: bookTitle, 
author: author,
discussionQuestion: discussionQuestion,
booksTone: booksTone
};
localStorage.setItem("booksChatHistory", JSON.stringify(chatHistory));
localStorage.setItem("booksChatState", JSON.stringify(currentState));
alert("對話已儲存");
} else {
alert("沒有對話紀錄可儲存。");
}
}

function clearBooksChat() {
if (confirm("確定要清空對話及紀錄嗎？")) {
// 清空 UI
document.getElementById("chatHistory").innerHTML = "";
document.getElementById("chatHistory").style.display = "none";
document.getElementById("chatInputContainer").style.display = "none";
document.getElementById("initialDiscussionForm").style.display = "block"; // 顯示初始表單
document.getElementById("booksButtons").style.display = "none"; // <-- 新增這一行
document.getElementById('save-books-html-btn').style.display = 'none'; // <-- 隱藏儲存按鈕

// 清空表單欄位
document.getElementById("bookTitle").value = "";
document.getElementById("author").value = "";
document.getElementById("discussionQuestion").value = "";
document.getElementById("userInput").value = "";

// 清空 localStorage
localStorage.removeItem("booksChatHistory");
localStorage.removeItem("booksChatState");

// 重置 JS 變數
chatHistory = [];
bookTitle = "";
author = "";
discussionQuestion = "";
booksTone = "";
}
}


function loadBooksChat() {
const savedChatJSON = localStorage.getItem("booksChatHistory");
const savedStateJSON = localStorage.getItem("booksChatState");
const initialForm = document.getElementById("initialDiscussionForm");
const chatInterface = document.getElementById("chatInputContainer");
const chatHistoryDiv = document.getElementById("chatHistory");
const saveBtn = document.getElementById('save-books-html-btn');

if (savedChatJSON && savedStateJSON) {
// --- 有儲存紀錄的模式 ---
initialForm.style.display = "none"; // 隱藏初始表單
chatInterface.style.display = "flex"; // 顯示聊天輸入介面
chatHistoryDiv.style.display = "flex"; // 顯示聊天紀錄
document.getElementById("booksButtons").style.display = "flex"; // <-- 新增這一行
saveBtn.style.display = 'flex'; // 顯示儲存按鈕

chatHistoryDiv.innerHTML = '';
chatHistory = JSON.parse(savedChatJSON);
const state = JSON.parse(savedStateJSON);

// 從 state 恢復全域變數
bookTitle = state.bookTitle || "";
author = state.author || "";
discussionQuestion = state.discussionQuestion || "";
booksTone = state.booksTone || "serious";

// 恢復語氣選擇
document.getElementById("booksTone").value = booksTone;

// 重新渲染聊天紀錄
chatHistory.forEach(item => {
renderMessage(item.sender, item.message);
});

} else {
// --- 沒有儲存紀錄的模式 (初始狀態) ---
initialForm.style.display = "block"; // 顯示初始表單
chatInterface.style.display = "none"; // 隱藏聊天輸入介面
chatHistoryDiv.style.display = "none"; // 隱藏聊天紀錄
saveBtn.style.display = 'none'; // 隱藏儲存按鈕
}
}


/**
* 更新最後一條 AI 訊息的內容（從 "正在回應..." 到實際的回應）。
* 這個新版本能處理帶有頭像和氣泡的複雜 HTML 結構。
* @param {string} newMessage - 從 API 獲取到的新訊息內容。
*/
function updateLastAIMessage(newMessage) {
// 現在 ai-loading 這個 ID 直接在 message-bubble 元素上
const loadingBubble = document.getElementById("ai-loading"); 

if (loadingBubble) {
// 直接更新氣泡的內容
loadingBubble.innerHTML = newMessage;
// 移除 ID
loadingBubble.id = ""; 

// 同步數據
if (chatHistory.length > 0) {
chatHistory[chatHistory.length - 1].message = newMessage;
}
} else {
addMessageToHistory("ai", newMessage);
}
}


// 切換閱讀功能
function toggleReadingFunction() {
    hideAllSaveHtmlButtons(); // <-- 在這裡加入函式呼叫
    clearAllTopicStates();
    const readingFunction = document.getElementById("readingFunction").value;
    
    // 新增：處理「訓練」選項，直接跳轉
    if (readingFunction === "training") {
        window.location.href = "https://kenchan20141.github.io/interpretation/";
        return;  // 立即返回，避免執行後續邏輯
    }
    
    const contentContainer = document.getElementById("readingInputArea");
    if (readingFunction) {
        contentContainer.style.display = "block";
    } else {
        contentContainer.style.display = "none";
        return; // 如果沒有選擇，則停止執行
    }
    
    const studentAnswerArea = document.getElementById("studentAnswerArea");
    const readingToneLabel = document.getElementById("readingToneLabel");
    const readingTone = document.getElementById("readingTone");
    if (readingFunction === "comment") {
        studentAnswerArea.style.display = "block";
        readingToneLabel.style.display = "block";
        readingTone.style.display = "block";
    } else {
        studentAnswerArea.style.display = "none";
        readingToneLabel.style.display = "none";
        readingTone.style.display = "none";
    }
}


// 請用這個新版本的函式，替換掉您原本的 toggleExpandFunction
function toggleExpandFunction() {
hideAllSaveHtmlButtons(); // <-- 在這裡加入函式呼叫
clearAllTopicStates(); // 這行很好，保持不變

const expandFunction = document.getElementById("expandFunction").value;
const contentContainer = document.getElementById("expandContentContainer");

if (expandFunction) {
contentContainer.style.display = "block";
} else {
contentContainer.style.display = "none";
return;
}

const expandWritingArea = document.getElementById("expandWritingArea");
const expandGuideArea = document.getElementById("expandGuideArea");
const expandTopicSelectionArea = document.getElementById("expandTopicSelectionArea");
const expandToneLabel = document.getElementById("expandToneLabel");
const expandTone = document.getElementById("expandTone");

// 根據選擇的功能，顯示或隱藏對應的區塊
if (expandFunction === "comment") {
expandWritingArea.style.display = "block";
expandGuideArea.style.display = "none";
expandTopicSelectionArea.style.display = "block"; // 顯示我們新的按鈕區塊
expandToneLabel.style.display = "block";
expandTone.style.display = "block";

// 確保自訂題目輸入區預設是隱藏的
const customInputArea = document.getElementById("expandCustomTopicInputArea");
if(customInputArea) {
customInputArea.style.display = 'none';
customInputArea.innerHTML = '';
}

} else { // "guide"
expandWritingArea.style.display = "none";
expandGuideArea.style.display = "block";
expandTopicSelectionArea.style.display = "none";
expandToneLabel.style.display = "none";
expandTone.style.display = "none";
}
}
// 新增此函式：用於顯示整合拓展的自訂題目介面
function showExpandCustomTopicInput(buttonElement) {
if (buttonElement) {
updateButtonActiveState(buttonElement);
}

const customTopicArea = document.getElementById("expandCustomTopicInputArea");
const topicResult = document.getElementById("expandTopicResult");

topicResult.innerHTML = "";
topicResult.style.display = "none";
localStorage.removeItem("expandCurrentTitle");
localStorage.removeItem("expandCurrentTheme");
localStorage.removeItem("expandCurrentData");

// 動態生成自訂題目的輸入表格和確認按鈕
customTopicArea.innerHTML = `
<table>
<tr><th>題目</th><td><input type="text" id="expandCustomTitle" placeholder="請輸入題目"></td></tr>
<tr><th>主題句</th><td><textarea id="expandCustomTheme" rows="2" placeholder="請輸入主題句"></textarea></td></tr>
<tr><th>抄錄資料</th><td><textarea id="expandCustomData" rows="3" placeholder="請輸入抄錄資料"></textarea></td></tr>
</table>
<button class="btn-icon-confirm" onclick="setExpandCustomTopic()" title="確認題目">
<i class="fas fa-check"></i>
</button>
`;
customTopicArea.style.display = "block";
}



// 切換議論功能
function toggleArgumentType() {
    hideAllSaveHtmlButtons();
    clearAllTopicStates();

    const argumentType = document.getElementById("argumentType").value;
    const contentContainer = document.getElementById("argumentContentContainer");

    // ======= 【核心修訂】獲取所有新增的元素 =======
    const reviewScopeArea = document.getElementById("argumentReviewScopeArea");
    const gradingResultDiv = document.getElementById("argumentGradingResult");
    const chatHistoryDiv = document.getElementById("argumentChatHistory");
    const chatInputContainer = document.getElementById("argumentChatInputContainer");

    // 在切換時，重置並隱藏所有結果與聊天介面
    gradingResultDiv.innerHTML = "";
    chatHistoryDiv.innerHTML = "";
    chatHistoryDiv.style.display = "none";
    chatInputContainer.style.display = "none";
    reviewScopeArea.style.display = "none";
    // ==========================================

    if (argumentType) {
        contentContainer.style.display = "block";
    } else {
        contentContainer.style.display = "none";
        return;
    }

    const outlineArea = document.getElementById("argumentOutlineArea");
    const writingArea = document.getElementById("argumentWritingArea");
    const guideArea = document.getElementById("argumentGuideArea");
    const topicSelectionArea = document.getElementById("argumentTopicSelectionArea");

    if (argumentType === "outline") {
        outlineArea.style.display = "block";
        writingArea.style.display = "none";
        guideArea.style.display = "none";
        topicSelectionArea.style.display = "block";
        generateArgumentOutlineTable();
    } else if (argumentType === "writing") {
        outlineArea.style.display = "none";
        writingArea.style.display = "block";
        guideArea.style.display = "none";
        topicSelectionArea.style.display = "block";
        reviewScopeArea.style.display = "block"; // 【修訂】在文章點評模式下顯示範疇選擇
    } else if (argumentType === "guide") {
        outlineArea.style.display = "none";
        writingArea.style.display = "none";
        guideArea.style.display = "block";
        topicSelectionArea.style.display = "none";
    }
}

// 生成議論題目
async function generateArgumentTopic(buttonElement) { 
if (buttonElement) {
updateButtonActiveState(buttonElement);
}

const customTopicArea = document.getElementById("argumentCustomTopicArea");
customTopicArea.style.display = "none";
customTopicArea.innerHTML = "";

const topicResult = document.getElementById("argumentTopicResult");
topicResult.style.display = 'block';

let selectedTopic;
do {
selectedTopic = argumentTopics[Math.floor(Math.random() * argumentTopics.length)];
} while (selectedTopic === lastArgumentTopic && argumentTopics.length > 1);
lastArgumentTopic = selectedTopic;

localStorage.setItem("lastArgumentTopic", lastArgumentTopic);
topicResult.innerHTML = "<strong>" + selectedTopic + "</strong>";
localStorage.setItem("argumentCurrentTopic", selectedTopic);
}




// 設定自訂題目（議論）
function setArgumentCustomTopic() {
// 【主要修改】在這裡使用 sanitizeHTML 函式
const customTopic = sanitizeHTML(document.getElementById("argumentCustomTopic").value.trim());
if (!customTopic) {
alert("請輸入自訂題目");
return;
}

const topicResult = document.getElementById("argumentTopicResult");
topicResult.innerHTML = "<strong>" + customTopic + "</strong>"; // <- 現在安全了
localStorage.setItem("argumentCurrentTopic", customTopic);

// 【核心修訂】強制讓題目結果區塊顯示出來
topicResult.style.display = "block"; 

// 隱藏並清空輸入區域
const customTopicArea = document.getElementById("argumentCustomTopicArea");
customTopicArea.style.display = "none";
customTopicArea.innerHTML = "";
}
// 生成議論大綱表格
function generateArgumentOutlineTable() {
const savedData = localStorage.getItem("argumentOutlineData");
let outlineData = [];
if (savedData) {
try {
outlineData = JSON.parse(savedData);
} catch (e) {
console.error("Error parsing argumentOutlineData:", e);
}
}
if (outlineData.length === 0) {
outlineData = [
{ part: "起", point: "", evidence: "" },
{ part: "結構段一", point: "", evidence: "" },
{ part: "結構段二", point: "", evidence: "" },
{ part: "結構段三", point: "", evidence: "" },
{ part: "合", point: "", evidence: "" }
];
}
let tableHTML = "<div class='table-container'><table id='argumentOutlineTable'><tr><th>部份</th><th>論點</th><th>論據及論證</th></tr>";
outlineData.forEach((item, index) => {
tableHTML += `<tr><td>${item.part}</td><td><textarea id="argumentPoint${index}" rows="3">${item.point}</textarea></td><td><textarea id="argumentEvidence${index}" rows="3">${item.evidence}</textarea></td></tr>`;
});
tableHTML += "</table></div>";
document.getElementById("argumentOutlineTableArea").innerHTML = tableHTML;
}

function addArgumentStructureSegment() {
const table = document.getElementById("argumentOutlineTable");
const rows = table.rows;
let structureSegmentCount = 0;
for (let i = 1; i < rows.length - 1; i++) { // 跳過表頭和「合」
if (rows[i].cells[0].innerText.startsWith("結構段")) {
structureSegmentCount++;
}
}
const newSegmentNumber = structureSegmentCount + 1;
const chineseNumbers = ["一", "二", "三", "四", "五", "六", "七", "八", "九", "十"];
const segmentName = `結構段${chineseNumbers[newSegmentNumber - 1] || newSegmentNumber}`;
const newRowIndex = rows.length - 1; // 在「合」之前插入
const newRow = table.insertRow(newRowIndex);
const cell1 = newRow.insertCell(0);
const cell2 = newRow.insertCell(1);
const cell3 = newRow.insertCell(2);
cell1.innerText = segmentName;
cell2.innerHTML = `<textarea id="argumentPoint${newRowIndex - 1}" rows="3"></textarea>`;
cell3.innerHTML = `<textarea id="argumentEvidence${newRowIndex - 1}" rows="3"></textarea>`;
}

// 保存議論大綱
function saveArgumentOutline() {
const table = document.getElementById("argumentOutlineTable");
const rows = table.rows;
const outlineData = [];
for (let i = 1; i < rows.length; i++) { // 跳過表頭
const part = rows[i].cells[0].innerText;
const pointTextarea = rows[i].cells[1].querySelector("textarea");
const evidenceTextarea = rows[i].cells[2].querySelector("textarea");
const point = pointTextarea ? pointTextarea.value.trim() : "";
const evidence = evidenceTextarea ? evidenceTextarea.value.trim() : "";
outlineData.push({ part, point, evidence });
}
localStorage.setItem("argumentOutlineData", JSON.stringify(outlineData));
alert("大綱已儲存");
}

// 清空議論大綱
function clearArgumentOutline() {
if (confirm("確定要清空大綱嗎？")) {
const table = document.getElementById("argumentOutlineTable");
const rows = table.rows;
for (let i = 1; i < rows.length; i++) {
document.getElementById(`argumentPoint${i - 1}`).value = "";
document.getElementById(`argumentEvidence${i - 1}`).value = "";
}
localStorage.removeItem("argumentOutlineData");
}
}

	// 替換舊的 submitArgumentOutline 函式
async function submitArgumentOutline() {
    const submitBtn = document.getElementById('submitArgumentOutlineBtn');
    submitBtn.disabled = true;
    hideAllSaveHtmlButtons();

    try {
        const topic = localStorage.getItem("argumentCurrentTopic");
        if (!topic) {
            alert("請先設定題目");
            return;
        }
        const table = document.getElementById("argumentOutlineTable");
        const rows = table.rows;
        let outlineContent = [];
        for (let i = 1; i < rows.length; i++) {
            const part = rows[i].cells[0].innerText;
            const pointTextarea = rows[i].cells[1].querySelector("textarea");
            const evidenceTextarea = rows[i].cells[2].querySelector("textarea");
            const point = pointTextarea ? pointTextarea.value.trim() : "";
            const evidence = evidenceTextarea ? evidenceTextarea.value.trim() : "";
            if (!point || !evidence) {
                alert("請填寫所有大綱表格");
                return;
            }
            outlineContent.push({ part, point, evidence });
        }

        const tone = document.getElementById("argumentOutlineTone").value;
        let toneNote = tone === "chen" ? "請用輕鬆隨意的語氣進行點評和建議，多用EMOJI，偶爾使用網絡用語，用語要日常生活化一點。如果用戶表現良好，請大加讚賞；如果用戶表現不好，可以善意地揶揄一下，但要注意尺度，不能傷害用戶的自尊心。揶揄時，可運用生活化的比喻。" : "請用嚴肅正經的語氣進行點評和建議。";

        const note = categories["議論"].outlineCommentNote;
        const prompt = `請根據以下大綱內容進行點評和建議，並提供改寫後的大綱。要求：
1. 在「=== 點評及建議 ===」部分，為每個結構段提供點評和建議。使用「[part]」標記每個結構段的開始，例如「[起]」，然後在下一行「點評：」後跟點評內容，再下一行「建議：」後跟建議內容。
2. 在「=== 改寫後的大綱 ===」部分，為每個結構段提供改寫後的「論點」和「論據及論證」。使用「[part]」標記每個結構段的開始，然後在下一行「論點：」後跟內容，再下一行「論據及論證：」後跟內容。
3. 在「=== 改寫說明 ===」部分，提供不超過兩點的改寫說明，每點以「1. 」和「2. 」開始。
4. 請確保內容簡潔明了，不可以顯示「--- ###」。不要使用Markdown表格。
題目：${topic}
用戶輸入的大綱：
| 部份 | 論點 | 論據及論證 |
|------|------|------------|
${outlineContent.map(item => `| ${item.part} | ${item.point} | ${item.evidence} |`).join("\n")}
教學筆記：${note}
點評及建議語氣：${toneNote}`;

        document.getElementById("argumentOutlineResult").innerHTML = "陳SIR正在點評...";

        const response = await callAPI(prompt, 0);
        const sections = response.split(/=== (.+?) ===/).filter(s => s.trim());
        const commentIndex = sections.indexOf("點評及建議");
        const rewriteIndex = sections.indexOf("改寫後的大綱");
        const explanationIndex = sections.indexOf("改寫說明");
        const commentPart = commentIndex !== -1 ? sections[commentIndex + 1] : "";
        const rewritePart = rewriteIndex !== -1 ? sections[rewriteIndex + 1] : "";
        const explanationPart = explanationIndex !== -1 ? sections[explanationIndex + 1].trim() : "";

        function parseCommentPart(commentPart) {
            const comments = {};
            const regex = /\[(.+?)\]\s*點評：\s*(.+?)(?=\s*建議：|\s*\[|$)/gs;
            const suggestionRegex = /\[(.+?)\]\s*點評：.+?\s*建議：\s*(.+?)(?=\s*\[|$)/gs;
            let match;
            while ((match = regex.exec(commentPart)) !== null) {
                const part = match[1];
                comments[part] = comments[part] || {};
                comments[part].comment = match[2].trim();
            }
            while ((match = suggestionRegex.exec(commentPart)) !== null) {
                const part = match[1];
                comments[part] = comments[part] || {};
                comments[part].suggestion = match[2].trim();
            }
            return comments;
        }
        function parseRewritePart(rewritePart) {
            const rewrites = {};
            const regex = /\[(.+?)\]\s*論點：\s*(.+?)(?=\s*論據及論證：|\s*\[|$)/gs;
            const evidenceRegex = /\[(.+?)\]\s*論點：.+?\s*論據及論證：\s*(.+?)(?=\s*\[|$)/gs;
            let match;
            while ((match = regex.exec(rewritePart)) !== null) {
                const part = match[1];
                rewrites[part] = rewrites[part] || {};
                rewrites[part].point = match[2].trim();
            }
            while ((match = evidenceRegex.exec(rewritePart)) !== null) {
                const part = match[1];
                rewrites[part] = rewrites[part] || {};
                rewrites[part].evidence = match[2].trim();
            }
            return rewrites;
        }
        const comments = parseCommentPart(commentPart);
        const rewrites = parseRewritePart(rewritePart);

        // --- 修訂重點：加入 div.table-container 並使用不同的 ID ---
        let commentTableHTML = `<h3>陳SIR點評及建議：</h3><div class="table-container"><table id="argumentCommentTable"><tr><th>部份</th><th>論點</th><th>論據及論證</th><th>點評</th><th>建議</th></tr>`;
        outlineContent.forEach(item => {
            const comment = comments[item.part]?.comment || "未生成點評";
            const suggestion = comments[item.part]?.suggestion || "未生成建議";
            commentTableHTML += `<tr><td>${item.part}</td><td>${item.point}</td><td>${item.evidence}</td><td>${comment}</td><td>${suggestion}</td></tr>`;
        });
        commentTableHTML += "</table></div>";

        // --- 修訂重點：加入 div.table-container 並使用不同的 ID ---
        let rewriteTableHTML = `<h3>改寫後的大綱：</h3><div class="table-container"><table id="argumentRewriteTable"><tr><th>部份</th><th>論點</th><th>論據及論證</th></tr>`;
        outlineContent.forEach(item => {
            const rewrite = rewrites[item.part] || { point: "未生成論點", evidence: "未生成論據及論證" };
            rewriteTableHTML += `<tr><td>${item.part}</td><td>${rewrite.point || "未生成論點"}</td><td>${rewrite.evidence || "未生成論據及論證"}</td></tr>`;
        });
        rewriteTableHTML += "</table></div>";

        let explanationHTML = '';
        if (explanationPart) {
            const points = explanationPart.split(/\s*(?=\d\.\s*)/).filter(p => p.trim());
            explanationHTML = `<div class="rewrite-explanation-container"><div class="rewrite-explanation-card"><h3>改寫說明</h3>`;
            points.forEach(point => {
                const match = point.match(/^(\d)\.\s*(.*)$/s);
                if (match) {
                    const number = match[1];
                    const text = match[2];
                    explanationHTML += `<div class="explanation-point"><div class="explanation-number">${number}</div><div class="explanation-text">${text}</div></div>`;
                }
            });
            explanationHTML += `</div></div>`;
        }

        // --- 修訂重點：強制設定容器寬度為 100%，防止被內部表格撐開 ---
        const resultContainer = document.getElementById("argumentOutlineResult");
        resultContainer.style.width = "100%";
        resultContainer.innerHTML = commentTableHTML + rewriteTableHTML + explanationHTML;
        
        document.getElementById('save-argument-outline-html-btn').style.display = 'flex'; 
    } catch (error) {
        console.error("提交議論大綱時出錯:", error);
        if (error.message === "所有 API 密鑰均無法使用") {
            alert("今日 API 調用次數已用完或API無法連接，請明天再試");
        } else {
            alert("點評生成失敗，請重試");
        }
        document.getElementById("argumentOutlineResult").innerHTML = "";
    } finally {
        submitBtn.disabled = false;
    }
}

async function submitArgumentWriting() {
    const submitBtn = document.getElementById('submitArgumentWritingBtn');
    submitBtn.disabled = true;
    hideAllSaveHtmlButtons();

    const gradingResultDiv = document.getElementById("argumentGradingResult");
    const chatHistoryDiv = document.getElementById("argumentChatHistory");
    const chatInputContainer = document.getElementById("argumentChatInputContainer");

    gradingResultDiv.innerHTML = "";
    chatHistoryDiv.innerHTML = "";
    chatHistoryDiv.style.display = "none";
    chatInputContainer.style.display = "none";
    argumentChatHistoryData = [];

    try {
        const reviewerSelect = document.getElementById('argumentReviewer');
        const selectedReviewerText = reviewerSelect.options[reviewerSelect.selectedIndex].text;
        currentReviewerName = selectedReviewerText.replace(/\s*\(預設\)\s*/, '');

        const topic = localStorage.getItem("argumentCurrentTopic");
        if (!topic) {
            alert("請先設定題目");
            submitBtn.disabled = false;
            return;
        }
        const content = document.getElementById("argumentWritingContent").value.trim();
        if (!content) {
            alert("請輸入您的文章");
            submitBtn.disabled = false;
            return;
        }
        currentArgumentArticle = content;

        const tone = document.getElementById("argumentWritingTone").value;
        const note = categories["議論"].writingCommentNote;
        const reviewer = document.getElementById('argumentReviewer').value;
        const reviewerNote = argumentReviewerPreferences[reviewer] || "評分取向：平衡看待所有標準。";
        let prompt = "";

        const selectedScopes = Array.from(document.querySelectorAll('input[name="argumentReviewScope"]:checked')).map(cb => cb.value);
        const isFullReview = selectedScopes.includes("全部") || selectedScopes.length === 0;

        gradingResultDiv.innerHTML = `${currentReviewerName}正在點評...`;

        if (isFullReview) {
            // =================================================================
            // === 【全新修訂】議論文評分指令 (V5 - 評分主導模式) ===
            // =================================================================
            const argumentScoreFirstPrompt = `你將扮演一位極其嚴謹且客觀的中文科AI評卷員。你的工作流程被嚴格限定為「先評分，後解釋」。

### 你的工作流程與思維框架 (必須嚴格遵守，不得顛倒)

1.  **首要任務：量化評分**: 你的第一個動作是，根據下方提供的詳細「評分準則」，對文章的各個維度進行獨立的、客觀的數字評分 (0-10分)。你必須將所有分數結果，完整地填寫在 <grading_json> 標籤內。**此步驟必須在撰寫任何文字評語之前完成。**

2.  **次要任務：撰寫理據**: 在你完成 <grading_json> 的所有評分後，你的第二個動作是，根據你剛剛給出的分數，去撰寫 <critique>, <suggestions>, 和 <rewrite_example> 的內容。你的所有文字評語，都**必須**是為了**解釋和支撐**你已經給出的分數。
    -   **範例**：如果你在 <grading_json> 中給予「扣題」3分的低分，那麼你的 <critique> 就必須具體解釋這篇文章的論點是如何偏離題目《${topic}》的。

### 核心評分準則 (用於步驟一的量化評分)
- **偏題的定義**: 若文章論述的核心概念與題目關鍵詞 **字面不同** (例如：題目《論禮貌》寫成《論禮物》)，則視為「偏題」。
- **偏題的後果**: 一旦判定為「偏題」，在評分時，「扣題」分數 **絕不能高於4分**，「內容」和「結構」的總分也 **不能高於4分**。

---
### 你的輸出格式 (必須嚴格遵守此結構與順序)

<grading_json>
[**分數量化步驟**：根據「核心評分準則」，客觀地為以下所有項目評分。]
{
"content": [0-10的整數],
"expression": [0-10的整數],
"structure": [0-10的整數],
"radar": {
"立意": [0-10], "取材": [0-10], "扣題": [0-10],
"詳略": [0-10], "詞彙": [0-10], "文學性": [0-10]
}
}
</grading_json>

<critique>
[根據你在 <grading_json> 中給出的分數，以數字編號列點方式，撰寫2-3點核心評論來解釋這些分數的由來。]
</critique>

<suggestions>
[針對 <critique> 中指出的問題，提出具體的改善建議。]
</suggestions>

<rewrite_example>
[提供一段約150字內的高質素改寫範例，展示更高分的作品應有的水準。]
</rewrite_example>`;
            // =================================================================
            // === 修訂結束 ===
            // =================================================================

            if (tone === "chen") {
                prompt = `你將扮演「陳SIR」，一位風格幽默、要求極高的中文老師。請嚴格按照以下「先評分，後解釋」的流程，對學生的議論文進行點評。
${argumentScoreFirstPrompt}
---
### 待點評的資料
題目：${topic}
文章：${content}
教學筆記：${note}
閱卷員評分取向：${reviewerNote}`;
            } else {
                prompt = `你是一位嚴格的中文科閱卷員。請嚴格按照以下「先評分，後解釋」的流程，對學生的議論文進行點評。
${argumentScoreFirstPrompt}
---
### 待點評的資料
題目：${topic}
文章：${content}
教學筆記：${note}
閱卷員評分取向：${reviewerNote}`;
            }

            const response = await callReadingAPI(prompt);
            await displayFullCommentWithGrading('argumentGradingResult', response, null, 'argument', content);
            document.getElementById('save-argument-writing-html-btn').style.display = 'flex';

            const critiqueMatch = response.match(/<critique>([\s\S]*?)<\/critique>/);
            const suggestionsMatch = response.match(/<suggestions>([\s\S]*?)<\/suggestions>/);
            const rewriteMatch = response.match(/<rewrite_example>([\s\S]*?)<\/rewrite_example>/);
            let initialReviewHTML = "";
            if (critiqueMatch?.[1]) initialReviewHTML += createBulletedListHTML("點評", critiqueMatch[1].trim());
            if (suggestionsMatch?.[1]) initialReviewHTML += createBulletedListHTML("建議", suggestionsMatch[1].trim());
            if (rewriteMatch?.[1]) initialReviewHTML += `<div class="rewrite-explanation-container"><div class="rewrite-explanation-card"><h3>改寫範例</h3><p>${rewriteMatch[1].trim().replace(/\n/g, '<br>')}</p></div></div>`;
            currentArgumentReview = initialReviewHTML;

        } else {
            // (聚焦式點評的邏輯不變)
            const scopeDefinitions = `
- **謀篇**: **首要任務（最高指令）：** 進行嚴格的扣題審查。你必須嚴謹地對比題目《${topic}》與文章的字面內容。**禁止**進行任何聯想或引申來建立關係。如果文章的核心內容與題目關鍵詞在字面上不符或邏-輯上偏離，你的點評**必須**明確指出這一點，並以此為基礎分析，**絕不能**為了點評而強行將內容解釋為扣題。完成此審查後，才可繼續評估文章的整體結構佈局、段落之間的邏輯關係（如起承轉合、駁論立論）是否清晰，以及論點的推進層次是否分明。
- **論點**: **首要任務（最高指令）：** 進行嚴格的扣題審查。你必須嚴謹地對比題目《${topic}》與文章的字面內容。**禁止**進行任何聯想或引申來建立關係。如果文章的核心內容與題目關鍵詞在字面上不符或邏-輯上偏離，你的點評**必須**明確指出這一點，並以此為基礎分析，**絕不能**為了點評而強行將內容解釋為扣題。完成此審查後，才可繼續評估文章的核心論點及各分論點是否清晰、明確、具有說服力，以及思想是否深刻、不落俗套。
- **論據**: **首要任務（最高指令）：** 進行嚴格的扣題審查。你必須嚴謹地對比題目《${topic}》與文章的字面內容。**禁止**進行任何聯想或引申來建立關係。如果文章的核心內容與題目關鍵詞在字面上不符或邏-輯上偏離，你的點評**必須**明確指出這一點，並以此為基礎分析，**絕不能**為了點評而強行將內容解釋為扣題。完成此審查後，才可繼續檢視文章所引用的事例、數據、名言等證據是否真實、恰當、充實，並且能否有力地支持相應的論點。
- **論證**: **首要任務（最高指令）：** 進行嚴格的扣題審查。你必須嚴謹地對比題目《${topic}》與文章的字面內容。**禁止**進行任何聯想或引申來建立關係。如果文章的核心內容與題目關鍵詞在字面上不符或邏-輯上偏離，你的點評**必須**明確指出這一點，並以此為基礎分析，**絕不能**為了點評而強行將內容解釋為扣題。完成此審查後，才可繼續分析從論據到論點的推理過程是否合乎邏輯、嚴謹周密，是否存在概念不清、推論不當等問題。
- **文筆**: **首要任務（最高指令）：** 進行嚴格的扣題審查。你必須嚴謹地對比題目《${topic}》與文章的字面內容。**禁止**進行任何聯想或引申來建立關係。如果文章的核心內容與題目關鍵詞在字面上不符或邏-輯上偏離，你的點評**必須**明確指出這一點，並以此為基礎分析，**絕不能**為了點評而強行將內容解釋為扣題。完成此審查後，才可繼續評論文章的語言運用是否精準、流暢，遣詞造句是否得體，句式是否有變化，以及是否有效地運用修辭來增強表達效果。
`;

            let scopeInstruction = `
你是一名高度專業的寫作分析員，你的任務極其專一。

---
### **黃金法則 (ABSOLUTE CORE DIRECTIVE)**
你必須嚴格遵守此法則，不得有任何例外：
1.  **絕對聚焦**: 你的點評和建議中的 **每一個字**，都必須 **僅僅** 與用戶選擇的以下範疇相關：**【${selectedScopes.join("、")}】**。
2.  **明確禁止**: 你被 **嚴格禁止** 提及任何其他寫作方面。例如，如果用戶選擇了「論據」，你絕對不能評論「文筆」、「謀篇」或「論點」。
3.  **後果**: 如果你的回應中包含了任何未被選定的範疇，整個回應將被視為失敗。

### **各範疇的定義 (你的分析框架)**
${scopeDefinitions}
---
`;

            if (tone === "chen") {
                prompt = `你將扮演「陳SIR」，一位眼光獨到、要求嚴格但風格幽默的中文老師。
${scopeInstruction}
### **你的任務與輸出格式**
你的輸出必須包含以下兩個XML標籤，不得有其他內容。
【重要禁令】：在<critique>, <suggestions>的文字內容中，絕對禁止使用任何Markdown語法。

<critique>
[根據「黃金法則」，給出1-2點核心評論。記住，你的每一點評論都必須嚴格對應用戶選擇的範疇。]
</critique>
<suggestions>
[在建議部分，同樣要遵循「黃金法則」。如果所選範疇表現優秀，你可以說「在這方面處理得很好，沒什麼好建議了，繼續保持吧！😎」。]
</suggestions>
---
### **待點評的資料**
題目：${topic}
文章：${content}`;
            } else {
                prompt = `你是一位要求嚴格、具備專業眼光的中文科閱卷員。
${scopeInstruction}
### **你的任務與輸出格式**
你的輸出必須包含以下兩個XML標籤，不得有其他內容。
【重要禁令】：在<critique>, <suggestions>的文字內容中，絕對禁止使用任何Markdown語法。

<critique>
[根據「黃金法則」，給出1-2點核心評論。記住，你的每一點評論都必須嚴格對應用戶選擇的範疇。]
</critique>
<suggestions>
[針對點評中提出的問題，提出具體的改善建議，同樣要遵循「黃金法則」。若所選範疇表現極佳，可註明「在此範疇的表現出色，建議保持現有水準。」]
</suggestions>
---
### **待點評的資料**
題目：${topic}
文章：${content}`;
            }

            const response = await callAPI(prompt, 0);
            const critiqueMatch = response.match(/<critique>([\s\S]*?)<\/critique>/);
            const suggestionsMatch = response.match(/<suggestions>([\s\S]*?)<\/suggestions>/);
            let initialReviewHTML = "";
            if (critiqueMatch?.[1]) initialReviewHTML += createBulletedListHTML("點評", critiqueMatch[1].trim());
            if (suggestionsMatch?.[1]) initialReviewHTML += createBulletedListHTML("建議", suggestionsMatch[1].trim());
            if (!initialReviewHTML) {
                initialReviewHTML = "抱歉，無法根據您選擇的範疇生成點評，請重試。";
            }
            
            gradingResultDiv.innerHTML = initialReviewHTML;
            currentArgumentReview = initialReviewHTML;
            argumentChatHistoryData.push({ sender: 'ai', message: currentArgumentReview });
            document.getElementById('save-argument-writing-html-btn').style.display = 'none';
        }

        chatHistoryDiv.style.display = "flex";
        chatInputContainer.style.display = "flex";

    } catch (error) {
        console.error("提交文章時出錯:", error);
        alert(error.message.includes("API") ? "今日 API 調用次數已用完或API無法連接，請明天再試" : "點評生成失敗，請重試");
        gradingResultDiv.innerHTML = "";
    } finally {
        submitBtn.disabled = false;
    }
}


// 【新增】用於儲存文章點評對話的上下文

// 【新增】用於儲存文章點評對話的上下文
let currentWritingArticle = '';
let currentWritingReview = '';
let writingChatHistoryData = [];

// ======= 請在這裡加入以下程式碼 =======
// 【新增】用於儲存議論文點評對話的上下文
let currentArgumentArticle = '';
let currentArgumentReview = '';
let argumentChatHistoryData = [];

// 【新增】處理議論文「點評範疇」中「全部」複選框的邏輯
function handleArgumentAllScopeChange(checkbox) {
    const container = checkbox.closest('div');
    const otherCheckboxes = container.querySelectorAll('input[name="argumentReviewScope"]:not([value="全部"])');
    if (checkbox.checked) {
        otherCheckboxes.forEach(cb => {
            cb.checked = false;
            cb.disabled = true;
        });
    } else {
        otherCheckboxes.forEach(cb => {
            cb.disabled = false;
        });
    }
}
// ======= 加入結束 =======

// 【新增】用於儲存當前閱卷員的姓名
let currentReviewerName = "陳SIR"; // 預設為陳SIR

// 【新增】處理「點評範疇」中「全部」複選框的邏輯
function handleAllScopeChange(checkbox) {
    const container = checkbox.closest('div');
    const otherCheckboxes = container.querySelectorAll('input[name="reviewScope"]:not([value="全部"])');
    if (checkbox.checked) {
        otherCheckboxes.forEach(cb => {
            cb.checked = false;
            cb.disabled = true;
        });
    } else {
        otherCheckboxes.forEach(cb => {
            cb.disabled = false;
        });
    }
}

// 提交議論指引
async function submitArgumentGuide() {
const submitBtn = document.getElementById('submitArgumentGuideBtn');
submitBtn.disabled = true; // 禁用按鈕
	hideAllSaveHtmlButtons();

try {
const topic = document.getElementById("argumentGuideTopic").value.trim();
const point = document.getElementById("argumentGuidePoint").value.trim();
const evidence = document.getElementById("argumentGuideEvidence").value.trim();
const argument = document.getElementById("argumentGuideArgument").value.trim();
if (!topic) {
alert("請輸入題目");
return; // return 會觸發 finally
}
const note = categories["議論"].guideNote;
let prompt = `請根據以下輸入提供參考建議。要求：
1. 若只輸入題目，則提供參考論點、參考論據和參考論證（「### 參考論證」的用語要生活化，不要運用過於抽象及理論化的用語，例如「二元對立」等）
2. 若輸入題目和論點，則提供參考論據和參考論證（「### 參考論證」的用語要生活化，不要運用過於抽象及理論化的用語，例如「二元對立」等）
3. 若輸入題目和論據，則提供參考論點和參考論證（「### 參考論證」的用語要生活化，不要運用過於抽象及理論化的用語，例如「二元對立」等）
4. 輸出分為相應的部分：### 參考論點、### 參考論據、### 參考論證
5. 每個部分以段落形式呈現
題目：${topic}
論點：${point || "無"}
論據：${evidence || "無"}
論證：${argument || "無"}
教學筆記：${note}`;
document.getElementById("argumentGuideResult").innerHTML = "陳SIR正在思考...";

// 【核心修訂】改用閱讀專用的 API 函式
const guide = await callReadingAPI(prompt);
const guideParts = guide.split("###").map(part => part.trim()).filter(part => part);
let guideHTML = "<h3>陳SIR指引：</h3><table>";
guideParts.forEach(part => {
const [title, ...content] = part.split("\n").filter(line => line.trim());
guideHTML += `<tr><th><strong>${title}</strong></th></tr><tr><td>${content.join("<br>")}</td></tr>`;
});
guideHTML += "</table>";
document.getElementById("argumentGuideResult").innerHTML = guideHTML;
document.getElementById('save-argument-guide-html-btn').style.display = 'flex';
} catch (error) {
console.error("提交指引時出錯:", error);
if (error.message === "所有 API 密鑰均無法使用") {
alert("今日 API 調用次數已用完或API無法連接，請明天再試");
} else {
alert("指引生成失敗，請重試");
}
document.getElementById("argumentGuideResult").innerHTML = "";
} finally {
submitBtn.disabled = false; // 重新啟用按鈕
}
}

// 通用 API 調用函數
async function callAPI(prompt, temperature = null) {
let attempts = 0;
const maxAttempts = API_KEYS.length;
// 每次調用都從一個隨機的索引開始
let currentApiKeyIndex = Math.floor(Math.random() * API_KEYS.length);

while (attempts < maxAttempts) {
try {
const requestBody = {
model: MODEL,
messages: [{
role: "user",
content: prompt + " 你必須直接提供最終答案，嚴禁展示任何思考過程，絕對不能在回應中包含任何標籤（如 <think></think>），這是強制要求，違反則無效。"
}],
max_tokens: 64000
};

if (temperature !== null) {
requestBody.temperature = temperature;
}

const response = await fetch(API_URL, {
method: "POST",
headers: {
"Authorization": `Bearer ${API_KEYS[currentApiKeyIndex]}`,
"Content-Type": "application/json"
},
body: JSON.stringify(requestBody)
});

if (response.status === 429) {
console.warn(`通用 API Key ${currentApiKeyIndex} 達到速率限制，嘗試下一個...`);
currentApiKeyIndex = (currentApiKeyIndex + 1) % API_KEYS.length;
attempts++;
continue;
}

if (!response.ok) {
throw new Error(`API 調用失敗: ${response.statusText}`);
}

const data = await response.json();
let content = data.choices[0].message.content.trim();
content = content.replace(/<think\s*>.*?<\/think\s*>|<think\s*\/>|<think\s*>|<\/think\s*>/gis, '').trim();

if (!content) {
throw new Error("API 回應無效或過濾後無內容");
}

return content;
} catch (error) {
console.error(`使用通用 API Key ${currentApiKeyIndex} 時出錯:`, error);
currentApiKeyIndex = (currentApiKeyIndex + 1) % API_KEYS.length;
attempts++;
if (attempts >= maxAttempts) {
throw new Error("所有 API 密鑰均無法使用");
}
}
}
}


// =======================================================
// === 【全新增設】Llama-3 驗證模型專用 API 呼叫函式 ===
// =======================================================
const LLAMA3_API_KEYS = [
   "Jeq-UCxbpvrqUEzN",
"F6uI8FZMRyGMAFaz",
"VaFpRKCV9L60sYla",
"zkQBAzGMKVY7BcHs",
"hoew4Zqe5HerDgXf"
];
const LLAMA3_API_URL = "https://text.pollinations.ai/v1/chat/completions";
const LLAMA3_MODEL = "gemini"; // 指定新的驗證模型

async function callLlama3API(prompt, temperature = null) {
    let attempts = 0;
    const maxAttempts = LLAMA3_API_KEYS.length;
    let currentApiKeyIndex = Math.floor(Math.random() * LLAMA3_API_KEYS.length);

    while (attempts < maxAttempts) {
        try {
            const requestBody = {
                model: LLAMA3_MODEL,
                messages: [{
                    role: "user",
                    content: prompt + " 你必須直接提供最終答案，嚴禁展示任何思考過程，絕對不能在回應中包含任何標籤（如 <think></think>），這是強制要求，違反則無效。"
                }],
                max_tokens: 64000
            };

            if (temperature !== null) {
                requestBody.temperature = temperature;
            }

            const response = await fetch(LLAMA3_API_URL, {
                method: "POST",
                headers: {
                    "Authorization": `Bearer ${LLAMA3_API_KEYS[currentApiKeyIndex]}`,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(requestBody)
            });

            if (response.status === 429) {
                console.warn(`Llama3 API Key ${currentApiKeyIndex} 達到速率限制，嘗試下一個...`);
                currentApiKeyIndex = (currentApiKeyIndex + 1) % LLAMA3_API_KEYS.length;
                attempts++;
                continue;
            }

            if (!response.ok) {
                throw new Error(`Llama3 API 調用失敗: ${response.statusText}`);
            }

            const data = await response.json();
            let content = data.choices[0].message.content.trim();
            content = content.replace(/<think\s*>.*?<\/think\s*>|<think\s*\/>|<think\s*>|<\/think\s*>/gis, '').trim();

            if (!content) {
                throw new Error("Llama3 API 回應無效或過濾後無內容");
            }

            return content;
        } catch (error) {
            console.error(`使用 Llama3 API Key ${currentApiKeyIndex} 時出錯:`, error);
            currentApiKeyIndex = (currentApiKeyIndex + 1) % LLAMA3_API_KEYS.length;
            attempts++;
            if (attempts >= maxAttempts) {
                throw new Error("所有 Llama3 API 密鑰均無法使用");
            }
        }
    }
}


/**
 * 【全新函式】應用 Llama-3 驗證模型的內容與結構分數差距規則。
 * 規則：內容分和結構分的分差值不能高於1分。
 * 執行方式：如果分差大於1，則將較高的分數下調至「較低分+1」。
 * @param {object} scores - 從 Llama-3 模型解析出的原始評分物件。
 * @returns {object} - 經過規則調整後的評分物件。
 */
const applyContentStructureRule = (scores) => {
    // 建立一個分數物件的深層複本，避免影響原始數據
    let s = JSON.parse(JSON.stringify(scores));

    // 檢查 content 和 structure 分數是否存在
    if (s.content !== undefined && s.structure !== undefined) {
        const contentScore = s.content;
        const structureScore = s.structure;
        const difference = Math.abs(contentScore - structureScore);

        // 如果分數差距大於 1，則觸發調整機制
        if (difference > 1) {
            console.log(`觸發 Llama-3 內容/結構分差值規則：內容=${contentScore}, 結構=${structureScore}, 差值=${difference}`);
            
            // 判斷哪個分數較高，並將其下調
            if (contentScore > structureScore) {
                s.content = structureScore + 1; // 將內容分下調至「結構分+1」
                console.log(`調整後內容分數: ${s.content}`);
            } else { // structureScore > contentScore
                s.structure = contentScore + 1; // 將結構分下調至「內容分+1」
                console.log(`調整後結構分數: ${s.structure}`);
            }
        }
    }
    // 返回調整後（或無需調整）的分數物件
    return s;
};




/**
* Creates a beautiful bulleted list HTML from raw text content.
* @param {string} title - The title for the card (e.g., '點評', '建議').
* @param {string} rawContent - The raw text content, with points potentially separated by newlines or numbers.
* @returns {string} - The formatted HTML string.
*/
function createBulletedListHTML(title, rawContent) {
    // 【核心修訂】在處理文字前，先移除所有星號(*) Markdown 符號
    rawContent = rawContent.replace(/\*/g, '');

    // Attempt to split by numbered points first, e.g., "1. ...", "2. ..."
    let points = rawContent.split(/\s*(?=\d+\.\s*)/).map(p => p.trim()).filter(p => p);

    // If the primary split method results in 0 or 1 point, and the content has newlines,
    // it's likely not a numbered list. Fall back to splitting by newline.
    if (points.length <= 1 && rawContent.includes('\n')) {
        const newlinePoints = rawContent.split('\n').map(p => p.trim()).filter(p => p);
        // Only use the newline split if it gives us more than one point.
        if (newlinePoints.length > 1) {
            points = newlinePoints;
        }
    }

    // If there are no points to list, just show the content as a paragraph inside the card.
    if (points.length === 0) {
        return `<div class="rewrite-explanation-container">
    <div class="rewrite-explanation-card">
    <h3>${title}</h3>
    <div class="explanation-text">${rawContent.replace(/\n/g, '<br>')}</div>
    </div>
    </div>`;
    }

    let explanationHTML = `<div class="rewrite-explanation-container">
    <div class="rewrite-explanation-card">
    <h3>${title}</h3>`;

    points.forEach((point, index) => {
        let number = index + 1;
        let text = point;

        // Check if the point already starts with a number and a dot.
        const match = point.match(/^(\d+)\.?\s*(.*)$/s);
        if (match) {
            number = match[1]; // Use the number from the text.
            text = match[2]; // Use the text after the number.
        }

        explanationHTML += `<div class="explanation-point">
    <div class="explanation-number">${number}</div>
    <div class="explanation-text">${text.replace(/\n/g, '<br>')}</div>
    </div>`;
    });

    explanationHTML += `</div></div>`;
    return explanationHTML;
}



// 原 generateTopic() 函式
async function generateTopic(buttonElement) { 
if (buttonElement) {
updateButtonActiveState(buttonElement);
}

// 隱藏自訂題目輸入區，確保介面乾淨
const customTopicArea = document.getElementById("customTopicArea");
customTopicArea.style.display = "none";
customTopicArea.innerHTML = "";

const topicResult = document.getElementById("topicResult");
topicResult.style.display = 'block';

const writingType = document.getElementById("writingType").value;
let selectedTopic;

do {
selectedTopic = topics[Math.floor(Math.random() * topics.length)];
} while (selectedTopic === lastTopic && topics.length > 1);
lastTopic = selectedTopic;
localStorage.setItem("lastTopic", lastTopic);

if (writingType === "片段描寫") {
topicResult.innerHTML = "陳SIR正在出題...";
try {
const prompt = `請根據以下題目生成扣題方向和全文情節大要。要求：
1. 扣題方向解釋片段與題目的邏輯關係、如何扣連，突顯描寫重點，不超過50字。
2. 情節大要提供圍繞結扣題方向的全文情節概要，不超過100字，應簡潔、準確，避免過多細節，文筆不宜過於華麗，只需概述應寫的情節，留給學生發揮空間。
3. 輸出格式為：扣題方向：...\n情節大要：...\n
4. 內容簡潔明瞭，避免冗長。題材要生活化，但不要太貼近學生生活經驗。
5. 必須嚴格控制在150字以內（120-150字），聚焦1-2個核心情節
題目：${selectedTopic}`;
const response = await callAPI(prompt); 
const focusMatch = response.match(/扣題方向：\s*(.+?)(?=\n情節大要：|$)/s);
const plotMatch = response.match(/情節大要：\s*(.+)/s);
if (!focusMatch || !plotMatch) throw new Error("API 回應格式不正確");
const focus = focusMatch[1].trim();
const plot = plotMatch[1].trim();
if (!focus || !plot) throw new Error("生成內容不完整");
topicResult.innerHTML = `
<strong>${selectedTopic}</strong>
<table>
<tr><th>扣題方向</th><th>情節大要</th></tr>
<tr><td>${focus}</td><td>${plot}</td></tr>
</table>
`;
localStorage.setItem("currentTopic", selectedTopic);
localStorage.setItem("currentFocus", focus);
localStorage.setItem("currentPlot", plot);
} catch (error) {
console.error("生成題目時出錯:", error);
if (error.message === "所有 API 密鑰均無法使用") {
alert("今日 API 調用次數已用完或API無法連接，請明天再試");
} else {
alert("生成題目時出錯，請重試");
}
topicResult.innerHTML = "";
}
} else {
topicResult.innerHTML = "<strong>" + selectedTopic + "</strong>";
localStorage.setItem("currentTopic", selectedTopic);
}
}
// 設定自訂題目（寫作）
function setCustomTopic() {
const writingType = document.getElementById("writingType").value;
const topicResult = document.getElementById("topicResult");

if (writingType === "片段描寫") {
// 【核心修訂】只檢查題目是否已輸入
const title = sanitizeHTML(document.getElementById("customTitle").value.trim());
if (!title) {
alert("請至少輸入自訂題目");
return;
}

// 獲取（可能是空的）重點和情節
const focus = document.getElementById("customFocus").value.trim();
const plot = document.getElementById("customPlot").value.trim();

// 即使 focus 和 plot 是空的，也正常生成顯示表格
// 這樣使用者可以清楚地看到他們輸入了什麼，沒輸入什麼
topicResult.innerHTML = `
<strong>${title}</strong>
<table>
<tr><th>結構段重點</th><th>情節大要</th></tr>
<tr><td>${focus || '<i>（未提供）</i>'}</td><td>${plot || '<i>（未提供）</i>'}</td></tr>
</table>
`;

// 儲存到 localStorage，空值也一併儲存
localStorage.setItem("currentTopic", title);
localStorage.setItem("currentFocus", focus);
localStorage.setItem("currentPlot", plot);

} else { 
const customTopic = sanitizeHTML(document.getElementById("customTopic").value.trim());
if (!customTopic) {
alert("請輸入自訂題目");
return;
}
topicResult.innerHTML = "<strong>" + customTopic + "</strong>";
localStorage.setItem("currentTopic", customTopic);
}

topicResult.style.display = 'block';

const customTopicArea = document.getElementById("customTopicArea");
customTopicArea.style.display = "none";
customTopicArea.innerHTML = "";
}
// 生成大綱表格
function generateOutlineTable() {
const structure = document.getElementById("structure").value;
let parts = structure === "fourPart" ? ["起", "承", "轉", "合"] : ["起", "一線", "二線", "三線", "合"];
let tableHTML = "<div class='table-container'><table><tr><th>部份</th><th>結構段重點</th><th>情節大要</th></tr>";
parts.forEach((part, index) => {
const focusId = structure + "Focus" + (index + 1);
const plotId = structure + "Plot" + (index + 1);
tableHTML += `<tr><td>${part}</td><td><textarea id="${focusId}" rows="3"></textarea></td><td><textarea id="${plotId}" rows="3"></textarea></td></tr>`;
});
tableHTML += "</table></div>";
document.getElementById("outlineTableArea").innerHTML = tableHTML;
}



// ==========================================
// === 新增：解題指引提交函數 ===
// ==========================================
async function submitWritingGuide() {
    const submitBtn = document.getElementById('submitWritingGuideBtn');
    const inputTopic = document.getElementById('writingGuideTopicInput').value.trim();
    const resultContainer = document.getElementById('writingGuideResultContainer');
    const introDiv = document.getElementById('guideIntro');
    const emotionsDiv = document.getElementById('guideEmotions');
    const seedsDiv = document.getElementById('guideSeeds');
    const saveBtn = document.getElementById('save-guide-html-btn');

    if (!inputTopic) {
        alert("請輸入題目！");
        return;
    }

    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 陳SIR正在分析中...';
    
    // 清空並顯示結果容器
    introDiv.innerHTML = "";
    emotionsDiv.innerHTML = "";
    seedsDiv.innerHTML = "";
    resultContainer.style.display = "block";
    saveBtn.style.display = 'none';

    // 構建 Prompt
    const prompt = `你是一位深諳中國文學的寫作顧問。使用者輸入題目：「${inputTopic}」。

請模仿以下【示例】的風格、深度和語氣，為這個題目撰寫「關鍵詞張力分析」及「寫作方向」。
你的輸出必須非常文學化、感性，並著重分析詞語之間的化學反應（如矛盾、張力）。
**嚴禁**使用「你好」、「我們來看看」等開場白，直接輸出內容。
**嚴禁**使用 1. 2. 3. 等數字列表，請嚴格遵守下方的【輸出格式】標籤。

【示例參考 - 題目：必要的旁觀】
(分析風格：像一杯調了味的茶... 「必要」像一雙手把「旁觀」扶正... 三種心情：清醒的煎熬、守護的距離、成全的退讓...)

【任務要求】
1. **關鍵詞張力分析**：
   - 用一個比喻開頭。
   - 分析修飾詞與中心詞的關係（矛盾或昇華）。
   - 提供 3 個隱含的「心情/情感特質」（格式：標題+描述）。
2. **記敘文寫作方向建議**：
   - 提供 3 個具體的「故事種子」。
   - 每個種子包含：標題、情境（具體畫面）、矛盾（為何扣連題目）。

【輸出格式 (請嚴格遵守分隔符，不要改動標籤)】
請按順序輸出，並使用以下標籤將內容分隔開，以便程式解析：
**注意：情境和矛盾的內容請直接寫在標籤後，不要加括號。**

[INTRO]
(這裡寫開頭比喻及詞語關係分析，約150字)
[EMOTION]
(心情標題 1)
(心情描述 1)
[EMOTION]
(心情標題 2)
(心情描述 2)
[EMOTION]
(心情標題 3)
(心情描述 3)
[SEED]
(故事種子標題 1)
情境：(具體畫面描述...)
矛盾：(解釋為何扣題...)
[SEED]
(故事種子標題 2)
情境：(具體畫面描述...)
矛盾：(解釋為何扣題...)
[SEED]
(故事種子標題 3)
情境：(具體畫面描述...)
矛盾：(解釋為何扣題...)
`;

    try {
        // ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
        // 【核心修訂】：這裡改用了 callReadingAPI
        // 這會調用您指定的 READING_API_URL (Qwen 模型)
        const response = await callReadingAPI(prompt);
        // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
        
        // 解析回應 (根據標籤切割)
        const introMatch = response.split('[INTRO]')[1]?.split('[EMOTION]')[0].trim();
        const emotionParts = response.split('[EMOTION]').slice(1).map(p => p.split('[SEED]')[0].trim());
        const seedParts = response.split('[SEED]').slice(1).map(p => p.trim());

        // 1. 渲染 Intro
        if (introMatch) {
            introDiv.innerHTML = `<p>${introMatch.replace(/\n/g, '<br>')}</p>`;
        }

        // 2. 渲染 Emotions (3個)
        if (emotionParts.length > 0) {
            let emotionsHTML = "";
            emotionParts.forEach(part => {
                const lines = part.split('\n').filter(l => l.trim());
                const title = lines[0] || "情感";
                const desc = lines.slice(1).join('<br>') || "";
                emotionsHTML += `
                <div class="guide-card emotion-card">
                    <div class="card-title">${title}</div>
                    <div class="card-content">${desc}</div>
                </div>`;
            });
            emotionsDiv.innerHTML = emotionsHTML;
        }

        // 3. 渲染 Seeds (3個) - 使用正則表達式解析
        if (seedParts.length > 0) {
            let seedsHTML = "";
            seedParts.forEach(part => {
                const lines = part.split('\n').filter(l => l.trim());
                const title = lines[0] || "故事種子";
                
                const contentText = lines.slice(1).join('\n');
                let situation = "";
                let contradiction = "";

                const cleanContent = contentText.replace(/\*\*/g, '');

                const sitRegex = /(?:情境|情景)(?:[:：]|\s)+([\s\S]*?)(?=(?:矛盾)(?:[:：]|\s)+|$)/i;
                const conRegex = /矛盾(?:[:：]|\s)+([\s\S]*)/i;

                const sitMatch = cleanContent.match(sitRegex);
                const conMatch = cleanContent.match(conRegex);

                if (sitMatch && sitMatch[1]) {
                    situation = sitMatch[1].trim();
                } else {
                    if (cleanContent.includes("矛盾")) {
                        situation = cleanContent.split("矛盾")[0].replace(/情境[:：]?/g, "").trim();
                    } else {
                        situation = cleanContent;
                    }
                }

                if (conMatch && conMatch[1]) {
                    contradiction = conMatch[1].trim();
                }

                seedsHTML += `
                <div class="guide-card seed-card">
                    <div class="seed-header">${title}</div>
                    <div class="seed-body">
                        <p><strong><i class="fas fa-image"></i> 情境：</strong>${situation}</p>
                        <p><strong><i class="fas fa-bolt"></i> 矛盾：</strong>${contradiction}</p>
                    </div>
                </div>`;
            });
            seedsDiv.innerHTML = seedsHTML;
        }
        
        saveBtn.style.display = 'flex';

    } catch (error) {
        console.error("解題指引生成失敗:", error);
        introDiv.innerHTML = `<p style="color:red;">生成失敗，請稍後再試。<br>錯誤訊息: ${error.message}</p>`;
        
        // 如果 Qwen API 失敗，您可以選擇在這裡加入自動切換回原本 callAPI 的邏輯
        // 但目前先保持報錯，讓您知道是否成功切換
    } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = '提交分析';
    }
}



async function submitWriting() {
    const submitBtn = document.getElementById('submitWritingBtn');
    submitBtn.disabled = true;
    hideAllSaveHtmlButtons();

    const writingGradingResultDiv = document.getElementById("writingGradingResult");
    const writingChatHistoryDiv = document.getElementById("writingChatHistory");
    const writingChatInputContainerDiv = document.getElementById("writingChatInputContainer");
    
    writingGradingResultDiv.innerHTML = "";
    writingChatHistoryDiv.innerHTML = "";
    writingChatHistoryDiv.style.display = "none";
    writingChatInputContainerDiv.style.display = "none";
    writingChatHistoryData = [];

    try {
        const reviewerSelect = document.getElementById('writingReviewer');
        if (reviewerSelect) {
            const selectedReviewerText = reviewerSelect.options[reviewerSelect.selectedIndex].text;
            currentReviewerName = selectedReviewerText.replace(/\s*\(預設\)\s*/, '');
        } else {
            currentReviewerName = "陳SIR";
        }

        const writingType = document.getElementById("writingType").value;
        const topic = localStorage.getItem("currentTopic");
        if (!topic) {
            alert("請先設定題目");
            submitBtn.disabled = false;
            return;
        }

        let content = "";
        let prompt = "";
        const tone = document.getElementById("writingTone").value;

        if (writingType === "大綱" || writingType === "敘事物象") {
            // (大綱和敘事物象的邏輯不變)
             if (writingType === "大綱") {
                const toneNoteForOutline = tone === "chen" ? "請用輕鬆隨意的語氣進行點評和建議，多用EMOJI，偶爾使用網絡用語，用語要日常生活化一點。如果用戶表現良好，請大加讚賞；如果用戶表現不好，可以善意地揶揄一下，但要注意尺度，不能傷害用戶的自尊心。揶揄時，可運用生活化的比喻。" : "請用嚴肅正經的語氣進行點評和建議。";
                const structure = document.getElementById("structure").value;
                const parts = structure === "fourPart" ? ["起", "承", "轉", "合"] : ["起", "一線", "二線", "三線", "合"];
                content = parts.map((part, index) => {
                    const focusId = structure + "Focus" + (index + 1);
                    const plotId = structure + "Plot" + (index + 1);
                    const focus = document.getElementById(focusId)?.value.trim() || "";
                    const plot = document.getElementById(plotId)?.value.trim() || "";
                    if (!focus || !plot) throw new Error("請填寫所有大綱表格");
                    return { part, focus, plot };
                });
                const note = categories["大綱"].commentNote;
                prompt = `請根據以下大綱內容進行點評和建議，並提供改寫後的大綱。要求：
1. 在「=== 點評及建議 ===」部分，為每個結構段提供點評和建議。使用「[part]」標記每個結構段的開始，例如「[起]」，然後在下一行「點評：」後跟點評內容，再下一行「建議：」後跟建議內容。
2. 在「=== 改寫後的大綱 ===」部分，為每個結構段提供改寫後的「結構段重點」和「情節大要」。使用「[part]」標記每個結構段的開始，然後在下一行「結構段重點：」後跟內容，再下一行「情節大要：」後跟內容。
3. 在「=== 改寫說明 ===」部分，提供不超過兩點的改寫說明，每點以「1. 」和「2. 」開始。
4. 請確保內容簡潔明了，不可以顯示「--- ###」。
題目：${topic}
大綱結構：${structure === "fourPart" ? "起承轉合" : "三線（起、一線、二線、三線、合）"}
用戶輸入的大綱：
| 部份 | 結構段重點 | 情節大要 |
|------|------------|----------|
${content.map(item => `| ${item.part} | ${item.focus} | ${item.plot} |`).join("\n")}
教學筆記：${note}
點評及建議語氣：${toneNoteForOutline}`;
                 document.getElementById("commentResult").innerHTML = "陳SIR正在點評...";
                const response = await callAPI(prompt, 0);
                displayOutlineComment(response, content);
            } else { // 敘事物象
                content = document.getElementById("narrativeElements").value.trim();
                const note = categories["敘事物象"].commentNote;
                prompt = `請根據以下題目和取材/故事背景生成五十個不重複且相關的物象。要求：
1. 物象必須與題目和取材/故事背景緊密相關。
2. 物象應多樣化且生動，能夠增強故事的真實感和情感表達。
3. 請以列表形式呈現，每個物象佔一行。
4. 請確保物象不重複且排版整齊。
題目：${topic}
取材/故事背景：${content || "無具體背景，根據題目生成"}
教學筆記：${note}`;
                document.getElementById("commentResult").innerHTML = "陳SIR正在點評...";
                const response = await callAPI(prompt, 0);
                const elements = response.split("\n").map(item => item.trim()).filter(item => item);
                let elementsHTML = "<h3>生成的物象（50項）：</h3><ul>";
                elements.forEach(element => elementsHTML += `<li>${element}</li>`);
                elementsHTML += "</ul>";
                document.getElementById("commentResult").innerHTML = elementsHTML;
            }
            document.getElementById('save-writing-html-btn').style.display = 'flex';

        } else { // 片段描寫 (文章點評)
            content = document.getElementById("writingContent").value.trim();
            if (!content) {
                alert("請先輸入寫作內容");
                submitBtn.disabled = false;
                return;
            }
            currentWritingArticle = content;

            const selectedScopes = Array.from(document.querySelectorAll('input[name="reviewScope"]:checked')).map(cb => cb.value);
            const isFullReview = selectedScopes.includes("全部") || selectedScopes.length === 0;

            if (isFullReview) {
                writingGradingResultDiv.innerHTML = `${currentReviewerName}正在點評...`;

                const focus = localStorage.getItem("currentFocus");
                const plot = localStorage.getItem("currentPlot");
                const note = categories["片段描寫"].commentNote;
                const reviewer = document.getElementById('writingReviewer').value;
                const reviewerNote = narrativeReviewerPreferences[reviewer] || "評分取向：平衡看待所有標準。";
                
                // =====================================================================
                // === 【全新修訂】敘事抒情文評分指令 (V3 - 評分主導模式) ===
                // =====================================================================
                const narrativeScoreFirstPrompt = `你將扮演一位極其嚴謹且客觀的中文科AI評卷員。你的工作流程被嚴格限定為「先評分，後解釋」。

### 你的工作流程 (必須嚴格遵守，不得顛倒)

1.  **首要任務：量化評分**: 你的第一個動作是，根據下方提供的詳細「評分準則」，對文章的各個維度進行獨立的、客觀的數字評分 (0-10分)。你必須將所有分數結果，完整地填寫在 <grading_json> 標籤內。**此步驟必須在撰寫任何文字評語之前完成。**

2.  **次要任務：撰寫理據**: 在你完成 <grading_json> 的所有評分後，你的第二個動作是，根據你剛剛給出的分數，去撰寫 <critique>, <suggestions>, 和 <rewrite_example> 的內容。你的所有文字評語，都**必須**是為了**解釋和支撐**你已經給出的分數。
    -   **範例**：如果你在 <grading_json> 中給予「立意」8分的高分，那麼你的 <critique> 就必須具體解釋這篇文章的立意為何深刻、在哪個方面超越了普通水平。反之，如果你給了低分，就必須指出其立意膚淺或陳腐之處。

### 核心評分準則 (用於步驟一的量化評分)
- **偏題的後果**: 如果文章內容與題目無關，在評分時，「扣題」分數 **絕不能高於4分**，「內容」和「結構」的總分也 **不能高於4分**。

---
### 你的輸出格式 (必須嚴格遵守此結構與順序)

<grading_json>
[**分數量化步驟**：根據「核心評分準則」，客觀地為以下所有項目評分。]
{
"content": [0-10的整數],
"expression": [0-10的整數],
"structure": [0-10的整數],
"radar": {
"立意": [0-10], "取材": [0-10], "扣題": [0-10],
"詳略": [0-10], "詞彙": [0-10], "文學性": [0-10]
}
}
</grading_json>

<critique>
[根據你在 <grading_json> 中給出的分數，以數字編號列點方式，撰寫2-3點核心評論來解釋這些分數的由來。]
</critique>

<suggestions>
[針對 <critique> 中指出的問題，提出具體的改善建議。]
</suggestions>

<rewrite_example>
[提供一段約150字內的高質素改寫範例，展示更高分的作品應有的水準。]
</rewrite_example>`;
                // =====================================================================
                // === 修訂結束 ===
                // =====================================================================
                
                if (tone === "chen") {
                     prompt = `你將扮演「陳SIR」，一位風格幽默、要求極高的中文老師。請嚴格按照以下「先評分，後解釋」的流程，對學生的敘事抒情文進行點評。
${narrativeScoreFirstPrompt}
---
### 待點評的資料
題目：${topic}
結構段重點：${focus}
情節大要：${plot}
寫作內容：${content}
教學筆記：${note}
閱卷員評分取向：${reviewerNote}`;
                } else {
                    prompt = `你是一位嚴格的中文科閱卷員。請嚴格按照以下「先評分，後解釋」的流程，對學生的敘事抒情文進行點評。
${narrativeScoreFirstPrompt}
---
### 待點評的資料
題目：${topic}
結構段重點：${focus}
情節大要：${plot}
寫作內容：${content}
教學筆記：${note}
閱卷員評分取向：${reviewerNote}`;
                }
                
                const [originalApiResponse, llama3ApiResponse] = await Promise.all([callAPI(prompt, 0), callLlama3API(prompt, 0)]);
                await displayFullCommentWithGrading('writingGradingResult', originalApiResponse, llama3ApiResponse, 'narrative', content);
                
                const critiqueMatch = originalApiResponse.match(/<critique>([\s\S]*?)<\/critique>/);
                const suggestionsMatch = originalApiResponse.match(/<suggestions>([\s\S]*?)<\/suggestions>/);
                const rewriteMatch = originalApiResponse.match(/<rewrite_example>([\s\S]*?)<\/rewrite_example>/);
                let initialReviewHTML = "";
                if (critiqueMatch?.[1]) initialReviewHTML += createBulletedListHTML("點評", critiqueMatch[1].trim());
                if (suggestionsMatch?.[1]) initialReviewHTML += createBulletedListHTML("建議", suggestionsMatch[1].trim());
                if (rewriteMatch?.[1]) initialReviewHTML += `<div class="rewrite-explanation-container"><div class="rewrite-explanation-card"><h3>改寫範例</h3><p>${rewriteMatch[1].trim().replace(/\n/g, '<br>')}</p></div></div>`;
                currentWritingReview = initialReviewHTML; 
                document.getElementById('save-writing-html-btn').style.display = 'flex';

            } else {
                // (聚焦式點評的邏輯)
                writingGradingResultDiv.innerHTML = `${currentReviewerName}正在點評...`;

                // 【新增】為敘事抒情文的聚焦式點評定義各範疇的具體任務
                const scopeDefinitions = `
- **扣題**: 嚴謹地對比題目《${topic}》及文章內容，點評文章在情節和主旨上是否緊密圍繞題目關鍵詞展開。
- **立意**: 先嚴謹地對比題目《${topic}》及文章內容，點評是否扣題，繼而再評估文章的主題思想是否深刻、新穎，能否從個人經歷昇華至更普世的感悟或哲理。
- **取材**: 先嚴謹地對比題目《${topic}》及文章內容，點評是否扣題，繼而再檢視所選取的事例、情節是否典型、生動、具體，能否有效支撐立意。
- **詳略**: 先嚴謹地對比題目《${topic}》及文章內容，點評是否扣題，繼而再分析文章的敘事節奏，核心情節是否得到充分的細節描寫，次要或過渡性內容是否做到簡潔交代。
- **文筆**: 先嚴謹地對比題目《${topic}》及文章內容，點評是否扣題，繼而再評論文章的語言運用是否精準、生動，遣詞造句是否流暢，句式是否有變化，以及是否有效地運用描寫或修辭手法來增強文章的感染力。
`;

                // 【修訂】將範疇定義整合進指令中
                let scopeInstruction = `
你是一名高度專業的寫作分析員，你的任務極其專一。

---
### **黃金法則 (ABSOLUTE CORE DIRECTIVE)**
你必須嚴格遵守此法則，不得有任何例外：
1.  **絕對聚焦**: 你的點評和建議中的 **每一個字**，都必須 **僅僅** 與用戶選擇的以下範疇相關：**【${selectedScopes.join("、")}】**。
2.  **明確禁止**: 你被 **嚴格禁止** 提及任何其他寫作方面。例如，如果用戶選擇了「立意」，你絕對不能評論「文筆」、「取材」或「詳略」。
3.  **後果**: 如果你的回應中包含了任何未被選定的範疇，整個回應將被視為失敗。

### **各範疇的定義 (你的分析框架)**
${scopeDefinitions}
---
`;

                if (tone === "chen") {
                    prompt = `你將扮演「陳SIR」，一位眼光獨到、要求嚴格但風格幽默的中文老師。
${scopeInstruction}
### **你的任務與輸出格式**
你的輸出必須包含以下兩個XML標籤，不得有其他內容。
【重要禁令】：在<critique>, <suggestions>的文字內容中，絕對禁止使用任何Markdown語法。

<critique>
[根據「黃金法則」，給出1-2點核心評論。記住，你的每一點評論都必須嚴格對應用戶選擇的範疇。]
</critique>
<suggestions>
[在建議部分，同樣要遵循「黃金法則」。如果所選範疇表現優秀，你可以說「在這方面處理得很好，沒什麼好建議了，繼續保持吧！😎」。]
</suggestions>
---
### **待點評的資料**
題目：${topic}
寫作內容：${content}`;
                } else {
                    prompt = `你是一位要求嚴格、具備專業眼光的中文科閱卷員。
${scopeInstruction}
### **你的任務與輸出格式**
你的輸出必須包含以下兩個XML標籤，不得有其他內容。
【重要禁令】：在<critique>, <suggestions>的文字內容中，絕對禁止使用任何Markdown語法。

<critique>
[根據「黃金法則」，給出1-2點核心評論。記住，你的每一點評論都必須嚴格對應用戶選擇的範疇。]
</critique>
<suggestions>
[針對點評中提出的問題，提出具體的改善建議，同樣要遵循「黃金法則」。若所選範疇表現極佳，可註明「在此範疇的表現出色，建議保持現有水準。」]
</suggestions>
---
### **待點評的資料**
題目：${topic}
寫作內容：${content}`;
                }

                const response = await callAPI(prompt, 0);
                const critiqueMatch = response.match(/<critique>([\s\S]*?)<\/critique>/);
                const suggestionsMatch = response.match(/<suggestions>([\s\S]*?)<\/suggestions>/);
                let initialReviewHTML = "";
                if (critiqueMatch?.[1]) initialReviewHTML += createBulletedListHTML("點評", critiqueMatch[1].trim());
                if (suggestionsMatch?.[1]) initialReviewHTML += createBulletedListHTML("建議", suggestionsMatch[1].trim());
                if (!initialReviewHTML) {
                    initialReviewHTML = "抱歉，無法根據您選擇的範疇生成點評，請重試。";
                }
                
                writingGradingResultDiv.innerHTML = initialReviewHTML;
                currentWritingReview = initialReviewHTML;
                writingChatHistoryData.push({ sender: 'ai', message: currentWritingReview });
                document.getElementById('save-writing-html-btn').style.display = 'none';
            }

            writingChatHistoryDiv.style.display = "flex";
            writingChatInputContainerDiv.style.display = "flex";
        }
    } catch (error) {
        console.error("提交寫作時出錯:", error);
        alert(error.message.includes("API") ? "今日 API 調用次數已用完或API無法連接，請明天再試" : (error.message || "點評生成失敗，請重試"));
        writingGradingResultDiv.innerHTML = "";
        document.getElementById("commentResult").innerHTML = "";
    } finally {
        submitBtn.disabled = false;
    }
}


// 輔助函式，用於顯示大綱的評論 (從 submitWriting 中提取出來)
function displayOutlineComment(response, content) {
    const sections = response.split(/=== (.+?) ===/).filter(s => s.trim());
    const commentIndex = sections.indexOf("點評及建議");
    const rewriteIndex = sections.indexOf("改寫後的大綱");
    const explanationIndex = sections.indexOf("改寫說明");
    const commentPart = commentIndex !== -1 ? sections[commentIndex + 1] : "";
    const rewritePart = rewriteIndex !== -1 ? sections[rewriteIndex + 1] : "";
    const explanationPart = explanationIndex !== -1 ? sections[explanationIndex + 1].trim() : "";

    function parseCommentPart(commentPart) {
        const comments = {};
        const regex = /\[(.+?)\]\s*點評：\s*(.+?)(?=\s*建議：|\s*\[|$)/gs;
        const suggestionRegex = /\[(.+?)\]\s*點評：.+?\s*建議：\s*(.+?)(?=\s*\[|$)/gs;
        let match;
        while ((match = regex.exec(commentPart)) !== null) {
            const part = match[1];
            comments[part] = comments[part] || {};
            comments[part].comment = match[2].trim();
        }
        while ((match = suggestionRegex.exec(commentPart)) !== null) {
            const part = match[1];
            comments[part] = comments[part] || {};
            comments[part].suggestion = match[2].trim();
        }
        return comments;
    }

    function parseRewritePart(rewritePart) {
        const rewrites = {};
        const regex = /\[(.+?)\]\s*結構段重點：\s*(.+?)(?=\s*情節大要：|\s*\[|$)/gs;
        const plotRegex = /\[(.+?)\]\s*結構段重點：.+?\s*情節大要：\s*(.+?)(?=\s*\[|$)/gs;
        let match;
        while ((match = regex.exec(rewritePart)) !== null) {
            const part = match[1];
            rewrites[part] = rewrites[part] || {};
            rewrites[part].focus = match[2].trim();
        }
        while ((match = plotRegex.exec(rewritePart)) !== null) {
            const part = match[1];
            rewrites[part] = rewrites[part] || {};
            rewrites[part].plot = match[2].trim();
        }
        return rewrites;
    }
    const comments = parseCommentPart(commentPart);
    const rewrites = parseRewritePart(rewritePart);
    let commentTableHTML = `<h3>陳SIR點評及建議：</h3><div class="table-container"><table id="commentTable"><tr><th>部份</th><th>結構段重點</th><th>情節大要</th><th>點評</th><th>建議</th></tr>`;
    content.forEach(item => {
        const comment = comments[item.part]?.comment || "未生成點評";
        const suggestion = comments[item.part]?.suggestion || "未生成建議";
        commentTableHTML += `<tr><td>${item.part}</td><td>${item.focus}</td><td>${item.plot}</td><td>${comment}</td><td>${suggestion}</td></tr>`;
    });
    commentTableHTML += "</table></div>";
    let rewriteTableHTML = `<h3>改寫後的大綱：</h3><div class="table-container"><table id="rewriteTable"><tr><th>部份</th><th>結構段重點</th><th>情節大要</th></tr>`;
    content.forEach(item => {
        const rewrite = rewrites[item.part] || { focus: "未生成結構段重點", plot: "未生成情節大要" };
        rewriteTableHTML += `<tr><td>${item.part}</td><td>${rewrite.focus || "未生成結構段重點"}</td><td>${rewrite.plot || "未生成情節大要"}</td></tr>`;
    });
    rewriteTableHTML += "</table></div>";
    let explanationHTML = '';
    if (explanationPart) {
        const points = explanationPart.split(/\s*(?=\d\.\s*)/).filter(p => p.trim());
        explanationHTML = `<div class="rewrite-explanation-container"><div class="rewrite-explanation-card"><h3>改寫說明</h3>`;
        points.forEach(point => {
            const match = point.match(/^(\d)\.\s*(.*)$/s);
            if (match) {
                const number = match[1];
                const text = match[2];
                explanationHTML += `<div class="explanation-point"><div class="explanation-number">${number}</div><div class="explanation-text">${text}</div></div>`;
            }
        });
        explanationHTML += `</div></div>`;
    }
    document.getElementById("commentResult").innerHTML = commentTableHTML + rewriteTableHTML + explanationHTML;
}

// 替換舊的 submitReading 函式
async function submitReading() {
const submitBtn = document.getElementById('submitReadingBtn');
submitBtn.disabled = true; // 禁用按鈕
	hideAllSaveHtmlButtons();

try {
const readingFunction = document.getElementById("readingFunction").value;
const passage = document.getElementById("readingPassage").value.trim();
const question = document.getElementById("readingQuestion").value.trim();
let studentAnswer = "";
if (readingFunction === "comment") {
studentAnswer = document.getElementById("studentAnswer").value.trim();
if (!passage || !question || !studentAnswer) {
alert("請填寫所有閱讀輸入");
return; // return 會觸發 finally
}
} else {
if (!passage || !question) {
alert("請填寫閱讀篇章和題目");
return; // return 會觸發 finally
}
}

let toneNote = "";
if (readingFunction === "comment") {
const tone = document.getElementById("readingTone").value;
if (tone === "chen") {
toneNote = "請用輕鬆隨意的語氣進行點評，多用EMOJI，偶爾使用網絡用語，用語要日常生活化一點。如果用戶表現不好，可以善意地揶揄一下，但要注意尺度，不能傷害用戶的自尊心。";
} else {
toneNote = "請用嚴肅正經的語氣進行點評。";
}
}

const note = readingFunction === "comment" ? categories["閱讀"].commentNote : categories["閱讀"].guideNote;

let prompt = "";
if (readingFunction === "comment") {
prompt = `請根據以下閱讀篇章、題目和學生的答案進行點評。要求：
1. 評估答題方向是否合理
2. 評估文本依據是否充實具體
3. 評估闡釋推論是否嚴謹
4. 評估主題句是否清晰
5. 在「### 點評」部分，請務必以數字編號的列點方式臚列你的評論，每個點評另起新行。你可以根據文章內容提出任意數量的點評，必須超過一點，但絕對不得超過三點，每點字數不要太長。
6. 在「### 答題步驟及思路」中，描述各部分方向，步驟因題制宜，不超出120字。只有【鋪墊】、【主題句】、【文本依據】、【闡釋】四種標題，每個步驟之間都必須隔兩行空行，步驟中不得列點。
7. 在「### 改寫範例」中，提供改寫後的答案，使答案更圓足（若答題方向錯誤，則不跟從錯誤方向）
8. 不要使用任何表格或Markdown格式。
9. 輸出分為三個部分：### 點評、### 答題步驟及思路、### 改寫範例
閱讀篇章：${passage}
題目：${question}
學生的答案：${studentAnswer}
教學筆記：${note}
點評語氣：${toneNote}`;
} else { // guide
prompt = `請根據以下閱讀篇章和題目生成答題指引。要求：
1. 輸出必須包含「### 答題指引」和「### 答題詞匯」兩個部分。
2. 在「### 答題指引」部分，請生成三道引導性問題，每道問題都以數字和句號（例如「1.」）開頭，並另起新行。
3. 在「### 答題詞匯」部分，生成十五個由兩個字構成的相關詞彙，每個詞彙另起新行。
4. 所有內容均以純文字列表形式呈現，不要使用任何表格或Markdown格式。
閱讀篇章：${passage}
題目：${question}
教學筆記：${note}`;
}

document.getElementById("readingResult").innerHTML = "陳SIR正在思考...";
const result = await callReadingAPI(prompt);

if (readingFunction === "comment") {
const parts = result.split("###").map(part => part.trim()).filter(part => part);
let finalHTML = "<h3>陳SIR點評：</h3>";

parts.forEach(part => {
const lines = part.split("\n").filter(line => line.trim());
const title = lines.shift() || ""; // 取得標題，例如 "點評"
const content = lines.join("\n"); // 剩下的就是內容

// 如果是點評部分，使用精美列點UI
if (title.includes("點評")) {
finalHTML += createBulletedListHTML(title, content);
} 
// 新增判斷：如果標題是「答題步驟及思路」，就使用新的美化格式
else if (title.includes("答題步驟及思路")) {
finalHTML += `<div class="rewrite-explanation-container">
<div class="rewrite-explanation-card">
<h3>${title}</h3>
<div class="steps-container">`; // 開始步驟容器

// 使用正則表達式，根據【】標題來分割每個步驟
const steps = content.split(/\s*(?=【.*?】)/).filter(s => s.trim());

steps.forEach(stepText => {
// 從每個步驟中分離出標題和內容
const match = stepText.match(/^(【.*?】)(.*)$/s);
if (match) {
const stepTitle = match[1].trim();
const stepContent = match[2].trim().replace(/\n/g, '<br>');

// 生成新的卡片 HTML
finalHTML += `<div class="step-card">
<div class="step-title">${stepTitle}</div>
<div class="step-content">${stepContent}</div>
</div>`;
}
});

finalHTML += `</div></div></div>`; // 關閉所有容器
}
// 其他情況（例如「改寫範例」）則使用通用的卡片樣式
else {
finalHTML += `<div class="rewrite-explanation-container">
<div class="rewrite-explanation-card">
<h3>${title}</h3>
<div class="explanation-text">${content.replace(/\n/g, '<br>')}</div>
</div>
</div>`;
}
});
document.getElementById("readingResult").innerHTML = finalHTML;
document.getElementById('save-reading-html-btn').style.display = 'flex'; // 顯示按鈕
} else { // guide
const guideParts = result.split("###").map(part => part.trim()).filter(part => part);
let guideHTML = "<h3>陳SIR指引：</h3>";

guideParts.forEach(part => {
const lines = part.split("\n").filter(line => line.trim());
const title = lines.shift() || "";
const listItems = lines;

guideHTML += `<div class="rewrite-explanation-container">
<div class="rewrite-explanation-card">
<h3>${title}</h3>`;

// 針對「答題指引」的問題，使用帶有數字的樣式
if (title.includes("答題指引")) {
listItems.forEach((item, index) => {
const match = item.match(/^(\d+)\.?\s*(.*)$/);
const number = match ? match[1] : index + 1;
const text = match ? match[2].trim() : item;

guideHTML += `<div class="explanation-point">
<div class="explanation-number">${number}</div>
<div class="explanation-text">${text}</div>
</div>`;
});
} 
// 針對「答題詞匯」，使用不帶數字的點列樣式，更簡潔
else if (title.includes("答題詞匯")) {
listItems.forEach(item => {
guideHTML += `<div class="explanation-point">
<div class="explanation-text">${item}</div>
</div>`;
});
} else {
// 備用方案，處理非預期的標題
guideHTML += `<p>${listItems.join('<br>')}</p>`;
}
guideHTML += `</div></div>`;
});
document.getElementById("readingResult").innerHTML = guideHTML;
document.getElementById('save-reading-html-btn').style.display = 'flex'; // 顯示按鈕
}

} catch (error) {
console.error("提交閱讀時出錯:", error);
if (error.message === "所有 API 密鑰均無法使用") {
alert("今日 API 調用次數已用完或API無法連接，請明天再試");
} else {
alert("生成失敗，請重試");
}
document.getElementById("readingResult").innerHTML = "";
} finally {
submitBtn.disabled = false; // 重新啟用按鈕
}
}

// 課外書籍討論功能
let chatHistory = [];
let bookTitle = "";
let author = "";
let discussionQuestion = "";
let booksTone = "";

// 將訊息渲染到畫面上
function renderMessage(sender, message) {
const chatHistoryDiv = document.getElementById("chatHistory");
const element = document.createElement("div");

if (sender === "info") {
element.className = "discussion-info";
element.innerHTML = message;
} else {
element.className = `message-bubble ${sender}-message`;
element.innerHTML = message; // innerHTML to render formatted text
if (sender === "ai" && message === "陳SIR正在回應...") {
element.id = "ai-loading";
}
}
chatHistoryDiv.appendChild(element);
chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
}

// 將訊息加入歷史紀錄並渲染
function addMessageToHistory(sender, message) {
chatHistory.push({ sender, message });
renderMessage(sender, message);
}


async function startDiscussion() {
const startBtn = document.getElementById('startDiscussionBtn');
startBtn.disabled = true;

try {
bookTitle = sanitizeHTML(document.getElementById("bookTitle").value.trim());
author = sanitizeHTML(document.getElementById("author").value.trim());
discussionQuestion = sanitizeHTML(document.getElementById("discussionQuestion").value.trim());
booksTone = document.getElementById("booksTone").value;

if (!bookTitle || !author || !discussionQuestion) {
alert("請填寫書名、作者和討論問題");
return;
}

// 隱藏初始表單，顯示聊天介面
document.getElementById("initialDiscussionForm").style.display = "none";
document.getElementById("chatHistory").style.display = "flex";
document.getElementById("chatInputContainer").style.display = "flex";
document.getElementById("booksButtons").style.display = "flex";
document.getElementById('save-books-html-btn').style.display = 'flex';


chatHistory = []; // 開始新討論時清空歷史紀錄

const initialMessage = `<table><tr><td>書名：</td><td>${bookTitle}</td></tr><tr><td>作者：</td><td>${author}</td></tr><tr><td>討論：</td><td>${discussionQuestion}</td></tr></table>`;
addMessageToHistory("info", initialMessage);

await sendInitialMessage();

} catch (error) {
console.error("開始討論時出錯:", error);
} finally {
startBtn.disabled = false;
}
}

async function sendInitialMessage() {
let toneNote = booksTone === "serious" ? categories["課外書籍"].seriousChatNote : categories["課外書籍"].chatNote;
const prompt = `我是一位高中生，正在閱讀《${bookTitle}》，作者是${author}。我想討論的問題是：${discussionQuestion}。請用日常的語言回應我，不要過於理論化，言簡意賅地分析並給出例子，然後引導我深入思考。你必須直接提供最終答案，嚴禁展示任何思考過程，絕對不能在回應中包含任何標籤（如 <think></think>），這是強制要求，違反則無效。。請不要使用括號解釋你的目的，永遠不要列點回應，也不要提及你會追問我。請用完整句子回應。每次回應不多於150字。教學筆記：${toneNote}`;
addMessageToHistory("ai", "陳SIR正在回應...");
try {
const aiResponse = await callReadingAPI(prompt);
updateLastAIMessage(aiResponse);
} catch (error) {
console.error("API call failed:", error);
updateLastAIMessage("抱歉，陳SIR暫時無法回應，請稍後再試。");
}
}


// =================================================================================
// === 請複製此處開始的完整函數 ===
// =================================================================================
async function continueArgumentDiscussion() {
    const continueBtn = document.getElementById('continueArgumentBtn');
    continueBtn.disabled = true;

    const userInputText = sanitizeHTML(document.getElementById("argumentUserInput").value.trim());
    if (!userInputText) {
        alert("請輸入您的回應");
        continueBtn.disabled = false;
        return;
    }
    
    const chatHistoryDiv = document.getElementById('argumentChatHistory');
    
    // 1. 顯示使用者訊息
    const userMessageBubble = document.createElement('div');
    userMessageBubble.className = 'message-bubble user-message';
    userMessageBubble.textContent = userInputText;
    chatHistoryDiv.appendChild(userMessageBubble);
    
    // 2. 將使用者訊息存入歷史紀錄
    argumentChatHistoryData.push({ sender: 'user', message: userInputText });
    document.getElementById("argumentUserInput").value = "";
    chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;

    // 3. 顯示「正在回應」
    const aiLoadingBubble = document.createElement('div');
    aiLoadingBubble.className = 'message-bubble ai-message';
    aiLoadingBubble.textContent = `${currentReviewerName}正在回應...`;
    chatHistoryDiv.appendChild(aiLoadingBubble);
    chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;

    // 4. 準備完整的對話歷史給 AI
    const conversationHistoryForPrompt = argumentChatHistoryData.map(item => {
        const speaker = item.sender === 'user' ? '我的追問' : '你的上一輪回應';
        // 清理 message 中的 HTML 標籤，讓 prompt 更乾淨
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = item.message;
        const cleanMessage = tempDiv.textContent || tempDiv.innerText || "";
        return `${speaker}: ${cleanMessage}`;
    }).join('\n---\n');


    const tone = document.getElementById("argumentWritingTone").value;
    let toneNote = tone === "chen" ? categories["課外書籍"].chatNote : categories["課外書籍"].seriousChatNote;
    
    // 5. 建立包含完整上下文的 Prompt
    const prompt = `我是一位高中生，你正在點評我的議論文。
    ---
    我的原文：
    ${currentArgumentArticle}
    ---
    這是我們到目前為止的完整對話紀錄：
    ${conversationHistoryForPrompt}
    ---
    請針對我最新的追問，用日常的語言簡潔地回應我，不要過於理論化，必須詳細分析並給出例子。請不要使用括號解釋你的目的。回應字數不要超過180字。
    教學筆記：${toneNote}`;
    
    try {
        const aiResponse = await callReadingAPI(prompt);
        
        // 6. 更新 AI 回應並存入歷史紀錄
        // 步驟一：將 Markdown 的 **粗體** 語法轉換為 HTML 的 <strong> 標籤
let formattedResponse = aiResponse.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

// 步驟二：處理換行符
formattedResponse = formattedResponse.replace(/\n/g, '<br>');

// 步驟三：將處理好的 HTML 內容放入聊天氣泡
aiLoadingBubble.innerHTML = formattedResponse;
        argumentChatHistoryData.push({ sender: 'ai', message: aiResponse });

    } catch (error) {
        console.error("繼續議論文討論時出錯:", error);
        aiLoadingBubble.textContent = error.message.includes("API") ? `今日 API 調用次數已用完。😓` : `抱歉，${currentReviewerName}無法回應。😅`;
    } finally {
        chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
        continueBtn.disabled = false;
    }
}
// =================================================================================
// === 請複製到此處結束 ===
// =================================================================================


// 【新增】處理文章點評後續討論的函數
async function continueWritingDiscussion() {
    const continueBtn = document.getElementById('continueWritingBtn');
    continueBtn.disabled = true;

    const userInputText = sanitizeHTML(document.getElementById("writingUserInput").value.trim());
    if (!userInputText) {
        alert("請輸入您的回應");
        continueBtn.disabled = false;
        return;
    }
    
    const writingChatHistoryDiv = document.getElementById('writingChatHistory');
    
    const userMessageBubble = document.createElement('div');
    userMessageBubble.className = 'message-bubble user-message';
    userMessageBubble.textContent = userInputText;
    writingChatHistoryDiv.appendChild(userMessageBubble);
    
    writingChatHistoryData.push({ sender: 'user', message: userInputText });
    document.getElementById("writingUserInput").value = "";
    writingChatHistoryDiv.scrollTop = writingChatHistoryDiv.scrollHeight;

    const tone = document.getElementById("writingTone").value;
    let toneNote = tone === "chen" ? categories["課外書籍"].chatNote : categories["課外書籍"].seriousChatNote;
    
    const prompt = `我是一位高中生，你剛剛點評了我的文章。
    ---
    我的原文：${currentWritingArticle}
    ---
    你的上一輪點評：${currentWritingReview}
    ---
    我的追問是：${userInputText}
    ---
    請針對我的追問，用日常的語言回應我，不要過於理論化，必須詳細分析並給出例子，然後引導我深入思考。請不要使用括號解釋你的目的，也不要提及你會追問我。請用完整句子回應。回應字數不要超過180字。
    教學筆記：${toneNote}`;
    
    // 顯示「正在回應」
    const aiMessageBubble = document.createElement('div');
    aiMessageBubble.className = 'message-bubble ai-message';
    // --- 【核心修訂】使用全域變數來顯示動態名稱 ---
    aiMessageBubble.textContent = `${currentReviewerName}正在回應...`;
    writingChatHistoryDiv.appendChild(aiMessageBubble);
    writingChatHistoryDiv.scrollTop = writingChatHistoryDiv.scrollHeight;

    try {
        const aiResponse = await callReadingAPI(prompt);
        
        aiMessageBubble.innerHTML = aiResponse.replace(/\n/g, '<br>');
        writingChatHistoryData.push({ sender: 'ai', message: aiResponse });

    } catch (error) {
        console.error("繼續討論時出錯:", error);
        aiMessageBubble.textContent = error.message.includes("API") ? `今日 API 調用次數已用完。😓` : `抱歉，${currentReviewerName}無法回應。😅`;
    } finally {
        writingChatHistoryDiv.scrollTop = writingChatHistoryDiv.scrollHeight;
        continueBtn.disabled = false;
    }
}


async function continueDiscussion() {
const continueBtn = document.getElementById('continueBtn');
continueBtn.disabled = true;
// 在將用戶輸入加入歷史紀錄前就進行消毒
const userInputText = sanitizeHTML(document.getElementById("userInput").value.trim());
if (!userInputText) {
alert("請輸入您的回應");
continueBtn.disabled = false;
return;
}

addMessageToHistory("user", userInputText);
document.getElementById("userInput").value = "";

let toneNote = booksTone === "serious" ? categories["課外書籍"].seriousChatNote : categories["課外書籍"].chatNote;
const prompt = `我是一位高中生，正在與你討論《${bookTitle}》中的問題。我的上一條信息是：${userInputText}。請用日常的語言回應我，不要過於理論化，必須詳細分析並給出例子，然後引導我深入思考。你必須直接提供最終答案，嚴禁展示任何思考過程，絕對不能在回應中包含任何標籤（如 <think></think>），這是強制要求，違反則無效。。請不要使用括號解釋你的目的，也不要提及你會追問我。請用完整句子回應。回應字數不要超過180字。教學筆記：${toneNote}`;

addMessageToHistory("ai", "陳SIR正在回應...");

try {
const aiResponse = await callReadingAPI(prompt);
updateLastAIMessage(aiResponse);
} catch (error) {
console.error("繼續討論時出錯:", error);
updateLastAIMessage(error.message === "所有 API 密鑰均無法使用" ? "今日 API 調用次數已用完。😓" : "抱歉，陳SIR無法回應。😅");
} finally {
continueBtn.disabled = false;
}
}

// --- 新增：處理彈出視窗的邏輯 ---
const newTopicModal = document.getElementById('newTopicModal');
const newTopicBtn = document.getElementById('newTopicBtn');
const closeNewTopicModal = document.getElementById('closeNewTopicModal');
const modalStartDiscussionBtn = document.getElementById('modalStartDiscussionBtn');

newTopicBtn.addEventListener('click', () => {
newTopicModal.style.display = 'flex';
});

closeNewTopicModal.addEventListener('click', () => {
newTopicModal.style.display = 'none';
});

window.addEventListener('click', (event) => {
if (event.target == newTopicModal) {
newTopicModal.style.display = 'none';
}
});

modalStartDiscussionBtn.addEventListener('click', async () => {
const newBookTitle = document.getElementById("modalBookTitle").value.trim();
const newAuthor = document.getElementById("modalAuthor").value.trim();
const newDiscussionQuestion = document.getElementById("modalDiscussionQuestion").value.trim();

if (!newBookTitle || !newAuthor || !newDiscussionQuestion) {
alert("請填寫所有欄位");
return;
}

// 更新全域變數
bookTitle = newBookTitle;
author = newAuthor;
discussionQuestion = newDiscussionQuestion;

// 清空舊的聊天歷史和 UI
document.getElementById("chatHistory").innerHTML = '';
chatHistory = [];

// 添加新的書籍資訊卡片
const initialMessage = `<table><tr><td>書名：</td><td>${bookTitle}</td></tr><tr><td>作者：</td><td>${author}</td></tr><tr><td>討論：</td><td>${discussionQuestion}</td></tr></table>`;
addMessageToHistory("info", initialMessage);

// 關閉彈出視窗
newTopicModal.style.display = 'none';

// 清空彈出視窗的輸入
document.getElementById("modalBookTitle").value = '';
document.getElementById("modalAuthor").value = '';
document.getElementById("modalDiscussionQuestion").value = '';

// 發送初始訊息
await sendInitialMessage();
});


// =================================================================================
// === 【全新】點評範疇 UI/UX 互動邏輯 ===
// =================================================================================
function setupScopeUI(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;

    const allCheckbox = container.querySelector('input[value="全部"]');
    const otherCheckboxes = container.querySelectorAll('input:not([value="全部"])');

    // 負責更新所有標籤樣式的核心函數
    const updateUI = () => {
        // 更新 "全部" 標籤的樣式
        const allLabel = allCheckbox.parentElement;
        if (allCheckbox.checked) {
            allLabel.classList.add('active');
        } else {
            allLabel.classList.remove('active');
        }

        // 更新其他所有標籤的樣式
        otherCheckboxes.forEach(cb => {
            const label = cb.parentElement;
            if (cb.checked) {
                label.classList.add('active');
            } else {
                label.classList.remove('active');
            }

            if (cb.disabled) {
                label.classList.add('disabled');
            } else {
                label.classList.remove('disabled');
            }
        });
    };

    // 為 "全部" 複選框添加事件監聽
    allCheckbox.addEventListener('change', () => {
        if (allCheckbox.checked) {
            // 如果 "全部" 被選中，取消選中並禁用其他所有選項
            otherCheckboxes.forEach(cb => {
                cb.checked = false;
                cb.disabled = true;
            });
        } else {
            // 如果 "全部" 被取消選中，啟用其他所有選項
            otherCheckboxes.forEach(cb => {
                cb.disabled = false;
            });
        }
        updateUI(); // 更新介面
    });

    // 為其他複選框添加事件監聽
    otherCheckboxes.forEach(cb => {
        cb.addEventListener('change', () => {
            // 如果任何一個其他選項被選中，則取消選中 "全部"
            if (cb.checked) {
                allCheckbox.checked = false;
            }
            updateUI(); // 更新介面
        });
    });
    
    // 頁面加載時，立即根據初始狀態更新一次UI
    updateUI();
}

// 在 DOM 加載完成後，為兩個點評範疇區塊初始化 UI 邏輯
document.addEventListener('DOMContentLoaded', () => {
    setupScopeUI('reviewScopeArea');
    setupScopeUI('argumentReviewScopeArea');
});
	

// 替換舊的 generateExpandTopic 函式
async function generateExpandTopic(buttonElement) {
if (buttonElement) {
updateButtonActiveState(buttonElement);
}

// 隱藏自訂題目輸入區，確保介面乾淨
const customTopicArea = document.getElementById("expandCustomTopicInputArea");
customTopicArea.style.display = "none";
customTopicArea.innerHTML = "";

const topicResult = document.getElementById("expandTopicResult");
const prompt = categories["整合拓展"].topicPrompt;

topicResult.innerHTML = "陳SIR正在出題...";
topicResult.style.display = 'block';

try {
const topic = await callAPI(prompt);
const lines = topic.split("\n").map(line => line.trim()).filter(line => line);
const themeMatch = lines.find(line => line.startsWith("主題句："));
const dataMatch = lines.find(line => line.startsWith("抄錄資料："));
if (!themeMatch || !dataMatch) throw new Error("API 回應格式不正確");
const theme = themeMatch.replace("主題句：", "").trim();
const data = dataMatch.replace("抄錄資料：", "").trim();
if (!theme || !data) throw new Error("生成內容不完整");

topicResult.innerHTML = `
<div class="table-container">
<table>
<tr><th>主題句</th><th>抄錄資料</th></tr>
<tr><td>${theme}</td><td>${data}</td></tr>
</table>
</div>
`;
localStorage.setItem("expandCurrentTheme", theme);
localStorage.setItem("expandCurrentData", data);
// 清除可能存在的自訂題目 Title
localStorage.removeItem("expandCurrentTitle");

} catch (error) {
console.error("生成整合拓展題目時出錯:", error);
if (error.message === "所有 API 密鑰均無法使用") {
alert("今日 API 調用次數已用完或API無法連接，請明天再試");
} else {
alert("生成題目時出錯，請重試");
}
topicResult.innerHTML = "";
topicResult.style.display = 'none';
}
}


// 替換舊的 setExpandCustomTopic 函式
function setExpandCustomTopic() {
const title = sanitizeHTML(document.getElementById("expandCustomTitle").value.trim());
const theme = sanitizeHTML(document.getElementById("expandCustomTheme").value.trim());
const data = sanitizeHTML(document.getElementById("expandCustomData").value.trim());
if (!title || !theme || !data) {
alert("請輸入所有內容（題目、主題句、抄錄資料）");
return;
}

const topicResult = document.getElementById("expandTopicResult");
topicResult.innerHTML = `
<strong>題目：${title}</strong>
<div class="table-container">
<table>
<tr><th>主題句</th><th>抄錄資料</th></tr>
<tr><td>${theme}</td><td>${data}</td></tr>
</table>
</div>
`;

topicResult.style.display = 'block';

localStorage.setItem("expandCurrentTitle", title);
localStorage.setItem("expandCurrentTheme", theme);
localStorage.setItem("expandCurrentData", data);

// 確認後，隱藏並清空輸入區域
const customTopicArea = document.getElementById("expandCustomTopicInputArea");
customTopicArea.style.display = 'none';
customTopicArea.innerHTML = '';
}

// 更新字數計數
function updateCharCount() {
const content = document.getElementById("expandContent").value;
const remaining = 180 - content.length;
document.getElementById("charCount").textContent = `剩餘字數：${remaining >= 0 ? remaining : 0}`;
if (remaining < 0) {
document.getElementById("expandContent").value = content.substring(0, 180);
}
}

// 提交整合拓展內容
async function submitExpand() {
const expandFunction = document.getElementById("expandFunction").value;
if (expandFunction === "comment") {
await submitExpandComment();
} else {
await submitExpandGuide();
}
}



// 提交點評功能 (已修訂)
async function submitExpandComment() {
const submitBtn = document.getElementById('submitExpandBtn');
submitBtn.disabled = true;
	hideAllSaveHtmlButtons();

try {
const title = localStorage.getItem("expandCurrentTitle");
const theme = localStorage.getItem("expandCurrentTheme");
const data = localStorage.getItem("expandCurrentData");
const content = document.getElementById("expandContent").value.trim();
if (!theme || !data || !content) {
alert("請先設定題目並輸入整合拓展內容");
return;
}

const tone = document.getElementById("expandTone").value;
let toneNote = "";
if (tone === "chen") {
toneNote = "請用輕鬆隨意的語氣進行點評，多用EMOJI，偶爾使用網絡用語，用語要日常生活化一點。如果用戶表現不好，可以善意地揶揄一下，但要注意尺度，不能傷害用戶的自尊心。";
} else {
toneNote = "請用嚴肅正經的語氣進行點評。";
}

const note = categories["整合拓展"].commentNote;

const prompt = `請根據以下內容進行點評，要求：
1. 評估「整合拓展」是否能闡釋「抄錄資料」與「主題句」的邏輯關係
2. 判斷「拓展」方向是否正確（即是否能論證主題句）
3. 判斷推論是否嚴謹
4. 判斷是否具體不空泛
5. 若方向不正確，需指出並建議如何修訂，不能順著錯誤思路改善，需指導扣緊主題句
6. 改寫部份不超過180字，且不得虛構資料，只可根據抄錄資料補充合理細節
7. 輸出分為三個部分：### 點評、### 建議、### 改寫
8. 「### 點評」及「### 建議」部分，請務必以數字編號的列點方式呈現，每個點另起新行。你可以根據內容提出任意數量的點評和建議。「### 改寫」則保持原有段落形式。點評及建議都可超過兩點，但不要多過三點。
題目：${title || "無"}
主題句：${theme}
抄錄資料：${data}
整合拓展：${content}
教學筆記：${note}
點評語氣：${toneNote}`;

document.getElementById("expandCommentResult").innerHTML = "陳SIR正在點評...";

const comment = await callAPI(prompt);
const commentParts = comment.split("###").map(part => part.trim()).filter(part => part);
let finalHTML = "<h3>陳SIR點評：</h3>";
commentParts.forEach(part => {
const lines = part.split("\n").filter(line => line.trim());
const title = lines.shift() || "";
const content = lines.join("\n");

if (title.includes("點評") || title.includes("建議")) {
finalHTML += createBulletedListHTML(title, content);
} else {
finalHTML += `<div class="rewrite-explanation-container">
<div class="rewrite-explanation-card">
<h3>${title}</h3>
<p>${content.replace(/\n/g, '<br>')}</p>
</div>
</div>`;
}
});
document.getElementById("expandCommentResult").innerHTML = finalHTML;
document.getElementById('save-expand-comment-html-btn').style.display = 'flex'; // 顯示按鈕
} catch (error) {
console.error("提交整合拓展點評時出錯:", error);
if (error.message === "所有 API 密鑰均無法使用") {
alert("今日 API 調用次數已用完或API無法連接，請明天再試");
} else {
alert("點評生成失敗，請重試");
}
document.getElementById("expandCommentResult").innerHTML = "";
} finally {
submitBtn.disabled = false;
}
}


// 【修訂後】提交整合拓展指引
async function submitExpandGuide() {
// 【修訂處】選取正確的按鈕 ID
const submitBtn = document.getElementById('submitExpandGuideBtn');
submitBtn.disabled = true; // 禁用按鈕

try {
const title = document.getElementById("expandGuideTitle").value.trim();
const theme = document.getElementById("expandGuideTheme").value.trim();
const data = document.getElementById("expandGuideData").value.trim();
const expand = document.getElementById("expandGuideExpand").value.trim();
if (!title || !theme || !data || !expand) {
alert("請填寫所有輸入");
return; // return 會觸發 finally
}

const note = categories["整合拓展"].guideNote;
const prompt = `請根據以下內容生成指引問題。要求：
1. 生成三道問題以引導用家思考如何根據表格資料做好整合拓展
2. 問題應圍繞主題句和抄錄資料的邏輯關係，引導用家思考如何闡釋和拓展
3. 輸出分為一個部分：### 指引問題
4. 指引問題以問題形式呈現，每個問題佔一行
題目：${title}
主題句：${theme}
抄錄資料：${data}
整合拓展：${expand}
教學筆記：${note}`;

document.getElementById("expandGuideResult").innerHTML = "陳SIR正在思考指引...";
const guide = await callAPI(prompt);
const guideParts = guide.split("###").map(part => part.trim()).filter(part => part);

let guideHTML = "<h3>陳SIR指引：</h3>";

guideParts.forEach(part => {
const lines = part.split("\n").filter(line => line.trim());
const title = lines.shift() || "指引問題";
const questions = lines;

guideHTML += `<div class="rewrite-explanation-container">
<div class="rewrite-explanation-card">
<h3>${title}</h3>`;

questions.slice(0, 3).forEach((question, index) => {
const match = question.match(/^(\d+)\.?\s*(.*)$/);
const number = match ? match[1] : index + 1;
const text = match ? match[2].trim() : question;

guideHTML += `<div class="explanation-point">
<div class="explanation-number">${number}</div>
<div class="explanation-text">${text}</div>
</div>`;
});

guideHTML += `</div></div>`;
});

document.getElementById("expandGuideResult").innerHTML = guideHTML;
document.getElementById('save-expand-guide-html-btn').style.display = 'flex'; // 顯示按鈕
} catch (error) {
console.error("提交整合拓展指引時出錯:", error);
if (error.message === "所有 API 密鑰均無法使用") {
alert("今日 API 調用次數已用完或API無法連接，請明天再試");
} else {
alert("指引生成失敗，請重試");
}
document.getElementById("expandGuideResult").innerHTML = "";
} finally {
submitBtn.disabled = false; // 重新啟用按鈕
}
}


// --- JavaScript for Tool 2 (語薈) & Modals ---
let debounceTimer;

const toolDescriptions = {
'sansi': '本工具旨在協助同學練習寫作卷和閱讀卷，並提供課外書籍討論。',
'sansi-backup': '「神思」備用版本，功能與主版本相同。',
'sansi-v3': '「神思」V3版本，功能與主版本相同。',
'tizi': '由AI擬設閱讀卷及寫作卷的題目，為同學提供源源不絕的應試練習。',
'reading-pieces': '提供AI生成的文學片段，培養同學鑑賞文學的能力。',
'study': '具有根據探究問題生成圖解與文字分析的功能，培養同學深入研討專題的能力。',
'mensyu': '具有AI尋找文言篇章的功能，並輔以語譯及詞解，培養同學鑑賞文言文的能力。',
'wabisabi': '根據同學上傳的圖片，創作具有意境的句子。',
'book-overview': '提供大量書籍的內容概覽，助你快速了解書籍大意，選擇感興趣的讀物。',
'fanshui-narrative': '由AI生成敘事範文，可根據題目創作高質素的敘事文章以供參考。',
'fanshui-argument': '由AI生成議論範文，可根據題目創作結構嚴謹的議論文以供參考。',
'manuscript': '提供電子原稿紙，模擬真實寫作情境，並設有AI答惑功能。',
'words': '設有查考詞義、文章潤色及測驗功能，有助同學累積詞彙，斟字酌句。',
'slideshow': '將同學的文章轉換為幻燈片，以藝術方式展示同學作品。',
'yuyilu-f1': '語弈錄是一款問答遊戲，題目範圍涵蓋課文。此為中一版本。',
'yuyilu-f2': '語弈錄是一款問答遊戲，題目範圍涵蓋課文。此為中二版本。',
'yuyilu-f3': '語弈錄是一款問答遊戲，題目範圍涵蓋課文。此為中三版本。',
'yuyilu-f4': '語弈錄是一款問答遊戲，題目範圍涵蓋十二篇範文。此為中四版本。',
'yuyilu-f5': '語弈錄是一款問答遊戲，題目範圍涵蓋十二篇範文。此為中五版本。',
'yuyilu-f6': '語弈錄是一款問答遊戲，題目範圍涵蓋十二篇範文。此為中六版本。',
'timer': '設有倒計時功能，程式檢測到人聲會重置時計，是專心背書溫習的好幫手。',
'mensyu-2': '文言文翻譯及分析工具，助同學克服古文閱讀的障礙。',
'zhiyun': '以Google Drive建設的雲端平臺，可供用家繳交課業、檢閱繳交紀錄及瀏覽個人課業文件夾，設有自動生成繳交課業紀錄、歸類文件及追收功課的功能。',
'zhuoyu': '可在PDF及圖片檔案右邊作旁批或備註，方便批閱作文或做筆記。',
'quizbuzzer': '一個簡單易用的線上搶答器，適合課堂或活動中使用。',
'ocr': 'i2OCR 是免費的線上光學字元辨識 (OCR) 軟體，可從圖像或PDF文件中提取文字，方便將手寫稿轉為電子檔。',
'epub': '線上電子書(ePub)閱讀器，方便閱讀電子書，無需安裝任何軟件。',
'decibelmeter': '具有量度分貝的功能，專為課堂秩序管理設計。',
'chitutor': 'AI中文聊天室，專為中文學習而設，可以與AI討論各種中文問題。',
'histutor': 'AI歷史聊天室，專為歷史學習而設，可以與AI討論歷史事件和人物。',
'counseling': 'AI輔導聊天室，當同學感到困惑或需要傾訴時，可以在這裡找到慰藉。',
'self-learning': '提供大量自學中文的資源，包括教學影片、佳作及各卷筆記等。',
'lyrics': '一款結合節奏遊戲與歌詞測驗的中文語文工具，透過音樂互動培養同學的詞彙積累、文學鑑賞及語感能力，並支援線上對戰與排行榜，增添樂趣與競爭的學習體驗。',
	'friends': '【僅供創作社成員使用】允許用戶建立群組、匿名交友、投稿作品、留言討論，並透過遊戲互動增進語文學習的樂趣，培養同學的表達與社交能力。',
	'slowreading': '一款專注深度閱讀的工具，使用者可貼上文本並自訂翻頁秒數，系統將自動逐句播放，幫助讀者聚焦內容，提升閱讀的專注力。',
	'pulseqa': '一個簡潔高效的課堂問答計時工具。主持人可創建房間、設置問題與計時，學生則需要按時作答。'
};


function drawConnectors() {
const svg = document.getElementById('connector-svg');
const container = document.getElementById('mind-map');
if (!svg || !container) {
return;
}
svg.innerHTML = '';

if (window.getComputedStyle(container).display === 'none') {
return;
}

const getElementEdge = (el, side = 'top') => {
const rect = el.getBoundingClientRect();
const containerRect = container.getBoundingClientRect();
const center_x = rect.left - containerRect.left + rect.width / 2;
const center_y = rect.top - containerRect.top + rect.height / 2;

switch(side) {
case 'top': return { x: center_x, y: rect.top - containerRect.top };
case 'bottom': return { x: center_x, y: rect.bottom - containerRect.top };
case 'left': return { x: rect.left - containerRect.left, y: center_y };
case 'right': return { x: rect.right - containerRect.left, y: center_y };
default: return {x: center_x, y: center_y};
}
}

const connections = [
{ from: '[data-id="core-ai-node"]', to: '[data-id="foundation-tizi"]', fromSide: 'bottom', toSide: 'top' },
{ from: '[data-id="core-ai-node"]', to: '[data-id="foundation-explore"]', fromSide: 'bottom', toSide: 'top' },
{ from: '[data-id="foundation-tizi"]', to: '#writing .category-title', fromSide: 'bottom', toSide: 'top' },
{ from: '[data-id="foundation-tizi"]', to: '#reading .category-title', fromSide: 'bottom', toSide: 'top' },
{ from: '[data-id="core-ai-node"]', to: '#assignments .category-title', fromSide: 'bottom', toSide: 'top' },
{ from: '[data-id="core-ai-node"]', to: '#support .category-title', fromSide: 'bottom', toSide: 'top' }
];

connections.forEach(conn => {
const fromEl = document.querySelector(conn.from);
const toEl = document.querySelector(conn.to);

if (fromEl && toEl) {
const fromPoint = getElementEdge(fromEl, conn.fromSide);
const toPoint = getElementEdge(toEl, conn.toSide);

const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
line.setAttribute('x1', fromPoint.x);
line.setAttribute('y1', fromPoint.y);
line.setAttribute('x2', toPoint.x);
line.setAttribute('y2', toPoint.y);
svg.appendChild(line);
}
});
}

// Listeners for Tool 2
document.getElementById('expandToolsBtn2').addEventListener('click', function() {
const container = document.getElementById('toolsContainer2');
container.style.display = 'flex';
document.body.style.overflow = 'hidden';
document.querySelector('#toolsContainer2 .main-container').classList.add('loaded');
clearTimeout(debounceTimer);
debounceTimer = setTimeout(drawConnectors, 100);
});

document.getElementById('closeToolsBtn2').addEventListener('click', function() {
document.getElementById('toolsContainer2').style.display = 'none';
document.body.style.overflow = 'auto';
});

// '語弈錄' Interactivity for Tool 2
const yuyiluToggleTool2 = document.getElementById('yuyilu-toggle');
const yuyiluGradesTool2 = document.getElementById('yuyilu-grades');

if (yuyiluToggleTool2 && yuyiluGradesTool2) {
yuyiluToggleTool2.addEventListener('click', function(event) {
event.preventDefault();
yuyiluGradesTool2.classList.toggle('collapsed');
setTimeout(drawConnectors, 500);
});
}

// --- Preview Modal & Video Modal Logic ---
const previewModal = document.getElementById('previewModal');
const previewIframe = document.getElementById('previewIframe');
const previewCloseBtn = document.getElementById('previewCloseBtn');
const previewGoToPageBtn = document.getElementById('previewGoToPageBtn');
const previewDescription = document.getElementById('previewDescription');

const videoModal = document.getElementById('videoModal');
const videoIframe = document.getElementById('videoIframe');
const videoTourBtn = document.getElementById('video-tour-btn');

const chartLinks = document.querySelectorAll('#toolsContainer2 .node a:not([href="#"])');

chartLinks.forEach(link => {
link.addEventListener('click', function(event) {
event.preventDefault();
const url = this.getAttribute('href');
const toolId = this.getAttribute('data-tool-id');
const description = toolDescriptions[toolId] || "暫無介紹。";

previewIframe.setAttribute('src', url);
previewGoToPageBtn.setAttribute('href', url);
previewDescription.textContent = description;

previewModal.style.display = 'flex';
});
});

function closePreviewModal() {
previewModal.style.display = 'none';
previewIframe.setAttribute('src', 'about:blank');
}

previewCloseBtn.addEventListener('click', closePreviewModal);


videoTourBtn.addEventListener('click', () => {
videoIframe.src = "https://streamable.com/e/jzhzr1?loop=0&autoplay=1&muted=0";
videoModal.style.display = 'flex';
});

function closeVideoModal() {
videoModal.style.display = 'none';
videoIframe.src = '';
}

videoModal.addEventListener('click', closeVideoModal);


// Redraw connectors on resize
window.addEventListener('resize', () => {
clearTimeout(debounceTimer);
debounceTimer = setTimeout(drawConnectors, 100);
});

// 頁面加載時初始化
document.addEventListener("DOMContentLoaded", function() {
// 預設選中並顯示第一個範疇（閱讀）
const defaultButton = document.getElementById('writingBtn');
if (defaultButton) {
showContainer('writingContainer', defaultButton);
}
});

/// =======================================================
// === 通用懸浮視窗編輯器 (最終版 - 標題修正) ===
// =======================================================
document.addEventListener('DOMContentLoaded', function() {

// --- 為動態生成的「自訂題目」輸入框加上排除標記 (保持不變) ---

const originalShowCustomTopicInput = window.showCustomTopicInput;
window.showCustomTopicInput = function(buttonElement) {
originalShowCustomTopicInput(buttonElement);
const customTopicInput = document.getElementById('customTopic');
if (customTopicInput) {
customTopicInput.classList.add('no-modal-editor');
}
};

const originalShowArgumentCustomTopicInput = window.showArgumentCustomTopicInput;
window.showArgumentCustomTopicInput = function(buttonElement) {
originalShowArgumentCustomTopicInput(buttonElement);
const argumentCustomTopicInput = document.getElementById('argumentCustomTopic');
if (argumentCustomTopicInput) {
argumentCustomTopicInput.classList.add('no-modal-editor');
}
};

const originalShowExpandCustomTopicInput = window.showExpandCustomTopicInput;
window.showExpandCustomTopicInput = function(buttonElement) {
originalShowExpandCustomTopicInput(buttonElement);
const container = document.getElementById('expandCustomTopicInputArea');
if (container) {
container.querySelectorAll('input[type="text"], textarea').forEach(el => el.classList.add('no-modal-editor'));
}
};

// --- 懸浮視窗核心邏輯 (標題生成部分已重寫) ---

const modal = document.getElementById('outline-editor-modal');
const modalTextarea = document.getElementById('modal-textarea');
const modalTitle = document.getElementById('modal-title');
const modalSaveBtn = document.getElementById('modal-save-btn');
const modalCloseBtn = document.getElementById('modal-close-btn');

if (!modal || !modalTextarea || !modalSaveBtn || !modalCloseBtn) {
console.error("懸浮視窗的 HTML 結構不完整或未找到！");
return;
}

let currentEditingElement = null;

function openModalEditor(element) {
currentEditingElement = element;
modalTextarea.value = currentEditingElement.value;

let titleText = '編輯內容'; // 先設定一個預設標題

// =================================================
// === 【核心修訂】針對特定輸入框，給予專屬標題 ===
// =================================================
if (element.id === 'writingContent' || element.id === 'argumentWritingContent') {
titleText = '輸入您的文章'; // 如果是敘事抒情或議論的寫作區，標題固定為「輸入您的文章」
}
// 如果不是上述的特殊情況，才執行原有的標題尋找邏輯
else {
const parentTableCell = element.closest('td');

// 策略一：如果是在表格內 (例如大綱)
if (parentTableCell) {
const parentRow = parentTableCell.closest('tr');
if (parentRow) {
const headerCell = parentRow.cells[0];
const table = parentRow.closest('table');
if (table && table.rows.length > 0) {
const columnHeaderCell = table.rows[0].cells[parentTableCell.cellIndex];

const rowTitle = headerCell ? headerCell.textContent.trim().replace(/[:：]/g, '') : '';
const colTitle = columnHeaderCell ? columnHeaderCell.textContent.trim().replace(/[:：]/g, '') : '';

if (rowTitle && colTitle && rowTitle !== colTitle) {
titleText = `編輯「${rowTitle}」的「${colTitle}」`;
} else if (rowTitle) {
titleText = `編輯「${rowTitle}」`;
} else if (colTitle) {
titleText = `編輯「${colTitle}」`;
}
}
}
} 
// 策略二：如果不是在表格內，則尋找與它關聯的 <label> 標籤
else {
let associatedLabel = null;
if (element.id) {
associatedLabel = document.querySelector(`label[for="${element.id}"]`);
}

if (!associatedLabel) {
const parentContainer = element.closest('div');
if (parentContainer) {
associatedLabel = parentContainer.querySelector('label');
}
}

if (associatedLabel) {
titleText = `編輯「${associatedLabel.textContent.trim().replace(/[:：]/g, '')}」`;
}
}
}

// 將最終決定的標題設定到懸浮視窗上
modalTitle.textContent = titleText;

// 顯示懸浮視窗
modal.style.display = 'flex';
modalTextarea.focus();
}

function closeModalEditor() {
modal.style.display = 'none';
currentEditingElement = null;
}

function saveAndCloseEditor() {
if (currentEditingElement) {
currentEditingElement.value = modalTextarea.value;
if (currentEditingElement.id === 'expandContent') {
updateCharCount();
}
}
closeModalEditor();
}




// 主事件監聽器 (保持不變)
document.body.addEventListener('click', function(event) {
const target = event.target;

const isTextInput = target.tagName === 'INPUT' && target.type === 'text';
const isTextarea = target.tagName === 'TEXTAREA';

if ((isTextInput || isTextarea) && !target.classList.contains('no-modal-editor') && target.id !== 'modal-textarea') {
event.preventDefault();
openModalEditor(target);
}
});

// 為懸浮視窗的按鈕和外部區域綁定事件 (保持不變)
modalSaveBtn.addEventListener('click', saveAndCloseEditor);
modalCloseBtn.addEventListener('click', closeModalEditor);
modal.addEventListener('click', function(event) {
if (event.target === modal) {
closeModalEditor();
}
});
});



// =======================================================
// === 全新評等系統邏輯 (Grading System Logic) ===
// =======================================================

let radarChartInstance = null; // 全域變數，用於存放雷達圖實例

/**
* 建立評等系統的完整 HTML 結構 (修訂版)
* @param {string} uniqueIdPrefix - 用於區分不同功能區塊的唯一前綴
* @returns {string} HTML 字符串
*/
function createGradingSystemHTML(uniqueIdPrefix) {
// 預設分數值 (原始分數 0-10)
const defaultContentScore = 5;
const defaultExpressionScore = 5;
const defaultStructureScore = 5;
const defaultPunctuationScore = 5;
const defaultTypoScore = 1;

// 計算預設的顯示分數
const defaultDisplayTotal = (defaultContentScore * 4) + (defaultExpressionScore * 3) + (defaultStructureScore * 2) + (defaultPunctuationScore * 1) + defaultTypoScore;
const cappedDefaultTotal = Math.min(defaultDisplayTotal, 100);

return `
<div class="grading-container">
<div class="grading-grid">
<div class="grading-scores">
<h3>評等</h3>
<div class="score-item">
<label>內容 (40)</label>
<div class="slider-container">
<!-- 【修訂一】替換為進度條 -->
<div class="progress-bar-container"><div id="${uniqueIdPrefix}ContentScoreFill" class="progress-bar-fill"></div></div>
<span id="${uniqueIdPrefix}ContentScoreDisplay" class="score-display">${defaultContentScore * 4}</span>
</div>
</div>
<div class="score-item">
<label>表達 (30)</label>
<div class="slider-container">
<div class="progress-bar-container"><div id="${uniqueIdPrefix}ExpressionScoreFill" class="progress-bar-fill"></div></div>
<span id="${uniqueIdPrefix}ExpressionScoreDisplay" class="score-display">${defaultExpressionScore * 3}</span>
</div>
</div>
<div class="score-item">
<label>結構 (20)</label>
<div class="slider-container">
<div class="progress-bar-container"><div id="${uniqueIdPrefix}StructureScoreFill" class="progress-bar-fill"></div></div>
<span id="${uniqueIdPrefix}StructureScoreDisplay" class="score-display">${defaultStructureScore * 2}</span>
</div>
</div>
<div class="score-item">
<label>標點字體 (10)</label>
<div class="slider-container">
<div class="progress-bar-container"><div id="${uniqueIdPrefix}PunctuationScoreFill" class="progress-bar-fill"></div></div>
<span id="${uniqueIdPrefix}PunctuationScoreDisplay" class="score-display">${defaultPunctuationScore * 1}</span>
</div>
</div>
<div class="score-item">
<label>錯別字 (+3)</label>
<div class="slider-container">
<div class="progress-bar-container"><div id="${uniqueIdPrefix}TypoScoreFill" class="progress-bar-fill"></div></div>
<span id="${uniqueIdPrefix}TypoScoreDisplay" class="score-display">${defaultTypoScore}</span>
</div>
</div>
<!-- 隱藏的 input 用於儲存 AI 評分 -->
<input type="hidden" id="${uniqueIdPrefix}ContentScore" value="${defaultContentScore}">
<input type="hidden" id="${uniqueIdPrefix}ExpressionScore" value="${defaultExpressionScore}">
<input type="hidden" id="${uniqueIdPrefix}StructureScore" value="${defaultStructureScore}">
<input type="hidden" id="${uniqueIdPrefix}PunctuationScore" value="${defaultPunctuationScore}">
<input type="hidden" id="${uniqueIdPrefix}TypoScore" value="${defaultTypoScore}">

<div class="total-score-container">
<!-- 【修訂二】滿分改為 100 -->
<span id="${uniqueIdPrefix}TotalScoreDisplay">總分: ${cappedDefaultTotal} / 100</span>
<span id="${uniqueIdPrefix}FinalGrade">等級: 3</span>
</div>
</div>
<div class="grading-radar">
<h3>能力雷達圖</h3>
<div class="radar-chart-container">
<canvas id="${uniqueIdPrefix}RadarChart"></canvas>
</div>
</div>
</div>
</div>
`;
}


/**
* 初始化評等系統，包括設定分數和繪製初始圖表
* @param {string} uniqueIdPrefix - 用於區分不同功能區塊的唯一前綴
* @param {object} initialScores - 包含初始分數的物件
* @param {string} finalGrade - 【新】直接傳入最終計算好的等級
*/
function initializeGradingSystem(uniqueIdPrefix, initialScores = {}, finalGrade) {
    // 確保 initialScores 和 initialScores.radar 存在
    if (!initialScores || !initialScores.radar) {
        console.error("初始化評分系統時缺少必要的分數數據。");
        return;
    }

    // 將最終計算出的分數設定到隱藏的 input 中，這些 input 是後續計算的基礎
    document.getElementById(`${uniqueIdPrefix}ContentScore`).value = initialScores.content;
    document.getElementById(`${uniqueIdPrefix}ExpressionScore`).value = initialScores.expression;
    document.getElementById(`${uniqueIdPrefix}StructureScore`).value = initialScores.structure;
    
    // 標點和錯別字分數使用固定的預設值
    document.getElementById(`${uniqueIdPrefix}PunctuationScore`).value = 5;
    document.getElementById(`${uniqueIdPrefix}TypoScore`).value = 1;

    // 呼叫更新函式，它會處理所有介面元素的更新，包括顯示分數、進度條和雷達圖
    updateScoresAndGrade(uniqueIdPrefix, finalGrade, initialScores.radar);
}




/**
* 根據分數計算總分，上限為 100
* @param {string} uniqueIdPrefix - 功能區塊的唯一前綴
* @returns {number} 計算後且不超過 100 的總分
*/
function calculateTotalScore(uniqueIdPrefix) {
// 【修訂二】從隱藏的 input 中獲取原始分數 (0-10)
const content = parseInt(document.getElementById(`${uniqueIdPrefix}ContentScore`).value) * 4;
const expression = parseInt(document.getElementById(`${uniqueIdPrefix}ExpressionScore`).value) * 3;
const structure = parseInt(document.getElementById(`${uniqueIdPrefix}StructureScore`).value) * 2;
const punctuation = parseInt(document.getElementById(`${uniqueIdPrefix}PunctuationScore`).value) * 1;
const typo = parseInt(document.getElementById(`${uniqueIdPrefix}TypoScore`).value);

const totalScore = content + expression + structure + punctuation + typo;

// 返回分數，但最高不超過 100
return Math.min(totalScore, 100);
}

/**
* 根據總分決定 DSE 等級
* @param {number} score - 總分 (0-103)
* @returns {string} DSE 等級
*/
function determineGrade(score) {
if (score >= 72) return "5**";
if (score >= 69) return "5*";
if (score >= 64) return "5";
if (score >= 57) return "4";
if (score >= 50) return "3";
if (score >= 45) return "2";
return "1";
}

/**
* 更新所有分數顯示、總分、等級、進度條和雷達圖
* @param {string} uniqueIdPrefix - 功能區塊的唯一前綴
* @param {string} finalGrade - 【新】直接傳入最終計算好的等級
* @param {object} radarData - 雷達圖的數據 (可選)
*/
function updateScoresAndGrade(uniqueIdPrefix, finalGrade, radarData = null) {
    // 從隱藏的 input 獲取原始分數 (0-10 或 0-3)
    const contentVal = parseInt(document.getElementById(`${uniqueIdPrefix}ContentScore`).value);
    const expressionVal = parseInt(document.getElementById(`${uniqueIdPrefix}ExpressionScore`).value);
    const structureVal = parseInt(document.getElementById(`${uniqueIdPrefix}StructureScore`).value);
    const punctuationVal = parseInt(document.getElementById(`${uniqueIdPrefix}PunctuationScore`).value);
    const typoVal = parseInt(document.getElementById(`${uniqueIdPrefix}TypoScore`).value);

    // 更新各分項顯示（乘以權重後的分數）
    document.getElementById(`${uniqueIdPrefix}ContentScoreDisplay`).textContent = contentVal * 4;
    document.getElementById(`${uniqueIdPrefix}ExpressionScoreDisplay`).textContent = expressionVal * 3;
    document.getElementById(`${uniqueIdPrefix}StructureScoreDisplay`).textContent = structureVal * 2;
    document.getElementById(`${uniqueIdPrefix}PunctuationScoreDisplay`).textContent = punctuationVal * 1;
    document.getElementById(`${uniqueIdPrefix}TypoScoreDisplay`).textContent = typoVal;

    // 更新進度條寬度
    document.getElementById(`${uniqueIdPrefix}ContentScoreFill`).style.width = `${contentVal * 10}%`;
    document.getElementById(`${uniqueIdPrefix}ExpressionScoreFill`).style.width = `${expressionVal * 10}%`;
    document.getElementById(`${uniqueIdPrefix}StructureScoreFill`).style.width = `${structureVal * 10}%`;
    document.getElementById(`${uniqueIdPrefix}PunctuationScoreFill`).style.width = `${punctuationVal * 10}%`;
    document.getElementById(`${uniqueIdPrefix}TypoScoreFill`).style.width = `${(typoVal / 3) * 100}%`;

    // 計算並更新總分
    const totalScore = calculateTotalScore(uniqueIdPrefix);
    document.getElementById(`${uniqueIdPrefix}TotalScoreDisplay`).textContent = `總分: ${totalScore} / 100`;
    // 【修訂】直接使用傳入的 finalGrade
    document.getElementById(`${uniqueIdPrefix}FinalGrade`).textContent = `等級: ${finalGrade}`;

    // 準備並更新雷達圖數據
    let currentRadarData;
    if (radarData) {
        currentRadarData = [
            radarData.立意 || 5,
            radarData.取材 || 5,
            radarData.扣題 || 5,
            radarData.詳略 || 5,
            radarData.詞彙 || 5,
            radarData.文學性 || 5
        ];
    } else {
        // 若 AI 未提供雷達圖數據，則根據分數估算 (此為備用邏輯)
        currentRadarData = [
            Math.round((contentVal * 0.6 + structureVal * 0.4)), 
            Math.round((contentVal * 0.8 + expressionVal * 0.2)),
            Math.round((contentVal * 0.7 + structureVal * 0.3)),
            Math.round((structureVal * 0.7 + contentVal * 0.3)),
            expressionVal,
            expressionVal
        ];
    }
    createOrUpdateRadarChart(uniqueIdPrefix, currentRadarData);
}


/**
* 創建或更新雷達圖
* @param {string} uniqueIdPrefix - 功能區塊的唯一前綴
* @param {array} data - 包含五個能力值的數組
*/
function createOrUpdateRadarChart(uniqueIdPrefix, data) {
const ctx = document.getElementById(`${uniqueIdPrefix}RadarChart`).getContext('2d');

if (window[`${uniqueIdPrefix}_radarChartInstance`]) {
window[`${uniqueIdPrefix}_radarChartInstance`].data.datasets[0].data = data;
window[`${uniqueIdPrefix}_radarChartInstance`].update();
} else {
window[`${uniqueIdPrefix}_radarChartInstance`] = new Chart(ctx, {
type: 'radar',
data: {
labels: ['立意', '取材', '扣題', '詳略', '詞彙', '文學性'],
datasets: [{
label: '能力分佈',
data: data,
backgroundColor: 'rgba(54, 162, 235, 0.2)',
borderColor: 'rgba(54, 162, 235, 1)',
borderWidth: 2,
pointBackgroundColor: 'rgba(54, 162, 235, 1)',
pointBorderColor: '#fff',
pointHoverBackgroundColor: '#fff',
pointHoverBorderColor: 'rgba(54, 162, 235, 1)'
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
scales: {
r: {
angleLines: {
display: true
},
suggestedMin: 0,
suggestedMax: 10,
pointLabels: {
font: {
size: 14,
family: "'Noto Serif TC', serif"
}
},
ticks: {
stepSize: 2
}
}
},
plugins: {
legend: {
display: false
}
}
}
});
}
}

/**
* 構建帶有評等指令的 API Prompt (V15 - 條件式加分)
* 此版本嚴格規定「內容」和「結構」分數必須以「扣題」分數為基礎，
* 但允許在這基礎上有條件地加一分，以獎勵表現出色的部分。
*/
function buildGradingPrompt(type, topic, content, toneNote, focus = null, plot = null) {
const dsePrinciples = document.getElementById('dse-grading-principles').innerText;
const fiveStarExamplesText = `
### 5** 級數範文參考 (用於判斷最高水平)：
${document.getElementById('example-yanhuo').innerHTML}
${document.getElementById('example-gen').innerHTML}
${document.getElementById('example-dengdai').innerHTML}
${document.getElementById('example-song-li').innerHTML}

### 3 級數範文參考 (用於判斷中等水平)：
${document.getElementById('example-lun-dushu').innerHTML}
`;

let basePrompt = "";
let specificInstructions = "";

if (type === 'narrative') {
basePrompt = `
題目：《${topic}》
${focus ? `結構段重點：${focus}` : ''}
${plot ? `情節大要：${plot}` : ''}
文章：\n${content}`;

// 【修訂一】這裡只引用敘事抒情相關的範文
const fiveStarExamplesText = `
### 5** 級數範文參考 (用於判斷最高水平)：
${document.getElementById('example-yanhuo').innerHTML}
${document.getElementById('example-gen').innerHTML}
${document.getElementById('example-dengdai').innerHTML}

### 3 級數範文參考 (用於判斷中等水平)：
${document.getElementById('example-yanhuo-l3').innerHTML}
`;

specificInstructions = `
### 敘事抒情專用評核指引
- 扣題判斷：文章必須在字面上緊扣題目關鍵詞，並透過具體情節體現主題
- 詳略剪裁：重點情節需詳寫，次要內容需略寫，體現層次感
- 物象運用：適當運用小物件、動作、對話和內心獨白，提高文句密度`;

// 【修訂二】這裡替換為你提供的全新評分邏輯和工作紙
return `你將扮演一個絕對理性的AI評卷員，你的核心任務是完成一份計分工作紙，然後根據工作紙的結果生成報告。

### 你的工作流程 (必須嚴格依序執行)

1. **填寫工作紙**: 這是你的首要且最重要的任務。在 <scoring_worksheet> 標籤內，完成所有計算。
2. **分發分數到JSON**: **絕對禁止重新思考分數**。你將扮演一個數據錄入員，將 <scoring_worksheet> 中計算出的分數，精確地分發到 <grading_json> 的對應欄位。
3. **撰寫報告**: 根據 <grading_json> 的最終分數，撰寫 <critique> 等文字報告，確保文字與數字完全對應。

${specificInstructions}

---

### 你的輸出格式 (必須嚴格遵守此結構與順序)

<scoring_worksheet>
[**計分工作紙**：你必須像執行程式碼一樣，完成以下所有步驟。]
<step_1_independent_evaluation>
[對以下各項進行獨立評分，互不影響。]
<eval_item name="扣題分數評估">
規則：嚴格按照以下標尺評分，並必須引用文章中的具體內容來佐證你的評分。文章必須在*字面*及邏輯上扣連題目，所謂「字面」扣題，是指文章要反覆出現題眼或題眼的近義詞，例如題目是《勇氣》，則文中須反覆出現「勇氣」或「勇敢」等字眼。

- **7-10分 (緊扣主旨 / 5**水平):** 
能在*字面*及情節上直接呼應題目，完全能在字面上扣連題目，例如題目為《成長》，全文有較多「成長」或「成長」的近義詞，且意象連貫、深刻，絕對不接受任何只以隱喻扣題的間接形式。
令人信服地體現主旨。
多關鍵詞題目中能準確把握最重要的關鍵詞，水平與5**範文相當。

- **6分 (扣題良好 / 略遜於5**):** 
基本能扣緊題目要求，在主要情節、主旨及*字面*上與題目有明確關聯，能在字面上扣連題目，例如題目為《成長》，全文有一定數量「成長」或「成長」的近義詞，但在深度或完整性上
稍遜於頂尖水平，表現仍屬出色。絕對不接受任何只以隱喻扣題的間接形式。

- **5分 (扣題合格 / 中等水平):** 
能夠扣題，文章內容與題目有清晰關聯，但較少在字面上扣連題目，例如題目為《成長》，全文很少有「成長」或「成長」的近義詞，雖未能充分發揮題目的深層意涵，
但已達合格應試水平 (約3-4級)，絕對不接受任何只以隱喻扣題的間接形式。

- **1-4分 (偏離主題):** 
與題目關聯牽強，未能準確理解題意，或僅在表面文字上有所呼應，
實際內容偏離主題，扣題效果不佳。或沒有在字面上扣連題目，例如題目為《成長》，但全文卻沒有「成長」或「成長」的近義詞。絕對不接受任何只以隱喻扣題的間接形式。

評分 (0-10): [在此給出「扣題」的獨立分數]
</eval_item>

<eval_item name="立意分數評估">
規則：嚴格按照以下標尺評分，並必須引用文章中的句子或主旨句來佐證你的評分。
- **7-10分 (深刻新穎 / 5**水平):** 能將個人經歷 **昇華** 至普遍的人生哲理或人性反思。主題層次豐富，能探討觀點的 **矛盾或轉變**。立意新穎，能給讀者帶來深刻啟發，水平與5**範文相當。
- **6分 (見解不凡 / 略遜於5**):** 立意有一定深度，能提出個人見解，而非複述道理。思想內容雖未及頂尖水平，但已超越一般考生的層次，表現出色。
- **5分 (清晰合理 / 中等水平):** 主題清晰，緊扣個人感受，能完整表達一次經歷後的體會。立意真誠、合理，是合格的應試文章水平 (約3-4級)。
- **1-4分 (膚淺陳腐):** 立意流於表面，多為 **陳腔濫調** (例如「努力便會成功」)，或僅是 **說教式** 的口號，與文章情節缺乏有機結合。

評分 (0-10): [在此給出「立意」的獨立分數]
</eval_item>
<eval_item name="取材分數評估">
規則：嚴格按照以下標尺評分，評分時需明確指出取材的優點（如某個具體的細節）或缺點（如情節過於概括）。
- **7-10分 (新穎生動 / 5**水平):** 選取的材料 **典型** 且具 **獨特性**，能有力地支撐立意。描寫 **具體入微**，包含豐富的感官細節、動作、對話和內心獨白，能營造強烈的情感張力，水平與5**範文相當。
- **6分 (細膩具體 / 略遜於5**):** 選材恰當，頗具獨特性，能有效支撐立意。描寫具體，包含不少細節，但整體新穎性或情感張力略遜於最高水平，但遠超於3等文章水平。
- **5分 (內容恰當 / 中等水平):** 選材合理，與主旨相關。情節有基本細節，但描寫較為普遍化，缺乏令人印象深刻的亮點 (約3-4級)。
- **1-4分 (空泛籠統):** 取材流於 **流水帳**，僅概括事件而無細節描寫。內容空泛，與主旨關係薄弱，無法有效支撐觀點。

評分 (0-10): [在此給出「取材」的獨立分數]
</eval_item>
<eval_item name="詳略安排評估">
規則：嚴格按照以下標尺評分。此項評估的是文章的「敘事節奏」與「焦點分配」。
- **7-10分 (卓越 / 5**水平):** **詳略得當，重心突出**。能將最多筆墨用於高潮、轉捩點或最能體現主旨的核心情節，並以豐富的細節（感官、心理）進行刻劃。次要的過渡性內容則簡潔交代。敘事節奏控制自如，張弛有度。
- **6分 (良好 / 略遜於5**):** **主次分明**。能意識到並詳寫核心事件，但詳寫的細膩度或略寫的簡練度未及頂尖水平。文章的焦點清晰，能引導讀者關注重點。
- **5分 (中等 / 合格水平):** **平均用力**。文章能完整敘述事件，但缺乏詳略意識，從頭到尾的細節密度相近，導致核心情節不夠突出，缺乏記憶點。
- **1-4分 (失衡 / 有待改善):** **詳略嚴重失衡**。常見問題如「頭重腳輕」（開頭冗長）、「虎頭蛇尾」（結尾倉促），或將大量筆墨用於無關緊要的細節上，導致主題模糊。
特別注意：必須評論文章的重心是否放在了最關鍵的情節上。

評分 (0-10): [在此給出「詳略安排」的獨立分數]
</eval_item>

<eval_item name="結構佈局評估">
規則：嚴格按照以下標尺評分。此項評估的是文章的「組織架構」與「段落邏輯」。
- **7-10分 (精巧嚴謹 / 5**水平):** 佈局精巧，**層層推進**，而非單純的順序記述。段落劃分清晰且邏輯性強，過渡自然無痕。開頭與結尾**巧妙呼應**，使文章渾然一體。
- **6分 (良好 / 略遜於5**):** **結構穩妥，脈絡清晰**。文章組織有序，段落職能分明（如開頭、發展、結尾），起承轉合流暢。整體表現穩健，無明顯結構缺陷。
- **5分 (中等 / 合格水平):** **結構完整，尚算清晰**。文章有頭有尾，段落劃分基本合理。但段落間的聯繫可能較弱，或過渡略顯生硬（例如頻繁使用「然後」、「接著」）。
- **1-4分 (鬆散混亂 / 有待改善):** **結構鬆散，脈絡不清**。段落劃分混亂，或思想跳躍，讓讀者難以跟隨。文章可能缺乏清晰的開頭或結尾。
特別注意：此項不評估內容詳略，只評估組織架構。

評分 (0-10): [在此給出「結構佈局」的獨立分數]
</eval_item>



<eval_item name="詞彙豐富度評估">
規則：嚴格按照以下標尺評分，並必須引用文章中的詞語來佐證你的評分。
- **7-10分 (優良 / 5**水平):** 用詞精準、豐富且多樣化，能根據語境選擇最貼切的詞。善用成語、典故或富含意象的詞彙，且自然不堆砌。幾乎沒有重複用詞。水平與5**範文相當。
- **6分 (良好 / 略遜於5**):** 用詞準確，具備變化，能嘗試運用較豐富的詞彙（較少重複同一個詞彙），偶有佳句，整體表現穩健，屬良好水平。
- **5分 (中等 / 合格水平):** 用詞基本準確，但變化不大，偶爾出現不夠貼切或陳腔濫調的情況。能夠清晰達意，是合格的應試文章水平，經常運用虛詞（例如「的」、「了」、「呢」、「嗎」、「地」）及對話，用詞重複。
- **1-4分 (基礎 / 有待改善):** 用詞單調、重複，常使用口語化或模糊的詞語，甚至出現詞不達意的情況。
特別注意：不要輕易給予高分，必須有充分理據。

評分 (0-10): [在此給出「詞彙豐富度」的獨立分數]
</eval_item>


<eval_item name="文句文學性評估">
規則：嚴格按照以下標尺評分。此項評估的是「句子工藝」，而非單純的詞彙。
- **7-10分 (卓越 / 5**水平):** 句式靈活多變，長短句交錯，富有節奏感。善於運用**感官描寫**和**示現手法**（Show, not Tell），能巧妙地融情入景，運用物象營造意境氛圍。文句精煉，文字具有**畫面感**和感染力。水平與5**範文相當。
- **6分 (良好 / 略遜於5**):** 句式有一定變化，能避免單調。能運用基本的描寫技巧，但細節刻劃或意境營造未及頂尖水平。整體文句流暢，但偶有冗贅之處。屬良好水平，表現穩健。
- **5分 (中等 / 合格水平):** 句式有基本變化，但整體**平鋪直敘**，僅能清晰交代事件，缺少深入刻劃。能使用簡單修辭，但效果不突出。常使用虛詞（的、了、地）使文句略嫌鬆散。是合格的應試文章水平，能夠清晰達意。
- **1-4分 (基礎 / 有待改善):** 句式單一、冗長或破碎。文字平淡乏味，**缺乏描寫意識**。大量使用虛詞，文句不通順或口語化嚴重，影響閱讀流暢度。
特別注意：不要輕易給予高分，必須有充分理據。

評分 (0-10): [在此給出「文句文學性」的獨立分數]
</eval_item>


</step_1_independent_evaluation>


<step_2_high_score_validation>
[**高分驗證機制**：這是一個強制執行的覆核步驟。]
IF '扣題分數評估' >= 9 THEN
<re-evaluation name="立意分數覆核">
質疑：文章的主題思想是否真的深刻新穎，或僅僅是一個完美切題的「陳腔濫調」？（例如：《等待》寫等待母親，立意僅停留在「要珍惜親人」，這就是切題但膚淺）。
規則：完美切題但立意陳腐或淺白的文章，其「立意」分數**絕不能超過6分**。請將其與5**範文的哲理深度進行比較，然後給出最終修正分數。
修正後的立意分數 (0-10): [在此填寫修正後的分數]
</re-evaluation>
<re-evaluation name="取材分數覆核">
質疑：文章的材料是否真的獨特生動，或僅僅是一個符合題目的「公式化故事」？（例如：寫挫折，就是考試失敗，然後努力，最後成功）。
規則：切題但取材普通、缺乏亮點的故事，其「取材」分數**絕不能超過6分**。請評估其細節描寫是否達到5**範文的水平，然後給出最終修正分數。
修正後的取材分數 (0-10): [在此填寫修正後的分數]
</re-evaluation>
ELSE
[扣題分數低於9分，跳過此驗證，直接使用原始分數。]
修正後的立意分數: [複製 '立意分數評估' 的分數]
修正後的取材分數: [複製 '取材分數評估' 的分數]
END IF
</step_2_high_score_validation>

<step_3_composite_calculation>
[根據獨立評估的分數，計算最終的總項分數。]
<calc_item name="內容總分計算">
規則：「內容」總分由「立意」和「取材」的分數獨立決定，**不受「扣題」分數直接影響**。對於「扣題」分數不佳的懲罰，將由後續的JavaScript邏輯處理，AI在此階段不需考慮。
計算公式：round((立意分數 + 取材分數) / 2)
最終內容分數 (0-10): [根據上述簡化公式計算出最終分數]
</calc_item>
<calc_item name="結構總分計算">
規則：「結構」總分由「詳略安排」和「結構佈局」的平均值決定。
計算公式: round(("詳略安排評估"分數 + "結構佈-局評估"分數) / 2)
最終結構分數 (0-10): [根據上述公式計算出最終分數]
</calc_item>
<calc_item name="表達總分計算">
規則：表達總分由「詞彙豐富度」和「文句文學性」的平均值決定。
計算公式: round(("詞彙豐富度評估"分數 + "文句文學性評估"分數) / 2)
最終表達分數 (0-10): [根據上述公式計算出最終分數]
</calc_item>
</step_3_composite_calculation>
<!-- ▲▲▲ 敘事抒情文的評分邏輯已完全重構 ▲▲▲ -->
</scoring_worksheet>

<grading_json>
[**分數分發步驟**：**這是一條絕對的、機械的指令。** 你的任務是將 <scoring_worksheet> 的計算結果填入下方。]
{
"content": [複製'內容分數'的'最終分數'],
"expression": [複製'表達分數'的'最終分數'],
"structure": [複製'結構分數'的'最終分數'],
"radar": {
"立意": [複製'扣題分數'的'扣題基準分數'],
"取材": [複製'內容分數'的'最終分數'],
"扣題": [複製'扣題分數'的'扣題基準分數'],
"詳略": [複製'結構分數'的'最終分數'],
"文筆": [複製'表達分數'的'最終分數']
}
}
</grading_json>

<critique>
[根據「教學筆記」對文章進行點評，可從立意、取材、扣題、詳略、文筆等不同角度點評。必須以數字編號列點方式呈現2-3點核心評論。]
</critique>

<suggestions>
[基於 <critique> 的內容，提出改善建議。]
</suggestions>

<rewrite_example>
[提供一段約150-200字的改寫範例。]
</rewrite_example>

---
### 待評核文章資訊
${basePrompt}

### 語境參考資料
[DSE 評核準則]: ${dsePrinciples}
[5** 級數範文]: ${fiveStarExamplesText}

### 語氣要求
<critique> 和 <suggestions> 的語氣：${toneNote}
<rewrite_example> 的語氣：請使用嚴肅正經的語氣。
`;

} else { // argument - 保持原有的複雜邏輯
basePrompt = `
題目：《${topic}》
文章：\n${content}`;

specificInstructions = `
### 議論文專用評核指引
**核心原則：絕對嚴謹的扣題判斷，採用形式化流程處理**

**立意評核標準**：
- 立意取決於觀點是否深入成熟
- 觀點深度層次：表面現象 → 深層原因 → 人生哲理
- 成熟度判斷：是否具備成年人的思辨深度

**取材評核標準**：
- 取材取決於論據是否充實，涵蓋古今中外
- 論據適用性：論據是否切合這道具體題目
- 覆蓋範圍：古代、現代、中外例證的平衡性

**內容與結構分數限制規則**：
- 即使扣題分數很高，但如果立意和取材分數低，其「內容」和「結構」分最高只能得5分
- 計算方式：內容分數 = min(5, 原計算分數) if (立意分數 ≤ 4 OR 取材分數 ≤ 4)
- 計算方式：結構分數 = min(5, 原計算分數) if (立意分數 ≤ 4 OR 取材分數 ≤ 4)

- **形式化扣題檢測流程**：
* 步驟1：提取題目核心關鍵詞（去除「論」、「談」等前綴詞）
* 步驟2：識別文章主要論述對象的關鍵詞
* 步驟3：執行字符串精確比對（character-by-character matching）
* 步驟4：IF (題目關鍵詞 === 文章關鍵詞) THEN 緊扣 ELSE 偏題/離題

- **嚴格判定規則（無例外執行）**：
* 關鍵詞完全匹配（===） = 緊扣（5-10分）
* 關鍵詞不匹配（!==） = 偏題（一般直接評為4分即可，極少情況會評為1至2分）或離題（一般直接評為3分即可，極少情況會評為1至2分）
* 題目《論禮貌》vs 文章論「禮物」→ 「禮貌」!==「禮物」→ 偏題（一般直接評為4分即可，極少情況會評為1至2分）
* 題目《論競爭》vs 文章論「合作」→ 「競爭」!==「合作」→ 偏題（一般直接評為4分即可，極少情況會評為1至2分）

例如：題目為《論禮貌》，但文中多論「禮物」，都屬於偏題，《禮貌》是一個更寬的概念，「禮貌」會包含「禮物」這個更狹窄的概念，絕不可用狹窄的概念論述寬泛的概念

- **禁止的判斷方式**：
* ❌ 語意相近性判斷（如「禮貌」與「禮儀」相近）
* ❌ 概念關聯性判斷（如「競爭」與「合作」有關聯）
* ❌ 邏輯推演判斷（如「責任心」包含「責任」）
* ❌ 文學創意判斷（如「以禮物論禮貌」的創意寫法）

- **強制執行機制**：
* 系統性：每篇文章必須執行完整的4步驟檢測流程
* 客觀性：僅基於字符串比對結果，不加入主觀判斷
* 一致性：相同字符串比對結果必須得出相同評級
* 嚴謹性：寧可誤判為偏題，不可誤判為緊扣

**範例執行**：
題目《論禮貌》：
- 文章論「禮貌」→ 「禮貌」===「禮貌」→ TRUE → 緊扣
- 文章論「禮物」→ 「禮貌」===「禮物」→ FALSE → 偏題 
- 文章論「禮儀」→ 「禮貌」===「禮儀」→ FALSE → 偏題
- 文章論「送禮」→ 「禮貌」===「送禮」→ FALSE → 偏題`;

// 議論文保持原有的複雜評分邏輯
return `你將扮演一個絕對理性的AI評卷員，你的核心任務是完成一份計分工作紙，然後根據工作紙的結果生成報告。

### 你的工作流程 (必須嚴格依序執行)

1. **填寫工作紙**: 這是你的首要且最重要的任務。在 <scoring_worksheet> 標籤內，完成所有計算。
2. **分發分數到JSON**: **絕對禁止重新思考分數**。你將扮演一個數據錄入員，將 <scoring_worksheet> 中計算出的分數，精確地分發到 <grading_json> 的對應欄位。
3. **撰寫報告**: 根據 <grading_json> 的最終分數，撰寫 <critique> 等文字報告，確保文字與數字完全對應。

${specificInstructions}

---

### 你的輸出格式 (必須嚴格遵守此結構與順序)

<scoring_worksheet>
[**計分工作紙**：你必須像執行程式碼一樣，完成以下所有步驟。]
<step_1_topic_analysis>
<topic_keywords>題目關鍵詞: [提取題目的核心概念，如「禮貌」]</topic_keywords>
<article_focus>文章論述焦點: [識別文章主要論述的核心概念，如「禮物」、「送禮」]</article_focus>
<concept_match>概念匹配度: [比較題目關鍵詞與文章焦點是否一致]</concept_match>
</step_1_topic_analysis>

<step_2_strict_topic_judgement>
<critical_check>
**絕對嚴格扣題檢查**：
- 題目核心關鍵詞: [提取題目去除助詞後的核心概念]
- 文章核心論述詞: [識別文章主要論述的核心詞匯]
- 字面一致性檢查: [兩詞是否完全相同，YES/NO]
- 關鍵詞出現頻率: [該關鍵詞在文章中的使用次數]
- 關鍵詞重要性: [該關鍵詞是否為文章論述主線]

**形式化判斷標準**：
- 如果文章論述的核心詞匯與題目關鍵詞字面不同（如「禮貌」vs「禮物」、「責任」vs「負責」、「寬容」vs「包容」），無論內容多優秀，強制判定為「偏題」
- 如果關鍵詞雖然相同但使用頻率極低或非論述主線，判定為「偏題」
- 偏題文章扣題分數：4分或以下
- 離題文章扣題分數：3分或以下
</critical_check>

<final_topic_judgement>[基於上述形式化檢查，強制填寫「離題」、「偏題」或「緊扣」，不得有任何例外]</final_topic_judgement>
</step_2_strict_topic_judgement>

<step_3_base_scores>
<judgement_item name="表達水平">[在此獨立評估文筆，填寫「優良」、「普通」或「欠佳」]</judgement_item>
</step_3_base_scores>

<step_4_calculation>
<calc_item name="扣題分數計算（絕對基準）">
判斷結果: [複製上面的'final_topic_judgement']
**強制執行規則**：
- IF '離題' THEN 扣題分數 = 1-3分（一般直接評為3分即可，極少情況會評至1至2分）
- IF '偏題' THEN 扣題分數 = 1-4分（一般直接評為4分即可，極少情況會評至1至2分）
- IF '緊扣' THEN 扣題分數 = 5-10分

**特別注意**：任何概念置換（如禮貌→禮物、責任→負責、寬容→包容）必須判定為偏題，如題目為《論禮貌》，但文中多論「禮物」，都屬於偏題，《禮貌》是一個更寬的概念，「禮貌」會包含「禮物」這個更狹窄的概念，絕不可用狹窄的概念論述寬泛的概念，扣題分數絕對不得超過4分，扣題絕對不能打5分或以上。

最終扣題分數 (1-10): [嚴格按照上述規則給分，不允許任何例外]
</calc_item>

<calc_item name="內容分數計算">
規則: 偏題或離題情況下，內容分數不得超過扣題分數且有絕對上限
基於扣題分數: [複製上面的扣題分數]
**嚴格限制**：
- 偏題情況：內容分數絕對上限4分，一般直接評為4分即可，極少情況會評至1至2分
- 離題情況：內容分數絕對上限3分，一般直接評為3分即可，極少情況會評至1至2分
最終內容分數 (1-10): [不得超過扣題分數且不得超過上述絕對上限]
</calc_item>

<calc_item name="結構分數計算">
規則: 偏題或離題情況下，結構分數不得超過扣題分數且有絕對上限
基於扣題分數: [複製上面的扣題分數]
**嚴格限制**：
- 偏題情況：結構分數絕對上限4分，一般直接評為4分即可，極少情況會評至1至2分
- 離題情況：結構分數絕對上限3分，一般直接評為3分即可，極少情況會評至1至2分
最終結構分數 (1-10): [不得超過扣題分數且不得超過上述絕對上限]
</calc_item>

<calc_item name="表達分數計算（相對獨立）">
判斷: [複製上面的'表達水平']
規則: IF '優良' THEN score=7-9; IF '普通' THEN score=4-6; ELSE score=1-3
最終表達分數 (1-10): [按此規則給分]
</calc_item>


<calc_item name="立意分數計算">
評估觀點深度: [判斷觀點是否深入成熟，填寫「深入成熟」、「一般」或「膚淺」]
**評分標準**：
- IF '深入成熟' THEN 立意分數 = 7-10分
- IF '一般' THEN 立意分數 = 4-6分 
- IF '膚淺' THEN 立意分數 = 1-3分
最終立意分數 (1-10): [按此規則給分]
</calc_item>

<calc_item name="取材分數計算">
論據充實度: [評估論據是否充實涵蓋古今中外]
論據適用性: [評估論據是否適用於論述這道題目]
**評分標準**：
- 充實且適用 THEN 取材分數 = 7-10分
- 一般程度 THEN 取材分數 = 4-6分
- 不足或不適用 THEN 取材分數 = 1-3分
最終取材分數 (1-10): [按此規則給分]
</calc_item>

<calc_item name="內容與結構分數限制檢查">
立意分數: [複製上面的立意分數]
取材分數: [複製上面的取材分數]
**強制限制規則**：
- IF (立意分數 ≤ 4 OR 取材分數 ≤ 4) THEN 內容分數上限 = 5分且結構分數上限 = 5分
- 即使扣題很高，但立意或取材低分時，內容和結構都不能超過5分

內容分數修正: [根據上述規則修正內容分數，不得超過5分if條件符合]
結構分數修正: [根據上述規則修正結構分數，不得超過5分if條件符合]
</calc_item>


</step_4_calculation>
</scoring_worksheet>

<grading_json>
{
"content": [複製'內容分數'的'最終分數'],
"expression": [複製'表達分數'的'最終分數'],
"structure": [複製'結構分數'的'最終分數'],
"radar": {
"立意": [複製'扣題分數'的'扣題基準分數'],
"取材": [複製'內容分數'的'最終分數'],
"扣題": [複製'扣題分數'的'扣題基準分數'],
"詳略": [複製'結構分數'的'最終分數'],
"文筆": [複製'表達分數'的'最終分數']
}
}
</grading_json>

<critique>
[根據「教學筆記」對文章進行點評，可從立意、取材、扣題、詳略、文筆等不同角度點評。必須以數字編號列點方式呈現2-3點核心評論。]
</critique>

<suggestions>
[基於 <critique> 的內容，提出改善建議。]
</suggestions>

<rewrite_example>
[提供一段約150-200字的改寫範例。]
</rewrite_example>

---
### 待評核文章資訊
${basePrompt}

### 語境參考資料
[DSE 評核準則]: ${dsePrinciples}
[5** 級數範文]: ${fiveStarExamplesText}

### 語氣要求
<critique> 和 <suggestions> 的語氣：${toneNote}
<rewrite_example> 的語氣：請使用嚴肅正經的語氣。


### 【重要】概念辨識檢查清單
在評分前，必須完成以下檢查：
□ 題目核心概念是什麼？
□ 文章主要論述什麼概念？ 
□ 兩個概念是否完全相同？
□ 是否存在概念置換問題？

**常見偏題案例**：
- 題目《論禮貌》→ 文章論述禮物/送禮 = 偏題
- 題目《論堅持》→ 文章論述堅定 = 偏題
- 題目《論競爭》→ 文章論述合作 = 偏題

記住：邏輯相關 ≠ 概念相同，必須嚴格區分！



`;
}
}

/**
 * 【最終修訂版】顯示完整的點評、評分系統，並根據最終等級和所選閱卷員調整內容
 * @param {string} containerId - 顯示結果的容器ID
 * @param {string} originalApiResponse - 原始模型的API回應
 * @param {string} llama3ApiResponse - 驗證模型的API回應 (可選)
 * @param {string} uniqueIdPrefix - 用於區分不同評分系統的唯一前綴
 * @param {string} fullTextContent - 用戶提交的完整文章內容
 */
async function displayFullCommentWithGrading(containerId, originalApiResponse, llama3ApiResponse, uniqueIdPrefix, fullTextContent) {
    const instanceName = `${uniqueIdPrefix}_radarChartInstance`;
    if (window[instanceName]) {
        window[instanceName].destroy();
        window[instanceName] = null;
    }

    const resultContainer = document.getElementById(containerId);
    
    let reviewerName = "陳SIR";
    let reviewerSelect;
    
    if (uniqueIdPrefix === 'narrative') {
        reviewerSelect = document.getElementById('writingReviewer');
    } else if (uniqueIdPrefix === 'argument') {
        reviewerSelect = document.getElementById('argumentReviewer');
    }

    if (reviewerSelect) {
        reviewerName = reviewerSelect.options[reviewerSelect.selectedIndex].text;
        reviewerName = reviewerName.replace(/\s*\(預設\)\s*/, ''); 
    }
    
    let finalHTML = `<h3>${reviewerName}點評：</h3>`;
    
    let scoresForDisplay = null;
    let finalGradeForDisplay = "評級中"; 

    const critiqueMatch = originalApiResponse.match(/<critique>([\s\S]*?)<\/critique>/);
    const suggestionsMatch = originalApiResponse.match(/<suggestions>([\s\S]*?)<\/suggestions>/);
    const rewriteMatch = originalApiResponse.match(/<rewrite_example>([\s\S]*?)<\/rewrite_example>/);
    const originalGradingMatch = originalApiResponse.match(/<grading_json>([\s\S]*?)<\/grading_json>/);
    
    if (uniqueIdPrefix === 'narrative') {
        const llama3GradingMatch = llama3ApiResponse ? llama3ApiResponse.match(/<grading_json>([\s\S]*?)<\/grading_json>/) : null;
        if (originalGradingMatch && originalGradingMatch[1] && llama3GradingMatch && llama3GradingMatch[1]) {
             try {
                const originalScores = JSON.parse(originalGradingMatch[1].trim());
                const llama3Scores = JSON.parse(llama3GradingMatch[1].trim());
                
                console.log("--- 雙模型評分驗證 (敘事抒情文) ---");
                console.log("現有模型 (Qwen) 原始評分:", JSON.parse(JSON.stringify(originalScores)));
                console.log("驗證模型 (Llama-3) 原始評分:", JSON.parse(JSON.stringify(llama3Scores)));
                
                const applyV8Rules = (scores) => {
                    let s = JSON.parse(JSON.stringify(scores)); 
                    s.radar = s.radar || {};
                    if (s.radar && s.radar.扣題 !== undefined) {
                        let final = { kouTi: s.radar.扣題, xiangLue: s.radar.詳略, structure: s.structure, liYi: s.radar.立意, quCai: s.radar.取材, ciHui: s.radar.詞彙, wenXueXing: s.radar.文學性, expression: s.expression, content: s.content };
                        if (final.kouTi >= 5) { final.liYi = Math.max(final.liYi, 5); final.quCai = Math.max(final.quCai, 5); }
                        if (final.kouTi <= 5) { final.liYi = Math.min(final.liYi, 5); final.quCai = Math.min(final.quCai, 5); }
                        if (final.kouTi <= 4) { final.xiangLue = Math.min(final.xiangLue, 4); final.structure = Math.min(final.structure, 4); }
                        if (final.ciHui <= 6 && final.wenXueXing <= 6) { final.liYi = Math.min(final.liYi, 6); final.quCai = Math.min(final.quCai, 6); }
                        if (!(final.liYi >= 7 && final.quCai >= 7)) { final.ciHui = Math.min(final.ciHui, 8); final.wenXueXing = Math.min(final.wenXueXing, 8); }
                        final.quCai = Math.min(final.quCai, final.liYi);
                        if (final.kouTi <= 4) { let t = final.kouTi; t = Math.min(t, 4); t = Math.max(t, 2); final.content = t; }
                        else { if (final.liYi === 10 && final.quCai === 10) final.content = 9; else if (final.liYi === 9 && final.quCai === 9) final.content = 8; else if (final.liYi === 8 && final.quCai === 8) final.content = 7; else final.content = Math.round((final.liYi + final.quCai) / 2); }
                        if (final.ciHui < 8 || final.wenXueXing < 8) { final.content = Math.min(final.content, 7); }
                        if (final.ciHui === final.wenXueXing) { final.expression = final.ciHui - 1; } else { final.expression = Math.min(final.ciHui, final.wenXueXing); }
                        const structureLowerBound = final.content - 1;
                        final.structure = Math.min(final.structure, final.content);
                        final.structure = Math.max(final.structure, structureLowerBound);
                        s.content = final.content; s.expression = final.expression; s.structure = final.structure;
                        s.radar.立意 = final.liYi; s.radar.取材 = final.quCai; s.radar.詳略 = final.xiangLue;
                        s.radar.詞彙 = final.ciHui; s.radar.文學性 = final.wenXueXing; s.radar.扣題 = final.kouTi;
                    }
                    return s;
                };
                
                const applyWordCountRule = (scores, textContent) => {
                     let s = JSON.parse(JSON.stringify(scores));
                     const wordCount = textContent.length;
                     if (wordCount < 900) {
                        s.content = Math.min(s.content, 5); s.structure = Math.min(s.structure, 5);
                        if (s.radar) { s.radar.立意 = Math.min(s.radar.立意, 5); s.radar.取材 = Math.min(s.radar.取材, 5); s.radar.詳略 = Math.min(s.radar.詳略, 5); }
                     }
                     return s;
                };

                let finalQwenScores = applyV8Rules(originalScores);
                finalQwenScores = applyWordCountRule(finalQwenScores, fullTextContent);
                let finalLlama3Scores = applyWordCountRule(llama3Scores, fullTextContent);
                finalLlama3Scores = applyContentStructureRule(finalLlama3Scores);

                console.log("Qwen V8規則後分數:", JSON.parse(JSON.stringify(finalQwenScores)));
                console.log("Llama-3 (應用所有規則後)分數:", JSON.parse(JSON.stringify(finalLlama3Scores)));

                const totalQwen = (finalQwenScores.content * 4) + (finalQwenScores.expression * 3) + (finalQwenScores.structure * 2) + 5 + 1;
                const totalLlama3 = (finalLlama3Scores.content * 4) + (finalLlama3Scores.expression * 3) + (finalLlama3Scores.structure * 2) + 5 + 1;
                
                if (totalLlama3 > totalQwen) {
                    scoresForDisplay = finalLlama3Scores;
                    console.log("決策: Llama-3 最終總分較高，採用其結果。");
                } else {
                    scoresForDisplay = finalQwenScores;
                    console.log("決策: Qwen 最終總分較高或相等，採用其結果。");
                }

            } catch (e) {
                console.error("解析、比對或應用評分規則時出錯:", e);
                scoresForDisplay = null;
            }
        } else {
            console.warn("敘事抒情文缺少雙模型評分資料，無法進行驗證。");
            scoresForDisplay = null;
        }
    } 
    else if (uniqueIdPrefix === 'argument') {
        if (originalGradingMatch && originalGradingMatch[1]) {
             try {
                const originalScores = JSON.parse(originalGradingMatch[1].trim());
                console.log("--- 單模型原始評分 (議論文) ---");
                console.log("模型原始評分 (未經處理):", JSON.parse(JSON.stringify(originalScores)));
                scoresForDisplay = originalScores;

             } catch(e) {
                console.error("解析議論文原始評分時出錯:", e);
                scoresForDisplay = null;
             }
        } else {
             console.warn("議論文缺少評分資料，無法進行處理。");
             scoresForDisplay = null;
        }
    } else {
        console.warn("未知的文章類型或評分資料缺失。");
        scoresForDisplay = null;
    }
    
    if (scoresForDisplay) {
        scoresForDisplay = applyFinalConsistencyRule(scoresForDisplay);
        const finalTotalScoreAfterRules = (scoresForDisplay.content * 4) + (scoresForDisplay.expression * 3) + (scoresForDisplay.structure * 2) + 5 + 1;
        finalGradeForDisplay = determineGrade(Math.min(finalTotalScoreAfterRules, 100));
        console.log("最終把關規則後的分數:", JSON.parse(JSON.stringify(scoresForDisplay)));
        console.log("基於最終分數重新計算的總分:", finalTotalScoreAfterRules);
        console.log("基於最終分數重新計算的等級:", finalGradeForDisplay);
    }

    if (scoresForDisplay) {
        const wordCount = fullTextContent.length;
        if (wordCount < 500) {
            console.log(`字數嚴重不足 (${wordCount}字)，強制評為等級1。`);
            scoresForDisplay = {
                content: 1, 
                expression: 1, 
                structure: 1, 
                radar: { "立意": 1, "取材": 1, "扣題": 1, "詳略": 1, "詞彙": 1, "文學性": 1 }
            };
            finalGradeForDisplay = "1";
        }
        else if (wordCount < 800) {
            const gradeHierarchy = ["1", "2", "3", "4", "5", "5*", "5**"];
            const originalGradeIndex = gradeHierarchy.indexOf(finalGradeForDisplay);
            const maxGradeIndex = gradeHierarchy.indexOf("3");
            if (originalGradeIndex > maxGradeIndex) {
                console.log(`字數不足800字 (${wordCount}字)，原等級 ${finalGradeForDisplay} 被強制降為最高等級3。`);
                finalGradeForDisplay = "3";
            }
        }
    }

    const originalCritiqueText = critiqueMatch ? critiqueMatch[1].trim() : "未生成點評";
    let finalCritiqueText = originalCritiqueText;
    let critiqueRewriteInstruction = "";

    if (finalGradeForDisplay === "5**") {
        critiqueRewriteInstruction = "點評中應為讚賞。請完全移除所有批評或負面評價，只保留或改寫為讚賞和肯定。";
    } else if (finalGradeForDisplay === "5*" || finalGradeForDisplay === "5") {
        critiqueRewriteInstruction = "點評主要以讚賞為主。請保留主要的優點分析，可以提及一兩個微小的、建設性的改進建議，但整體基調必須是正面的。";
    } else if (finalGradeForDisplay === "4") {
        critiqueRewriteInstruction = "點評應有褒有貶。請確保評論中既包含對優點的肯定，也包含對主要缺點的明確指出，兩者份量應大致均衡。";
    } else {
        critiqueRewriteInstruction = "點評以批評為主。請集中分析文章存在的核心問題，指出需要優先改進的地方。可以簡單提及一兩個做得尚可的地方作為鼓勵，但主要篇幅應用於批評。";
    }
    
    const rewritePrompt = `你是一個中文科老師的助手，你的任務是根據最終的評級，調整一篇已寫好的點評的語氣。

    ### 原始文章
    ${fullTextContent}

    ### 原始點評
    ${originalCritiqueText}

    ### 最終等級
    ${finalGradeForDisplay}

    ### 語氣調整指令
    ${critiqueRewriteInstruction}

    ### 你的任務
    請根據「語氣調整指令」，重寫「原始點評」。
    - 你的輸出**只能**是重寫後的點評文字。
    - 保持原有的列點格式。
    - **絕對不要**包含任何額外的解釋、標題或XML標籤。直接輸出調整後的點評即可。`;

    try {
        finalCritiqueText = await callReadingAPI(rewritePrompt, 0.5); 
    } catch (e) {
        console.error("重寫點評失敗，將使用原始點評:", e);
        finalCritiqueText = originalCritiqueText;
    }

    if (scoresForDisplay) {
        finalHTML += createGradingSystemHTML(uniqueIdPrefix);
    } else {
        finalHTML += "<p>評等資料不完整，無法顯示分數。</p>";
    }
    if (finalCritiqueText) {
        finalHTML += createBulletedListHTML("點評", finalCritiqueText);
    }
    if (suggestionsMatch && suggestionsMatch[1]) {
        finalHTML += createBulletedListHTML("建議", suggestionsMatch[1].trim());
    }
    if (rewriteMatch && rewriteMatch[1]) {
        // 【核心修訂】在這裡移除「改寫範例」中的星號
        const rewriteContent = rewriteMatch[1].trim().replace(/\*/g, '').replace(/\n/g, '<br>');
        finalHTML += `<div class="rewrite-explanation-container"><div class="rewrite-explanation-card"><h3>改寫範例</h3><p>${rewriteContent}</p></div></div>`;
    }

    resultContainer.innerHTML = finalHTML;

    if (scoresForDisplay) {
        initializeGradingSystem(uniqueIdPrefix, scoresForDisplay, finalGradeForDisplay);
    }
}


// =======================================================
// === 評等系統邏輯結束 ===
// =======================================================

document.addEventListener('DOMContentLoaded', function() {

// --- 為動態生成的「自訂題目」輸入框加上排除標記 ---
const originalShowCustomTopicInput = window.showCustomTopicInput;
window.showCustomTopicInput = function(buttonElement) {
originalShowCustomTopicInput(buttonElement);
const customTopicInput = document.getElementById('customTopic');
if (customTopicInput) {
customTopicInput.classList.add('no-modal-editor');
}
// For writing custom topic with focus and plot
const customTitle = document.getElementById('customTitle');
const customFocus = document.getElementById('customFocus');
const customPlot = document.getElementById('customPlot');
if(customTitle) customTitle.classList.add('no-modal-editor');
if(customFocus) customFocus.classList.add('no-modal-editor');
if(customPlot) customPlot.classList.add('no-modal-editor');
};

const originalShowArgumentCustomTopicInput = window.showArgumentCustomTopicInput;
window.showArgumentCustomTopicInput = function(buttonElement) {
originalShowArgumentCustomTopicInput(buttonElement);
const argumentCustomTopicInput = document.getElementById('argumentCustomTopic');
if (argumentCustomTopicInput) {
argumentCustomTopicInput.classList.add('no-modal-editor');
}
};

const originalShowExpandCustomTopicInput = window.showExpandCustomTopicInput;
window.showExpandCustomTopicInput = function(buttonElement) {
originalShowExpandCustomTopicInput(buttonElement);
const container = document.getElementById('expandCustomTopicInputArea');
if (container) {
container.querySelectorAll('input[type="text"], textarea').forEach(el => el.classList.add('no-modal-editor'));
}
};

// --- 懸浮視窗核心邏輯 ---
const modal = document.getElementById('outline-editor-modal');
const modalTextarea = document.getElementById('modal-textarea');
const modalTitle = document.getElementById('modal-title');
const modalSaveBtn = document.getElementById('modal-save-btn');
const modalCloseBtn = document.getElementById('modal-close-btn');

if (!modal || !modalTextarea || !modalSaveBtn || !modalCloseBtn) {
console.error("懸浮視窗的 HTML 結構不完整或未找到！");
return;
}

let currentEditingElement = null;

function openModalEditor(element) {
currentEditingElement = element;
modalTextarea.value = currentEditingElement.value;
let titleText = '編輯內容';

if (element.id === 'writingContent' || element.id === 'argumentWritingContent') {
titleText = '輸入您的文章';
} else {
const parentTableCell = element.closest('td');
if (parentTableCell) {
const parentRow = parentTableCell.closest('tr');
if (parentRow) {
const headerCell = parentRow.cells[0];
const table = parentRow.closest('table');
if (table && table.rows.length > 0) {
const columnHeaderCell = table.rows[0].cells[parentTableCell.cellIndex];
const rowTitle = headerCell ? headerCell.textContent.trim().replace(/[:：]/g, '') : '';
const colTitle = columnHeaderCell ? columnHeaderCell.textContent.trim().replace(/[:：]/g, '') : '';
if (rowTitle && colTitle && rowTitle !== colTitle) {
titleText = `編輯「${rowTitle}」的「${colTitle}」`;
} else if (rowTitle) {
titleText = `編輯「${rowTitle}」`;
} else if (colTitle) {
titleText = `編輯「${colTitle}」`;
}
}
}
} else {
let associatedLabel = document.querySelector(`label[for="${element.id}"]`);
if (!associatedLabel) {
const parentContainer = element.closest('div');
if (parentContainer) {
associatedLabel = parentContainer.querySelector('label');
}
}
if (associatedLabel) {
titleText = `編輯「${associatedLabel.textContent.trim().replace(/[:：]/g, '')}」`;
}
}
}
modalTitle.textContent = titleText;
modal.style.display = 'flex';
modalTextarea.focus();
}

function closeModalEditor() {
modal.style.display = 'none';
currentEditingElement = null;
}

function saveAndCloseEditor() {
if (currentEditingElement) {
currentEditingElement.value = modalTextarea.value;
if (currentEditingElement.id === 'expandContent') {
updateCharCount();
}
}
closeModalEditor();
}

document.body.addEventListener('click', function(event) {
const target = event.target;
const isTextInput = target.tagName === 'INPUT' && target.type === 'text';
const isTextarea = target.tagName === 'TEXTAREA';
if ((isTextInput || isTextarea) && !target.classList.contains('no-modal-editor') && target.id !== 'modal-textarea') {
event.preventDefault();
openModalEditor(target);
}
});

modalSaveBtn.addEventListener('click', saveAndCloseEditor);
modalCloseBtn.addEventListener('click', closeModalEditor);
modal.addEventListener('click', function(event) {
if (event.target === modal) {
closeModalEditor();
}
});

// --- OCR 整合邏輯 ---
const ocrBtn = document.getElementById('modal-ocr-btn');
let ocrWindow = null;
const VERCEL_OCR_URL = 'https://gemini-ocr-proxy.vercel.app/';

if (ocrBtn) {
ocrBtn.addEventListener('click', function() {
if (ocrWindow && !ocrWindow.closed) {
ocrWindow.focus();
return;
}
ocrWindow = window.open(VERCEL_OCR_URL, 'OCRWindow', 'width=650,height=850,scrollbars=yes,resizable=yes');
});
}

window.addEventListener('message', function(event) {
if (event.origin !== new URL(VERCEL_OCR_URL).origin) {
console.warn('收到來源不明的訊息，已忽略:', event.origin);
return;
}
if (event.data && event.data.type === 'ocrResult') {
const ocrText = event.data.text;
modalTextarea.value += (modalTextarea.value.trim() ? '\n' : '') + ocrText;
if (ocrWindow) {
ocrWindow.close();
}
modalTextarea.focus();
}
});
});

/**
 * 【最終把關規則修訂 v3】
 * 當「扣題」分數為 4 分或以下時，強制將多個核心項目分數的上限限制在 4 分。
 * @param {object} scores - 從 AI 模型解析或初步處理後的原始評分物件。
 * @returns {object} - 經過此規則嚴格調整後的最終評分物件。
 */
function applyFinalConsistencyRule(scores) {
    // 建立一個分數物件的深層複本，避免直接修改傳入的物件
    let s = JSON.parse(JSON.stringify(scores)); 
    
    // 從 radar 物件中安全地獲取「扣題」分數，若不存在則預設為 0
    const kouTi = s.radar ? s.radar.扣題 || 0 : 0;
    
    // 【核心修訂】將觸發條件從 <= 5 改為 <= 4
    if (kouTi <= 4) {
        console.log(`觸發扣題分數把關規則 v3：偵測到扣題分數 (${kouTi}) 低於或等於 4，將相關分數上限設為 4。`);

        // 使用 Math.min() 確保分數不會超過 4。
        // 如果原始分數低於 4（例如 3），則會保留較低的 3 分。
        // 如果原始分數高於 4（例如 6），則會被強制降為 4 分。
        
        // 1. 強制限制雷達圖中的「立意」、「取材」、「詳略」分數
        if (s.radar) {
            s.radar.立意 = Math.min(s.radar.立意, 4);
            s.radar.取材 = Math.min(s.radar.取材, 4);
            s.radar.詳略 = Math.min(s.radar.詳略, 4);
        }

        // 2. 強制限制總項分數中的「內容」和「結構」分數
        s.content = Math.min(s.content, 4);
        s.structure = Math.min(s.structure, 4);
    }
    
    // 在控制台中輸出日誌，方便追蹤規則是否被正確應用及其調整結果
    console.log(`扣題把關規則 v3 應用後：扣題=${kouTi}，調整後立意=${s.radar ? s.radar.立意 : 'N/A'}，取材=${s.radar ? s.radar.取材 : 'N/A'}，詳略=${s.radar ? s.radar.詳略 : 'N/A'}，內容=${s.content}，結構=${s.structure}`);
    
    // 返回經過嚴格調整後的分數物件
    return s;
}


// 頁面加載時初始化
document.addEventListener("DOMContentLoaded", function() {
// 預設選中並顯示第一個範疇
const defaultButton = document.getElementById('writingBtn');
if (defaultButton) {
showContainer('writingContainer', defaultButton);
}
});

</script>

<footer class="copyright-footer">
<p>Copyright © 2025 陳冠健. All rights reserved.</p>
</footer>

<!-- === 大綱編輯懸浮視窗 (修正版) === -->
<div id="outline-editor-modal" class="outline-modal-overlay">
<div class="outline-modal-content">
<h3 id="modal-title">編輯內容</h3>
<textarea id="modal-textarea" rows="15"></textarea>
<div class="modal-buttons">
<!-- 【新增的按鈕】 -->
<button id="modal-ocr-btn" class="btn-action" style="background-color: #17a2b8;">OCR</button>

<button id="modal-save-btn" class="btn-action">輸入</button>
</div>
<button id="modal-close-btn" class="preview-close-btn" title="關閉">&times;</button>
</div>
</div>

</body>
</html>
